import require$$0 from 'assert';
import require$$1 from 'async';
import require$$0$1 from 'path';
import require$$1$1 from 'fs';
import require$$6 from 'web-worker';
import require$$4 from 'promise-throttle';
import require$$5 from 'request-promise';
import require$$6$1 from 'http';
import require$$7 from 'https';
import require$$8 from 'crypto-js';
import require$$29 from 'child_process';

var moneroJavascript = {exports: {}};

var biginteger = {};

/*
	JavaScript BigInteger library version 0.9.1
	http://silentmatt.com/biginteger/

	Copyright (c) 2009 Matthew Crumley <email@matthewcrumley.com>
	Copyright (c) 2010,2011 by John Tobey <John.Tobey@gmail.com>
	Licensed under the MIT license.

	Support for arbitrary internal representation base was added by
	Vitaly Magerya.
*/

(function (exports) {
	/*

	This file has been modified by Paul Shapiro:

	1. to bring in the function lowVal which was written by Lucas Jones
	2. to expose CONSTRUCT

	*/
	/*
		File: biginteger.js

		Exports:

			<BigInteger>
	*/
	(function(exports) {
	/*
		Class: BigInteger
		An arbitrarily-large integer.

		<BigInteger> objects should be considered immutable. None of the "built-in"
		methods modify *this* or their arguments. All properties should be
		considered private.

		All the methods of <BigInteger> instances can be called "statically". The
		static versions are convenient if you don't already have a <BigInteger>
		object.

		As an example, these calls are equivalent.

		> BigInteger(4).multiply(5); // returns BigInteger(20);
		> BigInteger.multiply(4, 5); // returns BigInteger(20);

		> var a = 42;
		> var a = BigInteger.toJSValue("0b101010"); // Not completely useless...
	*/

	var CONSTRUCT = {}; // Unique token to call "private" version of constructor

	/*
		Constructor: BigInteger()
		Convert a value to a <BigInteger>.

		Although <BigInteger()> is the constructor for <BigInteger> objects, it is
		best not to call it as a constructor. If *n* is a <BigInteger> object, it is
		simply returned as-is. Otherwise, <BigInteger()> is equivalent to <parse>
		without a radix argument.

		> var n0 = BigInteger();	  // Same as <BigInteger.ZERO>
		> var n1 = BigInteger("123"); // Create a new <BigInteger> with value 123
		> var n2 = BigInteger(123);   // Create a new <BigInteger> with value 123
		> var n3 = BigInteger(n2);	// Return n2, unchanged

		The constructor form only takes an array and a sign. *n* must be an
		array of numbers in little-endian order, where each digit is between 0
		and BigInteger.base.  The second parameter sets the sign: -1 for
		negative, +1 for positive, or 0 for zero. The array is *not copied and
		may be modified*. If the array contains only zeros, the sign parameter
		is ignored and is forced to zero.

		> new BigInteger([5], -1): create a new BigInteger with value -5

		Parameters:

			n - Value to convert to a <BigInteger>.

		Returns:

			A <BigInteger> value.

		See Also:

			<parse>, <BigInteger>
	*/
	function BigInteger(n, s, token) {
		if (token !== CONSTRUCT) {
			if (n instanceof BigInteger) {
				return n;
			}
			else if (typeof n === "undefined") {
				return ZERO;
			}
			return BigInteger.parse(n);
		}

		n = n || [];  // Provide the nullary constructor for subclasses.
		while (n.length && !n[n.length - 1]) {
			--n.length;
		}
		this._d = n;
		this._s = n.length ? (s || 1) : 0;
	}
	BigInteger.CONSTRUCT = CONSTRUCT; // added by PS to actually use the constructor

	BigInteger._construct = function(n, s) {
		return new BigInteger(n, s, CONSTRUCT);
	};

	// Base-10 speedup hacks in parse, toString, exp10 and log functions
	// require base to be a power of 10. 10^7 is the largest such power
	// that won't cause a precision loss when digits are multiplied.
	var BigInteger_base = 10000000;
	var BigInteger_base_log10 = 7;

	BigInteger.base = BigInteger_base;
	BigInteger.base_log10 = BigInteger_base_log10;

	var ZERO = new BigInteger([], 0, CONSTRUCT);
	// Constant: ZERO
	// <BigInteger> 0.
	BigInteger.ZERO = ZERO;

	var ONE = new BigInteger([1], 1, CONSTRUCT);
	// Constant: ONE
	// <BigInteger> 1.
	BigInteger.ONE = ONE;

	var M_ONE = new BigInteger(ONE._d, -1, CONSTRUCT);
	// Constant: M_ONE
	// <BigInteger> -1.
	BigInteger.M_ONE = M_ONE;

	// Constant: _0
	// Shortcut for <ZERO>.
	BigInteger._0 = ZERO;

	// Constant: _1
	// Shortcut for <ONE>.
	BigInteger._1 = ONE;

	/*
		Constant: small
		Array of <BigIntegers> from 0 to 36.

		These are used internally for parsing, but useful when you need a "small"
		<BigInteger>.

		See Also:

			<ZERO>, <ONE>, <_0>, <_1>
	*/
	BigInteger.small = [
		ZERO,
		ONE,
		/* Assuming BigInteger_base > 36 */
		new BigInteger( [2], 1, CONSTRUCT),
		new BigInteger( [3], 1, CONSTRUCT),
		new BigInteger( [4], 1, CONSTRUCT),
		new BigInteger( [5], 1, CONSTRUCT),
		new BigInteger( [6], 1, CONSTRUCT),
		new BigInteger( [7], 1, CONSTRUCT),
		new BigInteger( [8], 1, CONSTRUCT),
		new BigInteger( [9], 1, CONSTRUCT),
		new BigInteger([10], 1, CONSTRUCT),
		new BigInteger([11], 1, CONSTRUCT),
		new BigInteger([12], 1, CONSTRUCT),
		new BigInteger([13], 1, CONSTRUCT),
		new BigInteger([14], 1, CONSTRUCT),
		new BigInteger([15], 1, CONSTRUCT),
		new BigInteger([16], 1, CONSTRUCT),
		new BigInteger([17], 1, CONSTRUCT),
		new BigInteger([18], 1, CONSTRUCT),
		new BigInteger([19], 1, CONSTRUCT),
		new BigInteger([20], 1, CONSTRUCT),
		new BigInteger([21], 1, CONSTRUCT),
		new BigInteger([22], 1, CONSTRUCT),
		new BigInteger([23], 1, CONSTRUCT),
		new BigInteger([24], 1, CONSTRUCT),
		new BigInteger([25], 1, CONSTRUCT),
		new BigInteger([26], 1, CONSTRUCT),
		new BigInteger([27], 1, CONSTRUCT),
		new BigInteger([28], 1, CONSTRUCT),
		new BigInteger([29], 1, CONSTRUCT),
		new BigInteger([30], 1, CONSTRUCT),
		new BigInteger([31], 1, CONSTRUCT),
		new BigInteger([32], 1, CONSTRUCT),
		new BigInteger([33], 1, CONSTRUCT),
		new BigInteger([34], 1, CONSTRUCT),
		new BigInteger([35], 1, CONSTRUCT),
		new BigInteger([36], 1, CONSTRUCT)
	];

	// Used for parsing/radix conversion
	BigInteger.digits = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");

	/*
		Method: toString
		Convert a <BigInteger> to a string.

		When *base* is greater than 10, letters are upper case.

		Parameters:

			base - Optional base to represent the number in (default is base 10).
				   Must be between 2 and 36 inclusive, or an Error will be thrown.

		Returns:

			The string representation of the <BigInteger>.
	*/
	BigInteger.prototype.toString = function(base) {
		base = +base || 10;
		if (base < 2 || base > 36) {
			throw new Error("illegal radix " + base + ".");
		}
		if (this._s === 0) {
			return "0";
		}
		if (base === 10) {
			var str = this._s < 0 ? "-" : "";
			str += this._d[this._d.length - 1].toString();
			for (var i = this._d.length - 2; i >= 0; i--) {
				var group = this._d[i].toString();
				while (group.length < BigInteger_base_log10) group = '0' + group;
				str += group;
			}
			return str;
		}
		else {
			var numerals = BigInteger.digits;
			base = BigInteger.small[base];
			var sign = this._s;

			var n = this.abs();
			var digits = [];
			var digit;

			while (n._s !== 0) {
				var divmod = n.divRem(base);
				n = divmod[0];
				digit = divmod[1];
				// TODO: This could be changed to unshift instead of reversing at the end.
				// Benchmark both to compare speeds.
				digits.push(numerals[digit.valueOf()]);
			}
			return (sign < 0 ? "-" : "") + digits.reverse().join("");
		}
	};

	// Verify strings for parsing
	BigInteger.radixRegex = [
		/^$/,
		/^$/,
		/^[01]*$/,
		/^[012]*$/,
		/^[0-3]*$/,
		/^[0-4]*$/,
		/^[0-5]*$/,
		/^[0-6]*$/,
		/^[0-7]*$/,
		/^[0-8]*$/,
		/^[0-9]*$/,
		/^[0-9aA]*$/,
		/^[0-9abAB]*$/,
		/^[0-9abcABC]*$/,
		/^[0-9a-dA-D]*$/,
		/^[0-9a-eA-E]*$/,
		/^[0-9a-fA-F]*$/,
		/^[0-9a-gA-G]*$/,
		/^[0-9a-hA-H]*$/,
		/^[0-9a-iA-I]*$/,
		/^[0-9a-jA-J]*$/,
		/^[0-9a-kA-K]*$/,
		/^[0-9a-lA-L]*$/,
		/^[0-9a-mA-M]*$/,
		/^[0-9a-nA-N]*$/,
		/^[0-9a-oA-O]*$/,
		/^[0-9a-pA-P]*$/,
		/^[0-9a-qA-Q]*$/,
		/^[0-9a-rA-R]*$/,
		/^[0-9a-sA-S]*$/,
		/^[0-9a-tA-T]*$/,
		/^[0-9a-uA-U]*$/,
		/^[0-9a-vA-V]*$/,
		/^[0-9a-wA-W]*$/,
		/^[0-9a-xA-X]*$/,
		/^[0-9a-yA-Y]*$/,
		/^[0-9a-zA-Z]*$/
	];

	/*
		Function: parse
		Parse a string into a <BigInteger>.

		*base* is optional but, if provided, must be from 2 to 36 inclusive. If
		*base* is not provided, it will be guessed based on the leading characters
		of *s* as follows:

		- "0x" or "0X": *base* = 16
		- "0c" or "0C": *base* = 8
		- "0b" or "0B": *base* = 2
		- else: *base* = 10

		If no base is provided, or *base* is 10, the number can be in exponential
		form. For example, these are all valid:

		> BigInteger.parse("1e9");			  // Same as "1000000000"
		> BigInteger.parse("1.234*10^3");	   // Same as 1234
		> BigInteger.parse("56789 * 10 ** -2"); // Same as 567

		If any characters fall outside the range defined by the radix, an exception
		will be thrown.

		Parameters:

			s - The string to parse.
			base - Optional radix (default is to guess based on *s*).

		Returns:

			a <BigInteger> instance.
	*/
	BigInteger.parse = function(s, base) {
		// Expands a number in exponential form to decimal form.
		// expandExponential("-13.441*10^5") === "1344100";
		// expandExponential("1.12300e-1") === "0.112300";
		// expandExponential(1000000000000000000000000000000) === "1000000000000000000000000000000";
		function expandExponential(str) {
			str = str.replace(/\s*[*xX]\s*10\s*(\^|\*\*)\s*/, "e");

			return str.replace(/^([+\-])?(\d+)\.?(\d*)[eE]([+\-]?\d+)$/, function(x, s, n, f, c) {
				c = +c;
				var l = c < 0;
				var i = n.length + c;
				x = (l ? n : f).length;
				c = ((c = Math.abs(c)) >= x ? c - x + l : 0);
				var z = (new Array(c + 1)).join("0");
				var r = n + f;
				return (s || "") + (l ? r = z + r : r += z).substr(0, i += l ? z.length : 0) + (i < r.length ? "." + r.substr(i) : "");
			});
		}

		s = s.toString();
		if (typeof base === "undefined" || +base === 10) {
			s = expandExponential(s);
		}

		var prefixRE;
		if (typeof base === "undefined") {
			prefixRE = '0[xcb]';
		}
		else if (base == 16) {
			prefixRE = '0x';
		}
		else if (base == 8) {
			prefixRE = '0c';
		}
		else if (base == 2) {
			prefixRE = '0b';
		}
		else {
			prefixRE = '';
		}
		var parts = new RegExp('^([+\\-]?)(' + prefixRE + ')?([0-9a-z]*)(?:\\.\\d*)?$', 'i').exec(s);
		if (parts) {
			var sign = parts[1] || "+";
			var baseSection = parts[2] || "";
			var digits = parts[3] || "";

			if (typeof base === "undefined") {
				// Guess base
				if (baseSection === "0x" || baseSection === "0X") { // Hex
					base = 16;
				}
				else if (baseSection === "0c" || baseSection === "0C") { // Octal
					base = 8;
				}
				else if (baseSection === "0b" || baseSection === "0B") { // Binary
					base = 2;
				}
				else {
					base = 10;
				}
			}
			else if (base < 2 || base > 36) {
				throw new Error("Illegal radix " + base + ".");
			}

			base = +base;

			// Check for digits outside the range
			if (!(BigInteger.radixRegex[base].test(digits))) {
				throw new Error("Bad digit for radix " + base);
			}

			// Strip leading zeros, and convert to array
			digits = digits.replace(/^0+/, "").split("");
			if (digits.length === 0) {
				return ZERO;
			}

			// Get the sign (we know it's not zero)
			sign = (sign === "-") ? -1 : 1;

			// Optimize 10
			if (base == 10) {
				var d = [];
				while (digits.length >= BigInteger_base_log10) {
					d.push(parseInt(digits.splice(digits.length-BigInteger.base_log10, BigInteger.base_log10).join(''), 10));
				}
				d.push(parseInt(digits.join(''), 10));
				return new BigInteger(d, sign, CONSTRUCT);
			}

			// Do the conversion
			var d = ZERO;
			base = BigInteger.small[base];
			var small = BigInteger.small;
			for (var i = 0; i < digits.length; i++) {
				d = d.multiply(base).add(small[parseInt(digits[i], 36)]);
			}
			return new BigInteger(d._d, sign, CONSTRUCT);
		}
		else {
			throw new Error("Invalid BigInteger format: " + s);
		}
	};

	/*
		Function: add
		Add two <BigIntegers>.

		Parameters:

			n - The number to add to *this*. Will be converted to a <BigInteger>.

		Returns:

			The numbers added together.

		See Also:

			<subtract>, <multiply>, <quotient>, <next>
	*/
	BigInteger.prototype.add = function(n) {
		if (this._s === 0) {
			return BigInteger(n);
		}

		n = BigInteger(n);
		if (n._s === 0) {
			return this;
		}
		if (this._s !== n._s) {
			n = n.negate();
			return this.subtract(n);
		}

		var a = this._d;
		var b = n._d;
		var al = a.length;
		var bl = b.length;
		var sum = new Array(Math.max(al, bl) + 1);
		var size = Math.min(al, bl);
		var carry = 0;
		var digit;

		for (var i = 0; i < size; i++) {
			digit = a[i] + b[i] + carry;
			sum[i] = digit % BigInteger_base;
			carry = (digit / BigInteger_base) | 0;
		}
		if (bl > al) {
			a = b;
			al = bl;
		}
		for (i = size; carry && i < al; i++) {
			digit = a[i] + carry;
			sum[i] = digit % BigInteger_base;
			carry = (digit / BigInteger_base) | 0;
		}
		if (carry) {
			sum[i] = carry;
		}

		for ( ; i < al; i++) {
			sum[i] = a[i];
		}

		return new BigInteger(sum, this._s, CONSTRUCT);
	};

	/*
		Function: negate
		Get the additive inverse of a <BigInteger>.

		Returns:

			A <BigInteger> with the same magnatude, but with the opposite sign.

		See Also:

			<abs>
	*/
	BigInteger.prototype.negate = function() {
		return new BigInteger(this._d, (-this._s) | 0, CONSTRUCT);
	};

	/*
		Function: abs
		Get the absolute value of a <BigInteger>.

		Returns:

			A <BigInteger> with the same magnatude, but always positive (or zero).

		See Also:

			<negate>
	*/
	BigInteger.prototype.abs = function() {
		return (this._s < 0) ? this.negate() : this;
	};

	/*
		Function: subtract
		Subtract two <BigIntegers>.

		Parameters:

			n - The number to subtract from *this*. Will be converted to a <BigInteger>.

		Returns:

			The *n* subtracted from *this*.

		See Also:

			<add>, <multiply>, <quotient>, <prev>
	*/
	BigInteger.prototype.subtract = function(n) {
		if (this._s === 0) {
			return BigInteger(n).negate();
		}

		n = BigInteger(n);
		if (n._s === 0) {
			return this;
		}
		if (this._s !== n._s) {
			n = n.negate();
			return this.add(n);
		}

		var m = this;
		// negative - negative => -|a| - -|b| => -|a| + |b| => |b| - |a|
		if (this._s < 0) {
			m = new BigInteger(n._d, 1, CONSTRUCT);
			n = new BigInteger(this._d, 1, CONSTRUCT);
		}

		// Both are positive => a - b
		var sign = m.compareAbs(n);
		if (sign === 0) {
			return ZERO;
		}
		else if (sign < 0) {
			// swap m and n
			var t = n;
			n = m;
			m = t;
		}

		// a > b
		var a = m._d;
		var b = n._d;
		var al = a.length;
		var bl = b.length;
		var diff = new Array(al); // al >= bl since a > b
		var borrow = 0;
		var i;
		var digit;

		for (i = 0; i < bl; i++) {
			digit = a[i] - borrow - b[i];
			if (digit < 0) {
				digit += BigInteger_base;
				borrow = 1;
			}
			else {
				borrow = 0;
			}
			diff[i] = digit;
		}
		for (i = bl; i < al; i++) {
			digit = a[i] - borrow;
			if (digit < 0) {
				digit += BigInteger_base;
			}
			else {
				diff[i++] = digit;
				break;
			}
			diff[i] = digit;
		}
		for ( ; i < al; i++) {
			diff[i] = a[i];
		}

		return new BigInteger(diff, sign, CONSTRUCT);
	};

	(function() {
		function addOne(n, sign) {
			var a = n._d;
			var sum = a.slice();
			var i = 0;

			while (true) {
				var digit = (a[i] || 0) + 1;
				sum[i] = digit % BigInteger_base;
				if (digit <= BigInteger_base - 1) {
					break;
				}
				++i;
			}

			return new BigInteger(sum, sign, CONSTRUCT);
		}

		function subtractOne(n, sign) {
			var a = n._d;
			var sum = a.slice();
			var i = 0;

			while (true) {
				var digit = (a[i] || 0) - 1;
				if (digit < 0) {
					sum[i] = digit + BigInteger_base;
				}
				else {
					sum[i] = digit;
					break;
				}
				++i;
			}

			return new BigInteger(sum, sign, CONSTRUCT);
		}

		/*
			Function: next
			Get the next <BigInteger> (add one).

			Returns:

				*this* + 1.

			See Also:

				<add>, <prev>
		*/
		BigInteger.prototype.next = function() {
			switch (this._s) {
			case 0:
				return ONE;
			case -1:
				return subtractOne(this, -1);
			// case 1:
			default:
				return addOne(this, 1);
			}
		};

		/*
			Function: prev
			Get the previous <BigInteger> (subtract one).

			Returns:

				*this* - 1.

			See Also:

				<next>, <subtract>
		*/
		BigInteger.prototype.prev = function() {
			switch (this._s) {
			case 0:
				return M_ONE;
			case -1:
				return addOne(this, -1);
			// case 1:
			default:
				return subtractOne(this, 1);
			}
		};
	})();

	/*
		Function: compareAbs
		Compare the absolute value of two <BigIntegers>.

		Calling <compareAbs> is faster than calling <abs> twice, then <compare>.

		Parameters:

			n - The number to compare to *this*. Will be converted to a <BigInteger>.

		Returns:

			-1, 0, or +1 if *|this|* is less than, equal to, or greater than *|n|*.

		See Also:

			<compare>, <abs>
	*/
	BigInteger.prototype.compareAbs = function(n) {
		if (this === n) {
			return 0;
		}

		if (!(n instanceof BigInteger)) {
			if (!isFinite(n)) {
				return(isNaN(n) ? n : -1);
			}
			n = BigInteger(n);
		}

		if (this._s === 0) {
			return (n._s !== 0) ? -1 : 0;
		}
		if (n._s === 0) {
			return 1;
		}

		var l = this._d.length;
		var nl = n._d.length;
		if (l < nl) {
			return -1;
		}
		else if (l > nl) {
			return 1;
		}

		var a = this._d;
		var b = n._d;
		for (var i = l-1; i >= 0; i--) {
			if (a[i] !== b[i]) {
				return a[i] < b[i] ? -1 : 1;
			}
		}

		return 0;
	};

	/*
		Function: compare
		Compare two <BigIntegers>.

		Parameters:

			n - The number to compare to *this*. Will be converted to a <BigInteger>.

		Returns:

			-1, 0, or +1 if *this* is less than, equal to, or greater than *n*.

		See Also:

			<compareAbs>, <isPositive>, <isNegative>, <isUnit>
	*/
	BigInteger.prototype.compare = function(n) {
		if (this === n) {
			return 0;
		}

		n = BigInteger(n);

		if (this._s === 0) {
			return -n._s;
		}

		if (this._s === n._s) { // both positive or both negative
			var cmp = this.compareAbs(n);
			return cmp * this._s;
		}
		else {
			return this._s;
		}
	};

	/*
		Function: isUnit
		Return true iff *this* is either 1 or -1.

		Returns:

			true if *this* compares equal to <BigInteger.ONE> or <BigInteger.M_ONE>.

		See Also:

			<isZero>, <isNegative>, <isPositive>, <compareAbs>, <compare>,
			<BigInteger.ONE>, <BigInteger.M_ONE>
	*/
	BigInteger.prototype.isUnit = function() {
		return this === ONE ||
			this === M_ONE ||
			(this._d.length === 1 && this._d[0] === 1);
	};

	/*
		Function: multiply
		Multiply two <BigIntegers>.

		Parameters:

			n - The number to multiply *this* by. Will be converted to a
			<BigInteger>.

		Returns:

			The numbers multiplied together.

		See Also:

			<add>, <subtract>, <quotient>, <square>
	*/
	BigInteger.prototype.multiply = function(n) {
		// TODO: Consider adding Karatsuba multiplication for large numbers
		if (this._s === 0) {
			return ZERO;
		}

		n = BigInteger(n);
		if (n._s === 0) {
			return ZERO;
		}
		if (this.isUnit()) {
			if (this._s < 0) {
				return n.negate();
			}
			return n;
		}
		if (n.isUnit()) {
			if (n._s < 0) {
				return this.negate();
			}
			return this;
		}
		if (this === n) {
			return this.square();
		}

		var r = (this._d.length >= n._d.length);
		var a = (r ? this : n)._d; // a will be longer than b
		var b = (r ? n : this)._d;
		var al = a.length;
		var bl = b.length;

		var pl = al + bl;
		var partial = new Array(pl);
		var i;
		for (i = 0; i < pl; i++) {
			partial[i] = 0;
		}

		for (i = 0; i < bl; i++) {
			var carry = 0;
			var bi = b[i];
			var jlimit = al + i;
			var digit;
			for (var j = i; j < jlimit; j++) {
				digit = partial[j] + bi * a[j - i] + carry;
				carry = (digit / BigInteger_base) | 0;
				partial[j] = (digit % BigInteger_base) | 0;
			}
			if (carry) {
				digit = partial[j] + carry;
				carry = (digit / BigInteger_base) | 0;
				partial[j] = digit % BigInteger_base;
			}
		}
		return new BigInteger(partial, this._s * n._s, CONSTRUCT);
	};

	// Multiply a BigInteger by a single-digit native number
	// Assumes that this and n are >= 0
	// This is not really intended to be used outside the library itself
	BigInteger.prototype.multiplySingleDigit = function(n) {
		if (n === 0 || this._s === 0) {
			return ZERO;
		}
		if (n === 1) {
			return this;
		}

		var digit;
		if (this._d.length === 1) {
			digit = this._d[0] * n;
			if (digit >= BigInteger_base) {
				return new BigInteger([(digit % BigInteger_base)|0,
						(digit / BigInteger_base)|0], 1, CONSTRUCT);
			}
			return new BigInteger([digit], 1, CONSTRUCT);
		}

		if (n === 2) {
			return this.add(this);
		}
		if (this.isUnit()) {
			return new BigInteger([n], 1, CONSTRUCT);
		}

		var a = this._d;
		var al = a.length;

		var pl = al + 1;
		var partial = new Array(pl);
		for (var i = 0; i < pl; i++) {
			partial[i] = 0;
		}

		var carry = 0;
		for (var j = 0; j < al; j++) {
			digit = n * a[j] + carry;
			carry = (digit / BigInteger_base) | 0;
			partial[j] = (digit % BigInteger_base) | 0;
		}
		if (carry) {
			partial[j] = carry;
		}

		return new BigInteger(partial, 1, CONSTRUCT);
	};

	/*
		Function: square
		Multiply a <BigInteger> by itself.

		This is slightly faster than regular multiplication, since it removes the
		duplicated multiplcations.

		Returns:

			> this.multiply(this)

		See Also:
			<multiply>
	*/
	BigInteger.prototype.square = function() {
		// Normally, squaring a 10-digit number would take 100 multiplications.
		// Of these 10 are unique diagonals, of the remaining 90 (100-10), 45 are repeated.
		// This procedure saves (N*(N-1))/2 multiplications, (e.g., 45 of 100 multiplies).
		// Based on code by Gary Darby, Intellitech Systems Inc., www.DelphiForFun.org

		if (this._s === 0) {
			return ZERO;
		}
		if (this.isUnit()) {
			return ONE;
		}

		var digits = this._d;
		var length = digits.length;
		var imult1 = new Array(length + length + 1);
		var product, carry, k;
		var i;

		// Calculate diagonal
		for (i = 0; i < length; i++) {
			k = i * 2;
			product = digits[i] * digits[i];
			carry = (product / BigInteger_base) | 0;
			imult1[k] = product % BigInteger_base;
			imult1[k + 1] = carry;
		}

		// Calculate repeating part
		for (i = 0; i < length; i++) {
			carry = 0;
			k = i * 2 + 1;
			for (var j = i + 1; j < length; j++, k++) {
				product = digits[j] * digits[i] * 2 + imult1[k] + carry;
				carry = (product / BigInteger_base) | 0;
				imult1[k] = product % BigInteger_base;
			}
			k = length + i;
			var digit = carry + imult1[k];
			carry = (digit / BigInteger_base) | 0;
			imult1[k] = digit % BigInteger_base;
			imult1[k + 1] += carry;
		}

		return new BigInteger(imult1, 1, CONSTRUCT);
	};

	/*
		Function: quotient
		Divide two <BigIntegers> and truncate towards zero.

		<quotient> throws an exception if *n* is zero.

		Parameters:

			n - The number to divide *this* by. Will be converted to a <BigInteger>.

		Returns:

			The *this* / *n*, truncated to an integer.

		See Also:

			<add>, <subtract>, <multiply>, <divRem>, <remainder>
	*/
	BigInteger.prototype.quotient = function(n) {
		return this.divRem(n)[0];
	};

	/*
		Function: divide
		Deprecated synonym for <quotient>.
	*/
	BigInteger.prototype.divide = BigInteger.prototype.quotient;

	/*
		Function: remainder
		Calculate the remainder of two <BigIntegers>.

		<remainder> throws an exception if *n* is zero.

		Parameters:

			n - The remainder after *this* is divided *this* by *n*. Will be
				converted to a <BigInteger>.

		Returns:

			*this* % *n*.

		See Also:

			<divRem>, <quotient>
	*/
	BigInteger.prototype.remainder = function(n) {
		return this.divRem(n)[1];
	};

	/*
		Function: divRem
		Calculate the integer quotient and remainder of two <BigIntegers>.

		<divRem> throws an exception if *n* is zero.

		Parameters:

			n - The number to divide *this* by. Will be converted to a <BigInteger>.

		Returns:

			A two-element array containing the quotient and the remainder.

			> a.divRem(b)

			is exactly equivalent to

			> [a.quotient(b), a.remainder(b)]

			except it is faster, because they are calculated at the same time.

		See Also:

			<quotient>, <remainder>
	*/
	BigInteger.prototype.divRem = function(n) {
		n = BigInteger(n);
		if (n._s === 0) {
			throw new Error("Divide by zero");
		}
		if (this._s === 0) {
			return [ZERO, ZERO];
		}
		if (n._d.length === 1) {
			return this.divRemSmall(n._s * n._d[0]);
		}

		// Test for easy cases -- |n1| <= |n2|
		switch (this.compareAbs(n)) {
		case 0: // n1 == n2
			return [this._s === n._s ? ONE : M_ONE, ZERO];
		case -1: // |n1| < |n2|
			return [ZERO, this];
		}

		var sign = this._s * n._s;
		var a = n.abs();
		var b_digits = this._d;
		var b_index = b_digits.length;
		n._d.length;
		var quot = [];
		var guess;

		var part = new BigInteger([], 0, CONSTRUCT);

		while (b_index) {
			part._d.unshift(b_digits[--b_index]);
			part = new BigInteger(part._d, 1, CONSTRUCT);

			if (part.compareAbs(n) < 0) {
				quot.push(0);
				continue;
			}
			if (part._s === 0) {
				guess = 0;
			}
			else {
				var xlen = part._d.length, ylen = a._d.length;
				var highx = part._d[xlen-1]*BigInteger_base + part._d[xlen-2];
				var highy = a._d[ylen-1]*BigInteger_base + a._d[ylen-2];
				if (part._d.length > a._d.length) {
					// The length of part._d can either match a._d length,
					// or exceed it by one.
					highx = (highx+1)*BigInteger_base;
				}
				guess = Math.ceil(highx/highy);
			}
			do {
				var check = a.multiplySingleDigit(guess);
				if (check.compareAbs(part) <= 0) {
					break;
				}
				guess--;
			} while (guess);

			quot.push(guess);
			if (!guess) {
				continue;
			}
			var diff = part.subtract(check);
			part._d = diff._d.slice();
		}

		return [new BigInteger(quot.reverse(), sign, CONSTRUCT),
			   new BigInteger(part._d, this._s, CONSTRUCT)];
	};

	// Throws an exception if n is outside of (-BigInteger.base, -1] or
	// [1, BigInteger.base).  It's not necessary to call this, since the
	// other division functions will call it if they are able to.
	BigInteger.prototype.divRemSmall = function(n) {
		var r;
		n = +n;
		if (n === 0) {
			throw new Error("Divide by zero");
		}

		var n_s = n < 0 ? -1 : 1;
		var sign = this._s * n_s;
		n = Math.abs(n);

		if (n < 1 || n >= BigInteger_base) {
			throw new Error("Argument out of range");
		}

		if (this._s === 0) {
			return [ZERO, ZERO];
		}

		if (n === 1 || n === -1) {
			return [(sign === 1) ? this.abs() : new BigInteger(this._d, sign, CONSTRUCT), ZERO];
		}

		// 2 <= n < BigInteger_base

		// divide a single digit by a single digit
		if (this._d.length === 1) {
			var q = new BigInteger([(this._d[0] / n) | 0], 1, CONSTRUCT);
			r = new BigInteger([(this._d[0] % n) | 0], 1, CONSTRUCT);
			if (sign < 0) {
				q = q.negate();
			}
			if (this._s < 0) {
				r = r.negate();
			}
			return [q, r];
		}

		var digits = this._d.slice();
		var quot = new Array(digits.length);
		var part = 0;
		var diff = 0;
		var i = 0;
		var guess;

		while (digits.length) {
			part = part * BigInteger_base + digits[digits.length - 1];
			if (part < n) {
				quot[i++] = 0;
				digits.pop();
				diff = BigInteger_base * diff + part;
				continue;
			}
			if (part === 0) {
				guess = 0;
			}
			else {
				guess = (part / n) | 0;
			}

			var check = n * guess;
			diff = part - check;
			quot[i++] = guess;
			if (!guess) {
				digits.pop();
				continue;
			}

			digits.pop();
			part = diff;
		}

		r = new BigInteger([diff], 1, CONSTRUCT);
		if (this._s < 0) {
			r = r.negate();
		}
		return [new BigInteger(quot.reverse(), sign, CONSTRUCT), r];
	};

	/*
		Function: isEven
		Return true iff *this* is divisible by two.

		Note that <BigInteger.ZERO> is even.

		Returns:

			true if *this* is even, false otherwise.

		See Also:

			<isOdd>
	*/
	BigInteger.prototype.isEven = function() {
		var digits = this._d;
		return this._s === 0 || digits.length === 0 || (digits[0] % 2) === 0;
	};

	/*
		Function: isOdd
		Return true iff *this* is not divisible by two.

		Returns:

			true if *this* is odd, false otherwise.

		See Also:

			<isEven>
	*/
	BigInteger.prototype.isOdd = function() {
		return !this.isEven();
	};

	/*
		Function: sign
		Get the sign of a <BigInteger>.

		Returns:

			* -1 if *this* < 0
			* 0 if *this* == 0
			* +1 if *this* > 0

		See Also:

			<isZero>, <isPositive>, <isNegative>, <compare>, <BigInteger.ZERO>
	*/
	BigInteger.prototype.sign = function() {
		return this._s;
	};

	/*
		Function: isPositive
		Return true iff *this* > 0.

		Returns:

			true if *this*.compare(<BigInteger.ZERO>) == 1.

		See Also:

			<sign>, <isZero>, <isNegative>, <isUnit>, <compare>, <BigInteger.ZERO>
	*/
	BigInteger.prototype.isPositive = function() {
		return this._s > 0;
	};

	/*
		Function: isNegative
		Return true iff *this* < 0.

		Returns:

			true if *this*.compare(<BigInteger.ZERO>) == -1.

		See Also:

			<sign>, <isPositive>, <isZero>, <isUnit>, <compare>, <BigInteger.ZERO>
	*/
	BigInteger.prototype.isNegative = function() {
		return this._s < 0;
	};

	/*
		Function: isZero
		Return true iff *this* == 0.

		Returns:

			true if *this*.compare(<BigInteger.ZERO>) == 0.

		See Also:

			<sign>, <isPositive>, <isNegative>, <isUnit>, <BigInteger.ZERO>
	*/
	BigInteger.prototype.isZero = function() {
		return this._s === 0;
	};

	/*
		Function: exp10
		Multiply a <BigInteger> by a power of 10.

		This is equivalent to, but faster than

		> if (n >= 0) {
		>	 return this.multiply(BigInteger("1e" + n));
		> }
		> else { // n <= 0
		>	 return this.quotient(BigInteger("1e" + -n));
		> }

		Parameters:

			n - The power of 10 to multiply *this* by. *n* is converted to a
			javascipt number and must be no greater than <BigInteger.MAX_EXP>
			(0x7FFFFFFF), or an exception will be thrown.

		Returns:

			*this* * (10 ** *n*), truncated to an integer if necessary.

		See Also:

			<pow>, <multiply>
	*/
	BigInteger.prototype.exp10 = function(n) {
		n = +n;
		if (n === 0) {
			return this;
		}
		if (Math.abs(n) > Number(MAX_EXP)) {
			throw new Error("exponent too large in BigInteger.exp10");
		}
		// Optimization for this == 0. This also keeps us from having to trim zeros in the positive n case
		if (this._s === 0) {
			return ZERO;
		}
		if (n > 0) {
			var k = new BigInteger(this._d.slice(), this._s, CONSTRUCT);

			for (; n >= BigInteger_base_log10; n -= BigInteger_base_log10) {
				k._d.unshift(0);
			}
			if (n == 0)
				return k;
			k._s = 1;
			k = k.multiplySingleDigit(Math.pow(10, n));
			return (this._s < 0 ? k.negate() : k);
		} else if (-n >= this._d.length*BigInteger_base_log10) {
			return ZERO;
		} else {
			var k = new BigInteger(this._d.slice(), this._s, CONSTRUCT);

			for (n = -n; n >= BigInteger_base_log10; n -= BigInteger_base_log10) {
				k._d.shift();
			}
			return (n == 0) ? k : k.divRemSmall(Math.pow(10, n))[0];
		}
	};

	/*
		Function: pow
		Raise a <BigInteger> to a power.

		In this implementation, 0**0 is 1.

		Parameters:

			n - The exponent to raise *this* by. *n* must be no greater than
			<BigInteger.MAX_EXP> (0x7FFFFFFF), or an exception will be thrown.

		Returns:

			*this* raised to the *nth* power.

		See Also:

			<modPow>
	*/
	BigInteger.prototype.pow = function(n) {
		if (this.isUnit()) {
			if (this._s > 0) {
				return this;
			}
			else {
				return BigInteger(n).isOdd() ? this : this.negate();
			}
		}

		n = BigInteger(n);
		if (n._s === 0) {
			return ONE;
		}
		else if (n._s < 0) {
			if (this._s === 0) {
				throw new Error("Divide by zero");
			}
			else {
				return ZERO;
			}
		}
		if (this._s === 0) {
			return ZERO;
		}
		if (n.isUnit()) {
			return this;
		}

		if (n.compareAbs(MAX_EXP) > 0) {
			throw new Error("exponent too large in BigInteger.pow");
		}
		var x = this;
		var aux = ONE;
		var two = BigInteger.small[2];

		while (n.isPositive()) {
			if (n.isOdd()) {
				aux = aux.multiply(x);
				if (n.isUnit()) {
					return aux;
				}
			}
			x = x.square();
			n = n.quotient(two);
		}

		return aux;
	};

	/*
		Function: modPow
		Raise a <BigInteger> to a power (mod m).

		Because it is reduced by a modulus, <modPow> is not limited by
		<BigInteger.MAX_EXP> like <pow>.

		Parameters:

			exponent - The exponent to raise *this* by. Must be positive.
			modulus - The modulus.

		Returns:

			*this* ^ *exponent* (mod *modulus*).

		See Also:

			<pow>, <mod>
	*/
	BigInteger.prototype.modPow = function(exponent, modulus) {
		var result = ONE;
		var base = this;

		while (exponent.isPositive()) {
			if (exponent.isOdd()) {
				result = result.multiply(base).remainder(modulus);
			}

			exponent = exponent.quotient(BigInteger.small[2]);
			if (exponent.isPositive()) {
				base = base.square().remainder(modulus);
			}
		}

		return result;
	};

	/*
		Function: log
		Get the natural logarithm of a <BigInteger> as a native JavaScript number.

		This is equivalent to

		> Math.log(this.toJSValue())

		but handles values outside of the native number range.

		Returns:

			log( *this* )

		See Also:

			<toJSValue>
	*/
	BigInteger.prototype.log = function() {
		switch (this._s) {
		case 0:	 return -Infinity;
		case -1: return NaN;
		}

		var l = this._d.length;

		if (l*BigInteger_base_log10 < 30) {
			return Math.log(this.valueOf());
		}

		var N = Math.ceil(30/BigInteger_base_log10);
		var firstNdigits = this._d.slice(l - N);
		return Math.log((new BigInteger(firstNdigits, 1, CONSTRUCT)).valueOf()) + (l - N) * Math.log(BigInteger_base);
	};

	/*
		Function: valueOf
		Convert a <BigInteger> to a native JavaScript integer.

		This is called automatically by JavaScipt to convert a <BigInteger> to a
		native value.

		Returns:

			> parseInt(this.toString(), 10)

		See Also:

			<toString>, <toJSValue>
	*/
	BigInteger.prototype.valueOf = function() {
		return parseInt(this.toString(), 10);
	};

	/*
		Function: toJSValue
		Convert a <BigInteger> to a native JavaScript integer.

		This is the same as valueOf, but more explicitly named.

		Returns:

			> parseInt(this.toString(), 10)

		See Also:

			<toString>, <valueOf>
	*/
	BigInteger.prototype.toJSValue = function() {
		return parseInt(this.toString(), 10);
	};

	/*
		Function: lowVal
		Author: Lucas Jones
	*/
	BigInteger.prototype.lowVal = function () {
		return this._d[0] || 0;
	};

	var MAX_EXP = BigInteger(0x7FFFFFFF);
	// Constant: MAX_EXP
	// The largest exponent allowed in <pow> and <exp10> (0x7FFFFFFF or 2147483647).
	BigInteger.MAX_EXP = MAX_EXP;

	(function() {
		function makeUnary(fn) {
			return function(a) {
				return fn.call(BigInteger(a));
			};
		}

		function makeBinary(fn) {
			return function(a, b) {
				return fn.call(BigInteger(a), BigInteger(b));
			};
		}

		function makeTrinary(fn) {
			return function(a, b, c) {
				return fn.call(BigInteger(a), BigInteger(b), BigInteger(c));
			};
		}

		(function() {
			var i, fn;
			var unary = "toJSValue,isEven,isOdd,sign,isZero,isNegative,abs,isUnit,square,negate,isPositive,toString,next,prev,log".split(",");
			var binary = "compare,remainder,divRem,subtract,add,quotient,divide,multiply,pow,compareAbs".split(",");
			var trinary = ["modPow"];

			for (i = 0; i < unary.length; i++) {
				fn = unary[i];
				BigInteger[fn] = makeUnary(BigInteger.prototype[fn]);
			}

			for (i = 0; i < binary.length; i++) {
				fn = binary[i];
				BigInteger[fn] = makeBinary(BigInteger.prototype[fn]);
			}

			for (i = 0; i < trinary.length; i++) {
				fn = trinary[i];
				BigInteger[fn] = makeTrinary(BigInteger.prototype[fn]);
			}

			BigInteger.exp10 = function(x, n) {
				return BigInteger(x).exp10(n);
			};
		})();
	})();

	exports.BigInteger = BigInteger;
	})(exports );
} (biginteger));

const assert$f = require$$0;
const BigInteger$m = biginteger.BigInteger;

/**
 * MIT License
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * Collection of general purpose utilities.
 * 
 * TODO: could pull in assert and remove these asserts
 * TODO: needs cleanup as ES6+ utility class
 */
class GenUtils$d {
  
  /**
   * Indicates if the given argument is defined.
   * 
   * @param arg is the arg to test
   * @returns true if the given arg is defined, false otherwise
   */
  static isDefined(arg) {
    return typeof arg !== 'undefined';
  }

  /**
   * Indicates if the given argument is undefined.
   * 
   * @param arg is the arg to test
   * @returns true if the given arg is undefined, false otherwise
   */
  static isUndefined(arg) {
    return typeof arg === 'undefined';
  }

  /**
   * Indicates if the given arg is initialized.
   * 
   * @param arg is the arg to test
   * @returns true if the given arg is initialized, false otherwise
   */
  static isInitialized(arg) {
    return arg !== undefined && arg !== null;
  }

  /**
   * Indicates if the given arg is uninitialized.
   * 
   * @param arg is the arg to test
   * @returns true if the given arg is uninitialized, false otherwise
   */
  static isUninitialized(arg) {
    if (!arg) return true;
    return false;
  }

  /**
   * Indicates if the given argument is a number.
   * 
   * @param arg is the argument to test
   * @returns true if the argument is a number, false otherwise
   */
  static isNumber(arg) {
    return !isNaN(parseFloat(arg)) && isFinite(arg);
  }

  /**
   * Indicates if the given argument is an integer.
   * 
   * @param arg is the argument to test
   * @returns true if the given argument is an integer, false otherwise
   */
  static isInt(arg) {
    return arg === parseInt(Number(arg)) && !isNaN(arg) && !isNaN(parseInt(arg, 10));
  }

  /**
   * Indicates if the given argument is an array.
   * 
   * @param arg is the argument to test as being an array
   * @returns true if the argument is an array, false otherwise
   */
  static isArray(arg) {
    return arg instanceof Array && Array.isArray(arg);
  }

  /**
   * Indicates if the given argument is a string.
   * 
   * @param arg is the argument to test as being a string
   * @returns true if the argument is a string, false otherwise
   */
  static isString(arg) {
    return typeof arg === 'string';
  }

  /**
   * Determines if the given argument is a boolean.
   * 
   * @param arg is the argument to test as being a boolean
   * @returns true if the argument is a boolean, false otherwise
   */
  static isBoolean(arg) {
    return typeof(arg) == typeof(true);
  }

  /**
   * Determines if the given argument is a static.
   * 
   * @param arg is the argument to test as being a static
   * @returns true if the argument is a static, false otherwise
   */
  static isFunction(arg) {
    return typeof arg === "static";
  }

  /**
   * Indicates if the given argument is an object and optionally if it has the given constructor name.
   * 
   * @param arg is the argument to test
   * @param obj is an object to test arg instanceof obj (optional)
   * @returns true if the given argument is an object and optionally has the given constructor name
   */
  static isObject(arg, obj) {
    if (!arg) return false;
    if (typeof arg !== 'object') return false;
    if (obj && !(arg instanceof obj)) return false;
    return true;
  }

  /**
   * Determines if all alphabet characters in the given string are upper case.
   * 
   * @param str is the string to test
   * @returns true if the string is upper case, false otherwise
   */
  static isUpperCase(str) {
    return str.toUpperCase() === str;
  }

  /**
   * Determines if all alphabet characters in the given string are lower case.
   * 
   * @param str is the string to test
   * @param true if the string is lower case, false otherwise
   */
  static isLowerCase(str) {
    return str.toLowerCase() === str;
  }

  /**
   * Asserts that the given argument is hex.
   * 
   * @param arg is the argument to assert as hex
   * @param msg is the message to throw if the argument is not hex
   */
  static assertHex(str, msg) {
    GenUtils$d.assertTrue(isHex(str), msg ? msg : "Argument asserted as hex but is not hex");
  }

  /**
   * Indicates if the given argument is a hexidemal string.
   * 
   * Credit: https://github.com/roryrjb/is-hex/blob/master/is-hex.js.
   * 
   * @param str is the string to test
   * @returns true if the given string is hexidecimal, false otherwise
   */
  static isHex(arg) {
    if (typeof arg !== 'string') return false;
    if (arg.length === 0) return false;
    return (arg.match(/([0-9]|[a-f])/gim) || []).length === arg.length;
  }

  /**
   * Determines if the given string is base32.
   */
  static isBase32(str) {
    if (typeof str !== 'string') return false;
    GenUtils$d.assertTrue(str.length > 0, "Cannot determine if empty string is base32");
    return /^[ABCDEFGHIJKLMNOPQRSTUVWXYZ234567]+$/.test(str);
  }

  /**
   * Asserts that the given argument is base58.
   * 
   * @param arg is the argument to assert as base58
   * @param msg is the message to throw if the argument is not base58
   */
  static assertBase58(str, msg) {
    GenUtils$d.assertTrue(isBase58(str), msg ? msg : "Argument asserted as base58 but is not base58");
  }

  /**
   * Determines if the given string is base58.
   */
  static isBase58(str) {
    if (typeof str !== 'string') return false;
    GenUtils$d.assertTrue(str.length > 0, "Cannot determine if empty string is base58");
    return /^[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]+$/.test(str);
  }

  /**
   * Asserts that the given argument is base64.
   * 
   * @param arg is the argument to assert as base64
   * @param msg is the message to throw if the argument is not base64
   */
  static assertBase64(str, msg) {
    GenUtils$d.assertTrue(isBase64(str), msg ? msg : "Argument asserted as base64 but is not base64");
  }

  /**
   * Determines if the given string is base64.
   */
  static isBase64(str) {
    if (typeof str !== 'string') return false;
    GenUtils$d.assertTrue(str.length > 0, "Cannot determine if empty string is base64");
    try {
      return btoa(atob(str)) == str;
    } catch (err) {
      return false;
    }
  }

  /**
   * Throws an exception with the given message.
   * 
   * @param msg defines the message to throw the exception with (optional)
   */
  static fail(msg) {
    throw new Error(msg ? msg : "Failure (no message)");
  }

  /**
   * Asserts that the given boolean is true.  Throws an exception if not a boolean or false.
   * 
   * @param bool is the boolean to assert true
   * @param msg is the message to throw if bool is false (optional)
   */
  static assertTrue(bool, msg) {
    if (typeof bool !== 'boolean') throw new Error("Argument is not a boolean");
    if (!bool) throw new Error(msg ? msg : "Boolean asserted as true but was false");
  }

  /**
   * Asserts that the given boolean is false.  Throws an exception if not a boolean or true.
   * 
   * @param bool is the boolean to assert false
   * @param msg is the message to throw if bool is true (optional)
   */
  static assertFalse(bool, msg) {
    if (typeof bool !== 'boolean') throw new Error("Argument is not a boolean");
    if (bool) throw new Error(msg ? msg : "Boolean asserted as false but was true");
  }

  /**
   * Asserts that the given argument is null.  Throws an exception if not null.
   * 
   * @param arg is the argument to assert null
   * @param msg is the message to throw if arg is not null (optional)
   */
  static assertNull(arg, msg) {
    if (arg !== null) throw new Error(msg ? msg : "Argument asserted as null but was not null: " + arg);
  }

  /**
   * Asserts that the given argument is not null.  Throws an exception if null.
   * 
   * @param arg is the argument to assert not null
   * @param msg is the message to throw if arg is null (optional)
   */
  static assertNotNull(arg, msg) {
    if (arg === null) throw new Error(msg ? msg : "Argument asserted as not null but was null");
  }

  /**
   * Asserts that the given argument is defined.  Throws an exception if undefined.
   * 
   * @param arg is the argument to assert defined
   * @param msg is the message to throw if arg is undefined (optional)
   */
  static assertDefined(arg, msg) {
    if (GenUtils$d.isUndefined(arg)) throw new Error(msg ? msg : "Argument asserted as defined but was undefined");
  }

  /**
   * Asserts that the given argument is undefined.  Throws an exception if defined.
   * 
   * @param arg is the argument to assert undefined
   * @param msg is the message to throw if arg is defined (optional)
   */
  static assertUndefined(arg, msg) {
    if (GenUtils$d.isDefined(arg)) throw new Error(msg ? msg : "Argument asserted as undefined but was defined: " + arg);
  }

  /**
   * Asserts that the given argument is initialized.  Throws an exception if not initialized.
   * 
   * @param arg is the argument to assert as initialized
   * @param msg is the message to throw if arg is not initialized (optional)
   */
  static assertInitialized(arg, msg) {
    if (GenUtils$d.isUninitialized(arg)) {
      throw new Error(msg ? msg : "Argument asserted as initialized but was " + arg);
    }
  }

  /**
   * Asserts that the given argument is uninitialized.  Throws an exception if initialized.
   * 
   * @param arg is the argument to assert as uninitialized
   * @param msg is the message to throw if arg is initialized (optional)
   */
  static assertUninitialized(arg, msg) {
    if (GenUtils$d.isInitialized(arg)) throw new Error(msg ? msg : "Argument asserted as uninitialized but was initialized");
  }

  /**
   * Asserts that the given arguments are equal.  Throws an exception if not equal.
   * 
   * @param arg1 is an argument to assert as equal
   * @param arg2 is an argument to assert as equal
   * @param msg is the message to throw if the arguments are not equal
   */
  static assertEquals(arg1, arg2, msg) {
    GenUtils$d.assertTrue(equals(arg1, arg2), msg ? msg : "Arguments asserted as equal but are not equal: " + arg1 + " vs " + arg2);
  }

  /**
   * Asserts that the given arguments are not equal.  Throws an exception if equal.
   * 
   * @param arg1 is an argument to assert as not equal
   * @param arg2 is an argument to assert as not equal
   * @param msg is the message to throw if the arguments are equal
   */
  static assertNotEquals(arg1, arg2, msg) {
    if (arg1 === arg2) throw new Error(msg ? msg : "Arguments asserted as not equal but are equal: " + arg1 + " vs " + arg2);
  }

  /**
   * Asserts that the given argument is an integer.
   * 
   * @param arg is the argument to assert as an integer
   * @param msg is the message to throw if the argument is not an integer
   */
  static assertInt(arg, msg) {
    if (!GenUtils$d.isInt(arg)) throw new Error(msg ? msg : "Argument asserted as an integer but is not an integer");
  }

  /**
   * Asserts that the given argument is a number.
   * 
   * @param arg is the argument to assert as a number
   * @param msg is the message to throw if the argument is not a number
   */
  static assertNumber(arg, msg) {
    if (!GenUtils$d.isNumber(arg)) throw new Error(msg ? msg : "Argument asserted as a number but is not a number");
  }

  /**
   * Asserts that the given argument is a boolean.
   * 
   * @param arg is the argument to assert as a boolean
   * @param msg is the message to throw if the argument is not a boolean
   */
  static assertBoolean(arg, msg) {
    if (!GenUtils$d.isBoolean(arg)) throw new Error(msg ? msg : "Argument asserted as a boolean but is not a boolean");
  }

  /**
   * Asserts that the given argument is a string.
   * 
   * @param arg is the argument to assert as a string
   * @param msg is the message to throw if the argument is not a string
   */
  static assertString(arg, msg) {
    if (!GenUtils$d.isString(arg)) throw new Error(msg ? msg : "Argument asserted as a string but is not a string: " + arg);
  }

  /**
   * Asserts that the given argument is an array.
   * 
   * @param arg is the argument to assert as an array
   * @param msg is the message to throw if the argument is not an array
   */
  static assertArray(arg, msg) {
    if (!GenUtils$d.isArray(arg)) throw new Error(msg ? msg : "Argument asserted as an array but is not an array");
  }

  /**
   * Asserts that the given argument is a static.
   * 
   * @param arg is the argument to assert as a static
   * @param msg is the message to throw if the argument is not a static
   */
  static assertFunction(arg, msg) {
    if (!GenUtils$d.isFunction(arg)) throw new Error(msg ? msg : "Argument asserted as a static but is not a static");
  }

  /**
   * Asserts that the given argument is an object with the given name.
   * 
   * @param arg is the argument to test
   * @param obj is an object to assert arg instanceof obj (optional)
   * @param msg is the message to throw if the argument is not the specified object
   */
  static assertObject(arg, obj, msg) {
    GenUtils$d.assertInitialized(arg, msg);
    if (obj) {
      if (!isObject(arg, obj)) throw new Error(msg ? msg : "Argument asserted as object '" + obj.name + "' but was not");
    } else {
      if (!isObject(arg)) throw new Error(msg ? msg : "Argument asserted as object but was not");
    }
  }

  /**
   * Sets the child's prototype to the parent's prototype.
   * 
   * @param child is the child class
   * @param parent is the parent class
   */
  static inheritsFrom(child, parent) {
    child.prototype = Object.create(parent.prototype);
    child.prototype.constructor = child;
  }

  /**
   * Invokes functions with arguments.
   * 
   * arguments[0] is assumed to be an array of functions to invoke
   * arguments[1...n] are args to invoke the functions with
   */
  static invoke() {
    let fns = arguments[0];
    let args = [];
    for (let i = 1; i < arguments.length; i++) args.push(arguments[i]);
    for (let i = 0; i < fns.length; i++) {
      assertFunction(fns[i], "Functions[" + i + "] is not a static");
      fns[i].apply(null, args);
    }
  }

  /**
   * Returns the power set of the given array.
   * 
   * @param arr is the array to get the power set of
   * @returns [][] is the power set of the given array
   */
  static getPowerSet(arr) {
    let fn = function(n, src, got, all) {
      if (n == 0) {
        if (got.length > 0) {
          all[all.length] = got;
        }
        return;
      }
      for (let j = 0; j < src.length; j++) {
        fn(n - 1, src.slice(j + 1), got.concat([ src[j] ]), all);
      }
      return;
    };
    let all = [];
    all.push([]);
    for (let i = 0; i < arr.length; i++) {
      fn(i, arr, [], all);
    }
    all.push(arr);
    return all;
  }

  /**
   * Returns the power set of the given array whose elements are the given size.
   * 
   * @param arr is the array to get the power set of
   * @param size is the required size of the elements within the power set
   * returns [][] is the power set of the given array whose elements are the given size 
   */
  static getPowerSetOfLength(arr, size) {
    assertInitialized(arr);
    assertInitialized(size);
    GenUtils$d.assertTrue(size >= 1);
    let powerSet = getPowerSet(arr);
    let powerSetOfLength = [];
    for (let i = 0; i < powerSet.length; i++) {
      if (powerSet[i].length === size) {
        powerSetOfLength.push(powerSet[i]);
      }
    }
    return powerSetOfLength;
  }

  /**
   * Returns an array of indices of the given size.
   * 
   * @param size specifies the size to get indices for
   * @returns array of the given size with indices starting at 0
   */
  static getIndices(size) {
    let indices = [];
    for (let i = 0; i < size; i++) {
      indices.push(i);
    }
    return indices;
  }

  /**
   * Returns a new array containing unique elements of the given array.
   * 
   * @param arr is the array to return unique elements from
   * @returns a new array with the given array's unique elements
   */
  static toUniqueArray(arr) {
    return arr.filter(function(value, index, self) {
      return self.indexOf(value) === index;
    });
  }

  /**
   * Copies the given array.
   * 
   * @param arr is the array to copy
   * @returns a copy of the given array
   */
  static copyArray(arr) {
    GenUtils$d.assertArray(arr);
    let copy = [];
    for (let i = 0; i < arr.length; i++) copy.push(arr[i]);
    return copy;
  }
  
  /**
   * Removes every instance of the given value from the given array.
   * 
   * @param arr is the array to remove the value from
   * @param val is the value to remove from the array
   * @returns true if the value is found and removed, false otherwise
   */
  static remove(arr, val) {
    let found = false;
    for (let i = arr.length - 1; i >= 0; i--) {
      if (arr[i] === val) {
        arr.splice(i, 1);
        found = true;
        i--;
      }
    }
    return found;
  }

  /**
   * Returns a copy of the given array where each element is lowercase.
   * 
   * @param arr is the array to convert to lowercase
   * @returns a copy of the given array where each element is lowercase
   */
  static toLowerCaseArray(arr) {
    let arr2 = [];
    for (let i = 0; i < arr.length; i++) {
      arr2.push(arr[i].toLowerCase());
    }
    return arr2;
  }

  /**
   * Listifies the given argument.
   * 
   * @param arrOrElem is an array or an element in the array
   * @returns an array which is the given arg if it's an array or an array with the given arg as an element
   */
  static listify(arrOrElem) {
    return GenUtils$d.isArray(arrOrElem) ? arrOrElem : [arrOrElem];
  }

  /**
   * Indicates if the given array contains the given object.
   * 
   * @param {object[]} arr - array that may or may not contain the object
   * @param {object} obj - object to check for inclusion in the array
   * @param {boolean} compareByReference - compare strictly by reference, forgoing deep equality check
   * @returns true if the array contains the object, false otherwise
   */
  static arrayContains(arr, obj, compareByReference) {
    GenUtils$d.assertTrue(GenUtils$d.isArray(arr));
    for (let i = 0; i < arr.length; i++) {
      if (arr[i] === obj) return true;
      if (!compareByReference && GenUtils$d.equals(arr[i], obj)) return true;
    }
    return false;
  }

  /**
   * Indicates if the given string contains the given substring.
   * 
   * @param str is the string to search for a substring
   * @param substring is the substring to searchin within the string
   * @returns true if the substring is within the string, false otherwise
   */
  static strContains(str, substring) {
    return str.indexOf(substring) > -1;
  }

  /**
   * Determines if two arrays are equal.
   * 
   * @param arr1 is an array to compare
   * @param arr2 is an array to compare
   * @returns true if the arrays are equal, false otherwise
   */
  static arraysEqual(arr1, arr2) {
    if (arr1 === arr2) return true;
    if (arr1 == null && arr2 == null) return true;
    if (arr1 == null || arr2 == null) return false;
    if (typeof arr1 === 'undefined' && typeof arr2 === 'undefined') return true;
    if (typeof arr1 === 'undefined' || typeof arr2 === 'undefined') return false;
    if (!GenUtils$d.isArray(arr1)) throw new Error("First argument is not an array");
    if (!GenUtils$d.isArray(arr2)) throw new Error("Second argument is not an array");
    if (arr1.length != arr2.length) return false;
    for (let i = 0; i < arr1.length; ++i) {
      if (!GenUtils$d.equals(arr1[i], arr2[i])) return false;
    }
    return true;
  }

  /**
   * Determines if two arguments are deep equal.
   * 
   * @param arg1 is an argument to compare
   * @param arg2 is an argument to compare
   * @returns true if the arguments are deep equals, false otherwise
   */
  static equals(arg1, arg2) {
    if (GenUtils$d.isArray(arg1) && GenUtils$d.isArray(arg2)) return GenUtils$d.arraysEqual(arg1, arg2);
    if (GenUtils$d.isObject(arg1) && GenUtils$d.isObject(arg2)) return GenUtils$d.objectsEqual(arg1, arg2);
    return arg1 === arg2;
  }
  
  /**
   * Determines if two objects are deep equal.
   * 
   * Undefined values are considered equal to non-existent keys.
   * 
   * @param map1 is a map to compare
   * @param map2 is a map to compare
   * @returns true if the maps have identical keys and values, false otherwise
   */
  static objectsEqual(map1, map2) {
    let keys1 = Object.keys(map1);
    let keys2 = Object.keys(map2);
    
    // compare each key1 to keys2
    for (let key1 of keys1) {
      let found = false;
      for (let key2 of keys2) {
        if (key1 === key2) {
          if (!GenUtils$d.equals(map1[key1], map2[key2])) return false;
          found = true;
          break;
        }
      }
      if (!found && map1[key1] !== undefined) return false; // allows undefined values to equal non-existent keys
    }
    
    // compare each key2 to keys1
    for (let key2 of keys2) {
      let found = false;
      for (let key1 of keys1) {
        if (key1 === key2) {
          found = true; // no need to re-compare which was done earlier
          break;
        }
      }
      if (!found && map2[key2] !== undefined) return false; // allows undefined values to equal non-existent keys
    }
    return true;
    
    // TODO: support strict option?
//    if (strict) {
//      let keys1 = Object.keys(map1);
//      if (keys1.length !== Object.keys(map2).length) return false;
//      for (let i = 0; i < keys1.length; i++) {
//        let key = Object.keys(map1)[i];
//        if (!GenUtils.equals(map1[key], map2[key])) return false;
//      }
//    }
  }
  
  /**
   * Deletes properties from the object that are undefined.
   * 
   * @param obj is the object to delete undefined keys from
   */
  static deleteUndefinedKeys(obj) {
    for (let key of Object.keys(obj)) {
      if (obj[key] === undefined) delete obj[key];
    }
  }

  /**
   * Returns combinations of the given array of the given size.
   * 
   * @param arr is the array to get combinations from
   * @param combinationSize specifies the size of each combination
   */
  static getCombinations(arr, combinationSize) {
    
    // validate input
    assertInitialized(arr);
    assertInitialized(combinationSize);
    GenUtils$d.assertTrue(combinationSize >= 1);
    
    // get combinations of array indices of the given size
    let indexCombinations = getPowerSetOfLength(getIndices(arr.length), combinationSize);
    
    // collect combinations from each combination of array indices
    let combinations = [];
    for (let indexCombinationsIdx = 0; indexCombinationsIdx < indexCombinations.length; indexCombinationsIdx++) {
      
      // get combination of array indices
      let indexCombination = indexCombinations[indexCombinationsIdx];
      
      // build combination from array
      let combination = [];
      for (let indexCombinationIdx = 0; indexCombinationIdx < indexCombination.length; indexCombinationIdx++) {
        combination.push(arr[indexCombination[indexCombinationIdx]]);
      }
      
      // add to combinations
      combinations.push(combination);
    }
    
    return combinations;
  }

  /**
   * Gets an 'a' element that is downloadable when clicked.
   * 
   * @param name is the name of the file to download
   * @param contents are the string contents of the file to download
   * @returns 'a' dom element with downloadable file
   */
  static getDownloadableA(name, contents) {
    let a = window.document.createElement('a');
    a.href = window.URL.createObjectURL(new Blob([contents], {type: 'text/plain'}));
    a.download = name;
    a.target="_blank";
    a.innerHTML = name;
    return a;
  }

  /**
   * Returns the given node's outer HTML.
   * 
   * @param node is the node to get outer HTML for
   * @returns the outer HTML of the given node
   */
  static getOuterHtml(node) {
    return $('<div>').append($(node).clone()).html();
  }

  /**
   * Copies properties in the given object to a new object.
   * 
   * @param obj is object to copy properties for
   * @returns a new object with properties copied from the given object
   */
  static copyProperties(obj) {
    return JSON.parse(JSON.stringify(obj))
  }

  /**
   * Deletes all properties in the given object.
   * 
   * @param obj is the object to delete properties from
   */
  static deleteProperties(obj) {
    let props = [];
    for (let prop in obj) props.push(prop); // TODO: if (obj.hasOwnProperty(prop)) { ...
    for (i = 0; i < props.length; i++) delete obj[props[i].toString()];
  }

  /**
   * Converts a CSV string to a 2-dimensional array of strings.
   * 
   * @param csv is the CSV string to convert
   * @returns a 2-dimensional array of strings
   */
  static csvToArr(csv) {
    return $.csv.toArrays(csv);
  }

  /**
   * Converts the given array to a CSV string.
   * 
   * @param arr is a 2-dimensional array of strings
   * @returns the CSV string
   */
  static arrToCsv(arr) {
    return $.csv.fromObjects(arr, {headers: false});
  }

  /**
   * Indicates if the given string contains whitespace.
   * 
   * @param str is the string to test
   * @returns true if the string contains whitespace, false otherwise
   */
  static hasWhitespace(str) {
    return /\s/g.test(str);
  }

  /**
   * Indicates if the given character is whitespace.
   * 
   * @param char is the character to test
   * @returns true if the given character is whitespace, false otherwise
   */
  static isWhitespace(char) {
    return /\s/.test(char);
  }

  /**
   * Indicates if the given character is a newline.
   * 
   * @param char is the character to test
   * @returns true if the given character is a newline, false otherwise
   */
  static isNewline(char) {
    return char === '\n' || char === '\r';
  }

  /**
   * Counts the number of non-whitespace characters in the given string.
   * 
   * @param str is the string to count the number of non-whitespace characters in
   * @returns int is the number of non-whitespace characters in the given string
   */
  static countNonWhitespaceCharacters(str) {
    let count = 0;
    for (let i = 0; i < str.length; i++) {
      if (!isWhitespace(str.charAt(i))) count++;
    }
    return count;
  }

  /**
   * Returns tokens separated by whitespace from the given string.
   * 
   * @param str is the string to get tokens from
   * @returns string[] are the tokens separated by whitespace within the string
   */
  static getWhitespaceTokens(str) {
    return str.match(/\S+/g);
  }

  /**
   * Returns lines separated by newlines from the given string.
   * 
   * @param str is the string to get lines from
   * @param string[] are the lines separated by newlines within the string
   */
  static getLines(str) {
    return str.match(/[^\r\n]+/g);
  }

  /**
   * Returns the document's first stylesheet which has no href.
   * 
   * @returns StyleSheet is the internal stylesheet
   */
  static getInternalStyleSheet() {
    for (let i = 0; i < document.styleSheets.length; i++) {
      let styleSheet = document.styleSheets[i];
      if (!styleSheet.href) return styleSheet;
    }
    return null;
  }

  /**
   * Returns the document's internal stylesheet as text.
   * 
   * @returns str is the document's internal stylesheet
   */
  static getInternalStyleSheetText() {
    let internalCss = "";
    let internalStyleSheet = getInternalStyleSheet();
    if (!internalStyleSheet) return null;
    for (let i = 0; i < internalStyleSheet.cssRules.length; i++) {
      internalCss += internalStyleSheet.cssRules[i].cssText + "\n";
    }
    return internalCss;
  }

  /**
   * Manually builds an HTML document string.
   * 
   * @param content specifies optional document content
   *        content.div is a pre-existing div to stringify and add to the body
   *        content.title is the title of the new tab
   *        content.dependencyPaths specifies paths to js, css, or img paths
   *        content.internalCss is css to embed in the html document
   *        content.metas are meta elements with keys/values to include
   * @returns str is the document string
   */
  static buildHtmlDocument(content) {
    let str = "<!DOCTYPE HTML>";
    str += "<html><head>";
    
    // add metas
    if (content.metas) {
      let metas = listify(content.metas);
      for (let i = 0; i < metas.length; i++) {
        let meta = metas[i];
        let elem = document.createElement("meta");
        for (let prop in meta) {
          if (meta.hasOwnProperty(prop)) {
            elem.setAttribute(prop.toString(), meta[prop.toString()]);
          }
        }
        str += elem.outerHTML;
      }
    }
    
    // add title and internal css
    str += content.title ? "<title>" + content.title + "</title>" : "";
    str += content.internalCss ? "<style>" + content.internalCss + "</style>" : "";
    
    // add dependency paths
    if (content.dependencyPaths) {
      let dependencyPaths = listify(content.dependencyPaths);
      for (let i = 0; i < dependencyPaths.length; i++) {
        let dependencyPath = dependencyPaths[i];
        if (dependencyPath.endsWith(".js")) str += "<script src='" + dependencyPath + "'></script>";
        else if (dependencyPath.endsWith(".css")) str += "<link rel='stylesheet' type='text/css' href='" + dependencyPath + "'/>";
        else if (dependencyPath.endsWith(".png") || dependencyPath.endsWith(".img"))  str += "<img src='" + dependencyPath + "'>";
        else throw new Error("Unrecognized dependency path extension: " + dependencyPath);      
      }
    }
    str += "</head><body>";
    if (content.div) str += $("<div>").append(content.div.clone()).html();  // add cloned div as string
    str += "</body></html>";
    return str;
  }

  /**
   * Opens the given div in a new window.
   * 
   * @param content specifies optional window content
   *        content.div is a pre-existing div to stringify and add to the body
   *        content.title is the title of the new tab
   *        content.dependencyPaths specifies paths to js, css, or img paths
   *        content.internalCss is css to embed in the html document
   *        content.metas are meta elements with keys/values to include
   * @param onLoad(err, window) is invoked with a reference to the window when available
   */
  static newWindow(content, onLoad) {
    let onLoadCalled = false;
    let w = window.open();
    if (!isInitialized(w) || !isInitialized(w.document)) {
      onLoadOnce(new Error("Could not get window reference"));
      return;
    }
    w.opener = null;
    w.document.write(buildHtmlDocument(content));
    w.addEventListener('load', function() {
      onLoadOnce(null, w);
    });
    w.document.close();
    
    // prevents onLoad() from being called multiple times
    function onLoadOnce(err, window) {
      if (onLoadCalled) return;
      onLoadCalled = true;
      if (onLoad) onLoad(err, window);
    }
  }

  /**
   * Converts the given image to a base64 encoded data url.
   * 
   * @param img is the image to convert
   * @param quality is a number between 0 and 1 specifying the image quality
   */
  static imgToDataUrl(img, quality) {
    let canvas = document.createElement('canvas');
    canvas.height = img.naturalHeight;
    canvas.width = img.naturalWidth;
    let context = canvas.getContext('2d');
    context.drawImage(img, 0, 0);
    return canvas.toDataURL(quality);
  }

  /**
   * Determines if the image at the given URL is accessible.
   * 
   * @param url is the url to an image
   * @param timeout is the maximum time to wait
   * @param onDone(bool) when the image is determined to be accessible or not
   */
  static isImageAccessible(url, timeout, onDone) {
    
    // track return so it only executes once
    let returned = false;
    
    // attempt to load favicon
    let img = new Image();
    img.onload = onResponse;
    img.onerror = onResponse;
    img.src = url + "?" + (+new Date()); // trigger image load with cache buster
    
    // nest failure timeouts to give response a chance when browser is under load
    setTimeout(function() {
      setImmediate(function() {
        setImmediate(function() {
          setImmediate(function() {
            if (!returned) {
              returned = true;
              onDone(false);
            }
          });
        });
      });
    }, timeout);
    
    function onResponse(e) {
      if (returned) return;
      returned = true;
      if (typeof e === 'undefined' || e.type === "error") onDone(false);
      else onDone(true);
    }
  }

  /**
   * Determines if the given file is a zip file.
   * 
   * @param file is a file
   * @returns true if the given file is a zip file, false otherwise
   */
  static isZipFile(file) {
    return file.name.endsWith(".zip") || file.type === 'application/zip';
  }

  /**
   * Determines if the given file is a json file.
   * 
   * @param file is a file
   * @returns true if the given file is a json file, false otherwise
   */
  static isJsonFile(file) {
    return file.name.endsWith(".json") || file.type === 'application/json';
  }

  /**
   * Determines if the given file is a csv file.
   * 
   * @param file is a file
   * @returns true if the given file is a csv file, false otherwise
   */
  static isCsvFile(file) {
    return file.name.endsWith(".csv") || file.type === 'text/csv';
  }

  /**
   * Determines if the given file is a txt file.
   * 
   * @param file is a file
   * @returns true if the given file is a txt file, false otherwise
   */
  static isTxtFile(file) {
    return file.name.endsWith(".txt") || file.type === 'text/plain';
  }

  /**
   * Fetches the given list of images.
   * 
   * Prerequisite: async.js.
   * 
   * @param paths are the paths to the images to fetch
   * @param onDone(err, images) is called when done
   */
  static getImages(paths, onDone) {
    
    // listify paths
    if (!GenUtils$d.isArray(paths)) {
      GenUtils$d.assertTrue(isString(paths));
      paths = [paths];
    }
    
    // collect functions to fetch images
    let funcs = [];
    for (let i = 0; i < paths.length; i++) {
      funcs.push(loadFunc(paths[i]));
    }
    
    // fetch in parallel
    async.parallel(funcs, onDone);
    
    // callback static to fetch a single image
    function loadFunc(path) {
      return function(onDone) {
        let img = new Image();
        img.onload = function() { onDone(null, img); };
        img.onerror = function() { onDone(new Error("Cannot load image: " + path)); };
        img.src = path;
      }
    }
  }
  
  /**
   * Returns a string indentation of the given length;
   * 
   * @param length is the length of the indentation
   * @returns {string} is an indentation string of the given length
   */
  static getIndent(length) {
    let str = "";
    for (let i = 0; i < length; i++) str += '  '; // two spaces
    return str;
  }
  
  static initPolyfills() {
    
    // Polyfill Object.assign()
    // Credit: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
    if (typeof Object.assign != 'static') {
      // Must be writable: true, enumerable: false, configurable: true
      Object.defineProperty(Object, "assign", {
        value: function assign(target, varArgs) { // .length of static is 2
          if (target == null) { // TypeError if undefined or null
            throw new TypeError('Cannot convert undefined or null to object');
          }

          let to = Object(target);

          for (let index = 1; index < arguments.length; index++) {
            let nextSource = arguments[index];

            if (nextSource != null) { // Skip over if undefined or null
              for (let nextKey in nextSource) {
                // Avoid bugs when hasOwnProperty is shadowed
                if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
                  to[nextKey] = nextSource[nextKey];
                }
              }
            }
          }
          return to;
        },
        writable: true,
        configurable: true
      });
    }
    
    /**
     * Polyfill str.replaceAt(idx, replacement).
     */
    String.prototype.replaceAt=function(idx, replacement) {
      return this.substr(0, idx) + replacement + this.substr(idx + replacement.length);
    };

    /**
     * Polyfill str.startsWith(searchString, position).
     * 
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith#Polyfill
     */
    String.prototype.startsWith = function(searchString, position) {
      return this.substr(position || 0, searchString.length) === searchString;
    };

    /**
     * Polyfill str.endsWith(searchString, position).
     * 
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith#Polyfill
     */
    String.prototype.endsWith = function(searchString, position) {
      if (!(position < this.length)) position = this.length;  // works better than >= because it compensates for NaN
      else position |= 0; // round position
      return this.substr(position - searchString.length, searchString.length) === searchString;
    };

    /**
     * Removes the given value from the array.
     * 
     * @returns true if the value was found and removed, false otherwise
     */
    Array.prototype.removeVal = function(val) {
      var found = false;
      for (var i = 0; i < this.length; i++) {
        if (this[i] == val) {    
          found = true;
          this.splice(i, 1);
          i--;
        }
      }
      return found;    };
  }

  /**
   * Generates a v4 UUID.
   * 
   * Source: https://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript
   */
  static getUUID() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      let r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });
  }
  
  /**
   * Indicates if the current environment is a browser.
   * 
   * @return {boolean} true if the environment is a browser, false otherwise
   */
  static isBrowser() {
    let isWorker = typeof importScripts === 'function';
    let isBrowserMain = new Function("try {return this===window;}catch(e){return false;}")();
    let isJsDom = isBrowserMain ? new Function("try {return window.navigator.userAgent.includes('jsdom');}catch(e){return false;}")() : false;
    return isWorker || (isBrowserMain && !isJsDom);
  }
  
  /**
   * Indicates if the current environment is a firefox-based browser.
   * 
   * @return {boolean} true if the environment is a firefox-based browser, false otherwise
   */
  static isFirefox() {
    return this.isBrowser() && navigator.userAgent.indexOf("Firefox") > 0;
  }

  /**
   * Gets the IE version number.
   * 
   * Credit: https://stackoverflow.com/questions/19999388/check-if-user-is-using-ie-with-jquery/21712356#21712356
   * 
   * @returns the IE version number or null if not IE
   */
  static getIEVersion() {
    let ua = window.navigator.userAgent;

    let msie = ua.indexOf('MSIE ');
    if (msie > 0) {
        // IE 10 or older => return version number
        return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);
    }

    let trident = ua.indexOf('Trident/');
    if (trident > 0) {
        // IE 11 => return version number
        let rv = ua.indexOf('rv:');
        return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);
    }

    let edge = ua.indexOf('Edge/');
    if (edge > 0) {
       // Edge (IE 12+) => return version number
       return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);
    }

    // other browser
    return null;
  }

  /**
   * Gets a parameter value.
   * 
   * Credit: https://stackoverflow.com/questions/901115/how-can-i-get-query-string-values-in-javascript
   * 
   * @param name is the name of the parameter to get the value of
   * @param url is a URL to get the parameter from, uses the window's current href if not given
   * @returns the parameter's value
   */
  static getParameterByName(name, url) {
    if (!url) url = window.location.href;
    name = name.replace(/[\[\]]/g, "\\$&");
    let regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"), results = regex.exec(url);
    if (!results) return null;
    if (!results[2]) return '';
    return decodeURIComponent(results[2].replace(/\+/g, " "));
  }
  
  /**
   * Gets a non-cryptographically secure random number within a given range.
   * 
   * @param min is the minimum range of the int to generate, inclusive
   * @param max is the maximum range of the int to generate, inclusive
   * 
   * Source: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random
   */
  static getRandomInt(min, max) {
    min = Math.ceil(min);
    max = Math.floor(max);
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }
  
  /**
   * Gets random ints.
   * 
   * @param min is the minimum range of the ints to generate, inclusive
   * @param max is the maximum range of the ints to generate, inclusive
   * @param count is the number of random ints to get
   */
  static getRandomInts(min, max, count) {
    GenUtils$d.assertTrue(typeof count === "number");
    let ints = [];
    for (let i = 0; i < count; i++) ints.push(GenUtils$d.getRandomInt(min, max));
    return ints;
  }
  
  /**
   * Gets a given number of unique random ints within a range.
   * 
   * @param min is the minimum range of the ints to generate, inclusive
   * @param max is the maximum range of the ints to generate, inclusive
   * @param count is the number of unique random ints to get
   */
  static getUniqueRandomInts(min, max, count) {
    let ints = [];
    GenUtils$d.assertTrue(count >= 0);
    GenUtils$d.assertTrue(max - min + 1 >= count);
    while (ints.length < count) {
      let randomInt = GenUtils$d.getRandomInt(min, max);
      if (!ints.includes(randomInt)) ints.push(randomInt);
    }
    return ints;
  }
  
  /**
   * Randomize array element order in-place using Durstenfeld shuffle algorithm.
   * 
   * Credit: https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array
   */
  static shuffle(array) {
    for (var i = array.length - 1; i > 0; i--) {
      var j = Math.floor(Math.random() * (i + 1));
      var temp = array[i];
      array[i] = array[j];
      array[j] = temp;
    }
  }
  
  /**
   * Sorts an array by natural ordering.
   * 
   * @param the array to sort
   */
  static sort(array) {
    array.sort((a, b) => a === b ? 0 : a > b ? 1 : -1);
  }
  
  /**
   * Sets the given value ensuring a previous value is not overwritten.
   * 
   * TODO: remove for portability because function passing not supported in other languages, use reconcile only
   * 
   * @param obj is the object to invoke the getter and setter on
   * @param getFn gets the current value
   * @param setFn sets the current value
   * @param val is the value to set iff it does not overwrite a previous value
   * @param config specifies reconciliation configuration
   *        config.resolveDefined uses defined value if true or undefined, undefined if false
   *        config.resolveTrue uses true over false if true, false over true if false, must be equal if undefined
   *        config.resolveMax uses max over min if true, min over max if false, must be equal if undefined
   * @param errMsg is the error message to throw if the values cannot be reconciled (optional)
   */
  static safeSet(obj, getFn, setFn, val, config, errMsg) {
    let curVal = getFn.call(obj);
    let reconciledVal = GenUtils$d.reconcile(curVal, val, config, errMsg);
    if (curVal !== reconciledVal) setFn.call(obj, reconciledVal);
  }
  
  /**
   * Reconciles two values.
   * 
   * TODO: remove custom error message
   * 
   * @param val1 is a value to reconcile
   * @param val2 is a value to reconcile
   * @param config specifies reconciliation configuration
   *        config.resolveDefined uses defined value if true or undefined, undefined if false
   *        config.resolveTrue uses true over false if true, false over true if false, must be equal if undefined
   *        config.resolveMax uses max over min if true, min over max if false, must be equal if undefined
   * @param errMsg is the error message to throw if the values cannot be reconciled (optional)
   * @returns the reconciled value if reconcilable, throws error otherwise
   */
  static reconcile(val1, val2, config, errMsg) {
    
    // check for equality
    if (val1 === val2) return val1;
    
    // check for BigInteger equality
    let comparison; // save comparison for later if applicable
    if (val1 instanceof BigInteger$m && val2 instanceof BigInteger$m) {
      comparison = val1.compare(val2);  
      if (comparison === 0) return val1;
    }
    
    // resolve one value defined
    if (val1 === undefined || val2 === undefined) {
      if (config && config.resolveDefined === false) return undefined;  // use undefined
      else return val1 === undefined ? val2 : val1;  // use defined value
    }
    
    // resolve different booleans
    if (config && config.resolveTrue !== undefined && typeof val1 === "boolean" && typeof val2 === "boolean") {
      assert$f.equal(typeof config.resolveTrue, "boolean");
      return config.resolveTrue;
    }
    
    // resolve different numbers
    if (config && config.resolveMax !== undefined) {
      assert$f.equal(typeof config.resolveMax, "boolean");
      
      // resolve js numbers
      if (typeof val1 === "number" && typeof val2 === "number") {
        return config.resolveMax ? Math.max(val1, val2) : Math.min(val1, val2);
      }
      
      // resolve BigIntegers
      if (val1 instanceof BigInteger$m && val2 instanceof BigInteger$m) {
        return config.resolveMax ? (comparison < 0 ? val2 : val1) : (comparison < 0 ? val1 : val2);
      }
    }
    
    // assert deep equality
    assert$f.deepEqual(val1, val2, errMsg ? errMsg : "Cannot reconcile values " + val1 + " and " + val2 + " with config: " + JSON.stringify(config));
    return val1;
  }
  
  /**
   * Returns a human-friendly key value line.
   * 
   * @param key is the key
   * @param value is the value
   * @param indent indents the line
   * @param newline specifies if the string should be terminated with a newline or not
   * @param ignoreUndefined specifies if undefined values should return an empty string
   * @returns {string} is the human-friendly key value line
   */
  static kvLine(key, value, indent = 0, newline = true, ignoreUndefined = true) {
    if (value === undefined && ignoreUndefined) return "";
    return GenUtils$d.getIndent(indent) + key + ": " + value + (newline ? '\n' : "");
  }
  
  /**
   * Replace big integers (16 or more consecutive digits) with strings in order
   * to preserve numeric precision.
   * 
   * @param {string} str is the string to be modified
   * @return {string} the modified string with big numbers converted to strings
   */
  static stringifyBIs(str) {
    return str.replace(/("[^"]*"\s*:\s*)(\d{16,})/g, '$1"$2"');
  }
  
  /**
   * Print the current stack trace. 
   * 
   * @param {string} msg - optional message to print with the trace
   */
  static printStackTrace(msg) {
    try { throw new Error(msg); }
    catch (err) { console.error(err.stack); }
  }
  
  /**
   * Wait for the duration.
   * 
   * @param {number} duration - the duration to wait for in ms
   */
  static async waitFor(duration) {
    return new Promise(function(resolve) { setTimeout(resolve, duration); });
  }
  
  /**
   * Kill the given nodejs child process.
   * 
   * @param {process} process - the nodejs child process to kill
   * @param {string} signal - the kill signal, e.g. SIGTERM, SIGKILL, SIGINT (default)
   */
  static async killProcess(process, signal) {
    return new Promise(function(resolve, reject) {
      process.on("exit", function() { resolve(); });
      process.on("error", function(err) { reject(err); });
      process.kill(signal ? signal : "SIGINT");
    });
  }
}

var GenUtils_1 = GenUtils$d;

/**
 * Base filter.
 * 
 * @private
 */

class Filter {
  
  /**
   * Indicates if the given value meets the criteria of this filter.
   * 
   * @param val is the value to test
   * @return true if the value meets the criteria of this filter, false otherwise
   */
  meetsCriteria(val) {
    throw new Error("Subclass must implement");
  }
  
  /**
   * Returns a new array comprised of elements from the given array that meet
   * the filter's criteria.
   * 
   * @param filter implements meetsCriteria(elem) to filter the given array
   * @param array is the array to apply the filter to
   * @return the new array of filtered elements
   */
  static apply(filter, array) {
    return array.filter(elem => !filter || filter.meetsCriteria(elem));
  }
}

var Filter_1 = Filter;

/**
 * Exception when interacting with a Monero wallet or daemon.
 */

class MoneroError$7 extends Error {
  
  /**
   * Constructs the error.
   * 
   * @param {string} message is a human-readable message of the error
   * @param {int} code is the error code (optional)
   */
  constructor(message, code) {
    super(message);
    this.code = code;
  }
  
  getCode() {
    return this.code;
  }
  
  toString() {
    if (this.message === undefined && this.getCode() === undefined) return super.message;
    let str = "";
    if (this.getCode() !== undefined) str += this.getCode() + ": ";
    str += this.message;
    return str;
  }
}

var MoneroError_1 = MoneroError$7;

function commonjsRequire(path) {
	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}

const GenUtils$c = GenUtils_1;

/**
 * Simple thread pool using the async library.
 */
class ThreadPool {
  
  /**
   * Construct the thread pool.
   * 
   * @param {int} maxConcurrency - maximum number of threads in the pool (default 1)
   */
  constructor(maxConcurrency) {
    if (maxConcurrency === undefined) maxConcurrency = 1;
    if (maxConcurrency < 1) throw new Error("Max concurrency must be greater than or equal to 1");
    
    // manager concurrency with async queue
    const async = require$$1;
    this.taskQueue = async.queue(function(asyncFn, callback) {
      if (asyncFn.then) asyncFn.then(resp => { callback(resp); }).catch(err => { callback(undefined, err); });
      else asyncFn().then(resp => { callback(resp); }).catch(err => { callback(undefined, err); });
    }, maxConcurrency);
    
    // use drain listeners to support await all
    let that = this;
    this.drainListeners = [];
    this.taskQueue.drain = function() {
      for (let listener of that.drainListeners) listener();
    };
  }
  
  /**
   * Submit an asynchronous function to run using the thread pool.
   * 
   * @param {function} asyncFn - asynchronous function to run with the thread pool
   * @return {Promise} resolves when the function completes execution
   */
  async submit(asyncFn) {
    let that = this;
    return new Promise(function(resolve, reject) {
      that.taskQueue.push(asyncFn, function(resp, err) {
        if (err !== undefined) reject(err);
        else resolve(resp);
      });
    });
  }
  
  /**
   * Await all functions to complete.
   * 
   * @return {Promise} resolves when all functions complete
   */
  async awaitAll() {
    if (this.taskQueue.length === 0) return;
    let that = this;
    return new Promise(function(resolve) {
      that.drainListeners.push(function() {
        GenUtils$c.remove(that.drainListeners, this);
        resolve();
      });
    });
  }
}

var ThreadPool_1 = ThreadPool;

var monero_wallet_keys = {exports: {}};

var hasRequiredMonero_wallet_keys;

function requireMonero_wallet_keys () {
	if (hasRequiredMonero_wallet_keys) return monero_wallet_keys.exports;
	hasRequiredMonero_wallet_keys = 1;
	(function (module, exports) {
		var monero_javascript = (() => {
		  var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;
		  if (typeof __filename !== 'undefined') _scriptDir = _scriptDir || __filename;
		  return (
		function(monero_javascript) {
		  monero_javascript = monero_javascript || {};

		var Module=typeof monero_javascript!="undefined"?monero_javascript:{};var readyPromiseResolve,readyPromiseReject;Module["ready"]=new Promise(function(resolve,reject){readyPromiseResolve=resolve;readyPromiseReject=reject;});var moduleOverrides=Object.assign({},Module);var thisProgram="./this.program";var quit_=(status,toThrow)=>{throw toThrow};var ENVIRONMENT_IS_WEB=typeof window=="object";var ENVIRONMENT_IS_WORKER=typeof importScripts=="function";var ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";var scriptDirectory="";function locateFile(path){if(Module["locateFile"]){return Module["locateFile"](path,scriptDirectory)}return scriptDirectory+path}var read_,readAsync,readBinary;function logExceptionOnExit(e){if(e instanceof ExitStatus)return;let toLog=e;err("exiting due to exception: "+toLog);}var fs;var nodePath;var requireNodeFS;if(ENVIRONMENT_IS_NODE){if(ENVIRONMENT_IS_WORKER){scriptDirectory=require$$0$1.dirname(scriptDirectory)+"/";}else {scriptDirectory=__dirname+"/";}requireNodeFS=(()=>{if(!nodePath){fs=require$$1$1;nodePath=require$$0$1;}});read_=function shell_read(filename,binary){requireNodeFS();filename=nodePath["normalize"](filename);return fs.readFileSync(filename,binary?undefined:"utf8")};readBinary=(filename=>{var ret=read_(filename,true);if(!ret.buffer){ret=new Uint8Array(ret);}return ret});readAsync=((filename,onload,onerror)=>{requireNodeFS();filename=nodePath["normalize"](filename);fs.readFile(filename,function(err,data){if(err)onerror(err);else onload(data.buffer);});});if(process["argv"].length>1){thisProgram=process["argv"][1].replace(/\\/g,"/");}process["argv"].slice(2);process["on"]("unhandledRejection",function(reason){throw reason});quit_=((status,toThrow)=>{if(keepRuntimeAlive()){process["exitCode"]=status;throw toThrow}logExceptionOnExit(toThrow);process["exit"](status);});Module["inspect"]=function(){return "[Emscripten Module object]"};}else if(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER){if(ENVIRONMENT_IS_WORKER){scriptDirectory=self.location.href;}else if(typeof document!="undefined"&&document.currentScript){scriptDirectory=document.currentScript.src;}if(_scriptDir){scriptDirectory=_scriptDir;}if(scriptDirectory.indexOf("blob:")!==0){scriptDirectory=scriptDirectory.substr(0,scriptDirectory.replace(/[?#].*/,"").lastIndexOf("/")+1);}else {scriptDirectory="";}{read_=(url=>{var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.send(null);return xhr.responseText});if(ENVIRONMENT_IS_WORKER){readBinary=(url=>{var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.responseType="arraybuffer";xhr.send(null);return new Uint8Array(xhr.response)});}readAsync=((url,onload,onerror)=>{var xhr=new XMLHttpRequest;xhr.open("GET",url,true);xhr.responseType="arraybuffer";xhr.onload=(()=>{if(xhr.status==200||xhr.status==0&&xhr.response){onload(xhr.response);return}onerror();});xhr.onerror=onerror;xhr.send(null);});}}else;var out=Module["print"]||console.log.bind(console);var err=Module["printErr"]||console.warn.bind(console);Object.assign(Module,moduleOverrides);moduleOverrides=null;if(Module["arguments"])Module["arguments"];if(Module["thisProgram"])thisProgram=Module["thisProgram"];if(Module["quit"])quit_=Module["quit"];function uleb128Encode(n){if(n<128){return [n]}return [n%128|128,n>>7]}function convertJsFunctionToWasm(func,sig){if(typeof WebAssembly.Function=="function"){var typeNames={"i":"i32","j":"i64","f":"f32","d":"f64"};var type={parameters:[],results:sig[0]=="v"?[]:[typeNames[sig[0]]]};for(var i=1;i<sig.length;++i){type.parameters.push(typeNames[sig[i]]);}return new WebAssembly.Function(type,func)}var typeSection=[1,96];var sigRet=sig.slice(0,1);var sigParam=sig.slice(1);var typeCodes={"i":127,"j":126,"f":125,"d":124};typeSection=typeSection.concat(uleb128Encode(sigParam.length));for(var i=0;i<sigParam.length;++i){typeSection.push(typeCodes[sigParam[i]]);}if(sigRet=="v"){typeSection.push(0);}else {typeSection=typeSection.concat([1,typeCodes[sigRet]]);}typeSection=[1].concat(uleb128Encode(typeSection.length),typeSection);var bytes=new Uint8Array([0,97,115,109,1,0,0,0].concat(typeSection,[2,7,1,1,101,1,102,0,0,7,5,1,1,102,0,0]));var module=new WebAssembly.Module(bytes);var instance=new WebAssembly.Instance(module,{"e":{"f":func}});var wrappedFunc=instance.exports["f"];return wrappedFunc}var freeTableIndexes=[];var functionsInTableMap;function getEmptyTableSlot(){if(freeTableIndexes.length){return freeTableIndexes.pop()}try{wasmTable.grow(1);}catch(err){if(!(err instanceof RangeError)){throw err}throw "Unable to grow wasm table. Set ALLOW_TABLE_GROWTH."}return wasmTable.length-1}function updateTableMap(offset,count){for(var i=offset;i<offset+count;i++){var item=getWasmTableEntry(i);if(item){functionsInTableMap.set(item,i);}}}function addFunction(func,sig){if(!functionsInTableMap){functionsInTableMap=new WeakMap;updateTableMap(0,wasmTable.length);}if(functionsInTableMap.has(func)){return functionsInTableMap.get(func)}var ret=getEmptyTableSlot();try{setWasmTableEntry(ret,func);}catch(err){if(!(err instanceof TypeError)){throw err}var wrapped=convertJsFunctionToWasm(func,sig);setWasmTableEntry(ret,wrapped);}functionsInTableMap.set(func,ret);return ret}var tempRet0=0;var setTempRet0=value=>{tempRet0=value;};var getTempRet0=()=>tempRet0;var wasmBinary;if(Module["wasmBinary"])wasmBinary=Module["wasmBinary"];var noExitRuntime=Module["noExitRuntime"]||true;if(typeof WebAssembly!="object"){abort("no native wasm support detected");}var wasmMemory;var ABORT=false;function assert(condition,text){if(!condition){abort(text);}}var UTF8Decoder=typeof TextDecoder!="undefined"?new TextDecoder("utf8"):undefined;function UTF8ArrayToString(heapOrArray,idx,maxBytesToRead){var endIdx=idx+maxBytesToRead;var endPtr=idx;while(heapOrArray[endPtr]&&!(endPtr>=endIdx))++endPtr;if(endPtr-idx>16&&heapOrArray.buffer&&UTF8Decoder){return UTF8Decoder.decode(heapOrArray.subarray(idx,endPtr))}else {var str="";while(idx<endPtr){var u0=heapOrArray[idx++];if(!(u0&128)){str+=String.fromCharCode(u0);continue}var u1=heapOrArray[idx++]&63;if((u0&224)==192){str+=String.fromCharCode((u0&31)<<6|u1);continue}var u2=heapOrArray[idx++]&63;if((u0&240)==224){u0=(u0&15)<<12|u1<<6|u2;}else {u0=(u0&7)<<18|u1<<12|u2<<6|heapOrArray[idx++]&63;}if(u0<65536){str+=String.fromCharCode(u0);}else {var ch=u0-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023);}}}return str}function UTF8ToString(ptr,maxBytesToRead){return ptr?UTF8ArrayToString(HEAPU8,ptr,maxBytesToRead):""}function stringToUTF8Array(str,heap,outIdx,maxBytesToWrite){if(!(maxBytesToWrite>0))return 0;var startIdx=outIdx;var endIdx=outIdx+maxBytesToWrite-1;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343){var u1=str.charCodeAt(++i);u=65536+((u&1023)<<10)|u1&1023;}if(u<=127){if(outIdx>=endIdx)break;heap[outIdx++]=u;}else if(u<=2047){if(outIdx+1>=endIdx)break;heap[outIdx++]=192|u>>6;heap[outIdx++]=128|u&63;}else if(u<=65535){if(outIdx+2>=endIdx)break;heap[outIdx++]=224|u>>12;heap[outIdx++]=128|u>>6&63;heap[outIdx++]=128|u&63;}else {if(outIdx+3>=endIdx)break;heap[outIdx++]=240|u>>18;heap[outIdx++]=128|u>>12&63;heap[outIdx++]=128|u>>6&63;heap[outIdx++]=128|u&63;}}heap[outIdx]=0;return outIdx-startIdx}function stringToUTF8(str,outPtr,maxBytesToWrite){return stringToUTF8Array(str,HEAPU8,outPtr,maxBytesToWrite)}function lengthBytesUTF8(str){var len=0;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343)u=65536+((u&1023)<<10)|str.charCodeAt(++i)&1023;if(u<=127)++len;else if(u<=2047)len+=2;else if(u<=65535)len+=3;else len+=4;}return len}var UTF16Decoder=typeof TextDecoder!="undefined"?new TextDecoder("utf-16le"):undefined;function UTF16ToString(ptr,maxBytesToRead){var endPtr=ptr;var idx=endPtr>>1;var maxIdx=idx+maxBytesToRead/2;while(!(idx>=maxIdx)&&HEAPU16[idx])++idx;endPtr=idx<<1;if(endPtr-ptr>32&&UTF16Decoder){return UTF16Decoder.decode(HEAPU8.subarray(ptr,endPtr))}else {var str="";for(var i=0;!(i>=maxBytesToRead/2);++i){var codeUnit=HEAP16[ptr+i*2>>1];if(codeUnit==0)break;str+=String.fromCharCode(codeUnit);}return str}}function stringToUTF16(str,outPtr,maxBytesToWrite){if(maxBytesToWrite===undefined){maxBytesToWrite=2147483647;}if(maxBytesToWrite<2)return 0;maxBytesToWrite-=2;var startPtr=outPtr;var numCharsToWrite=maxBytesToWrite<str.length*2?maxBytesToWrite/2:str.length;for(var i=0;i<numCharsToWrite;++i){var codeUnit=str.charCodeAt(i);HEAP16[outPtr>>1]=codeUnit;outPtr+=2;}HEAP16[outPtr>>1]=0;return outPtr-startPtr}function lengthBytesUTF16(str){return str.length*2}function UTF32ToString(ptr,maxBytesToRead){var i=0;var str="";while(!(i>=maxBytesToRead/4)){var utf32=HEAP32[ptr+i*4>>2];if(utf32==0)break;++i;if(utf32>=65536){var ch=utf32-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023);}else {str+=String.fromCharCode(utf32);}}return str}function stringToUTF32(str,outPtr,maxBytesToWrite){if(maxBytesToWrite===undefined){maxBytesToWrite=2147483647;}if(maxBytesToWrite<4)return 0;var startPtr=outPtr;var endPtr=startPtr+maxBytesToWrite-4;for(var i=0;i<str.length;++i){var codeUnit=str.charCodeAt(i);if(codeUnit>=55296&&codeUnit<=57343){var trailSurrogate=str.charCodeAt(++i);codeUnit=65536+((codeUnit&1023)<<10)|trailSurrogate&1023;}HEAP32[outPtr>>2]=codeUnit;outPtr+=4;if(outPtr+4>endPtr)break}HEAP32[outPtr>>2]=0;return outPtr-startPtr}function lengthBytesUTF32(str){var len=0;for(var i=0;i<str.length;++i){var codeUnit=str.charCodeAt(i);if(codeUnit>=55296&&codeUnit<=57343)++i;len+=4;}return len}function allocateUTF8(str){var size=lengthBytesUTF8(str)+1;var ret=_malloc(size);if(ret)stringToUTF8Array(str,HEAP8,ret,size);return ret}function writeArrayToMemory(array,buffer){HEAP8.set(array,buffer);}function writeAsciiToMemory(str,buffer,dontAddNull){for(var i=0;i<str.length;++i){HEAP8[buffer++>>0]=str.charCodeAt(i);}if(!dontAddNull)HEAP8[buffer>>0]=0;}var buffer,HEAP8,HEAPU8,HEAP16,HEAPU16,HEAP32,HEAPU32,HEAPF32,HEAPF64;function updateGlobalBufferAndViews(buf){buffer=buf;Module["HEAP8"]=HEAP8=new Int8Array(buf);Module["HEAP16"]=HEAP16=new Int16Array(buf);Module["HEAP32"]=HEAP32=new Int32Array(buf);Module["HEAPU8"]=HEAPU8=new Uint8Array(buf);Module["HEAPU16"]=HEAPU16=new Uint16Array(buf);Module["HEAPU32"]=HEAPU32=new Uint32Array(buf);Module["HEAPF32"]=HEAPF32=new Float32Array(buf);Module["HEAPF64"]=HEAPF64=new Float64Array(buf);}Module["INITIAL_MEMORY"]||16777216;var wasmTable;var __ATPRERUN__=[];var __ATINIT__=[];var __ATPOSTRUN__=[];function keepRuntimeAlive(){return noExitRuntime}function preRun(){if(Module["preRun"]){if(typeof Module["preRun"]=="function")Module["preRun"]=[Module["preRun"]];while(Module["preRun"].length){addOnPreRun(Module["preRun"].shift());}}callRuntimeCallbacks(__ATPRERUN__);}function initRuntime(){if(!Module["noFSInit"]&&!FS.init.initialized)FS.init();FS.ignorePermissions=false;callRuntimeCallbacks(__ATINIT__);}function postRun(){if(Module["postRun"]){if(typeof Module["postRun"]=="function")Module["postRun"]=[Module["postRun"]];while(Module["postRun"].length){addOnPostRun(Module["postRun"].shift());}}callRuntimeCallbacks(__ATPOSTRUN__);}function addOnPreRun(cb){__ATPRERUN__.unshift(cb);}function addOnInit(cb){__ATINIT__.unshift(cb);}function addOnPostRun(cb){__ATPOSTRUN__.unshift(cb);}var runDependencies=0;var dependenciesFulfilled=null;function getUniqueRunDependency(id){return id}function addRunDependency(id){runDependencies++;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies);}}function removeRunDependency(id){runDependencies--;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies);}if(runDependencies==0){if(dependenciesFulfilled){var callback=dependenciesFulfilled;dependenciesFulfilled=null;callback();}}}function abort(what){{if(Module["onAbort"]){Module["onAbort"](what);}}what="Aborted("+what+")";err(what);ABORT=true;what+=". Build with -sASSERTIONS for more info.";var e=new WebAssembly.RuntimeError(what);readyPromiseReject(e);throw e}var dataURIPrefix="data:application/octet-stream;base64,";function isDataURI(filename){return filename.startsWith(dataURIPrefix)}function isFileURI(filename){return filename.startsWith("file://")}var wasmBinaryFile;wasmBinaryFile="monero_wallet_keys.wasm";if(!isDataURI(wasmBinaryFile)){wasmBinaryFile=locateFile(wasmBinaryFile);}function getBinary(file){try{if(file==wasmBinaryFile&&wasmBinary){return new Uint8Array(wasmBinary)}if(readBinary){return readBinary(file)}else {throw "both async and sync fetching of the wasm failed"}}catch(err){abort(err);}}function getBinaryPromise(){if(!wasmBinary&&(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER)){if(typeof fetch=="function"&&!isFileURI(wasmBinaryFile)){return fetch(wasmBinaryFile,{credentials:"same-origin"}).then(function(response){if(!response["ok"]){throw "failed to load wasm binary file at '"+wasmBinaryFile+"'"}return response["arrayBuffer"]()}).catch(function(){return getBinary(wasmBinaryFile)})}else {if(readAsync){return new Promise(function(resolve,reject){readAsync(wasmBinaryFile,function(response){resolve(new Uint8Array(response));},reject);})}}}return Promise.resolve().then(function(){return getBinary(wasmBinaryFile)})}function createWasm(){var info={"a":asmLibraryArg};function receiveInstance(instance,module){var exports=instance.exports;Module["asm"]=exports;wasmMemory=Module["asm"]["Fa"];updateGlobalBufferAndViews(wasmMemory.buffer);wasmTable=Module["asm"]["Ia"];addOnInit(Module["asm"]["Ga"]);removeRunDependency();}addRunDependency();function receiveInstantiationResult(result){receiveInstance(result["instance"]);}function instantiateArrayBuffer(receiver){return getBinaryPromise().then(function(binary){return WebAssembly.instantiate(binary,info)}).then(function(instance){return instance}).then(receiver,function(reason){err("failed to asynchronously prepare wasm: "+reason);abort(reason);})}function instantiateAsync(){if(!wasmBinary&&typeof WebAssembly.instantiateStreaming=="function"&&!isDataURI(wasmBinaryFile)&&!isFileURI(wasmBinaryFile)&&typeof fetch=="function"){return fetch(wasmBinaryFile,{credentials:"same-origin"}).then(function(response){var result=WebAssembly.instantiateStreaming(response,info);return result.then(receiveInstantiationResult,function(reason){err("wasm streaming compile failed: "+reason);err("falling back to ArrayBuffer instantiation");return instantiateArrayBuffer(receiveInstantiationResult)})})}else {return instantiateArrayBuffer(receiveInstantiationResult)}}if(Module["instantiateWasm"]){try{var exports=Module["instantiateWasm"](info,receiveInstance);return exports}catch(e){err("Module.instantiateWasm callback failed with error: "+e);return false}}instantiateAsync().catch(readyPromiseReject);return {}}var tempDouble;var tempI64;function callRuntimeCallbacks(callbacks){while(callbacks.length>0){var callback=callbacks.shift();if(typeof callback=="function"){callback(Module);continue}var func=callback.func;if(typeof func=="number"){if(callback.arg===undefined){getWasmTableEntry(func)();}else {getWasmTableEntry(func)(callback.arg);}}else {func(callback.arg===undefined?null:callback.arg);}}}function getWasmTableEntry(funcPtr){return wasmTable.get(funcPtr)}function setWasmTableEntry(idx,func){wasmTable.set(idx,func);}function _CONF_modules_unload(){err("missing function: CONF_modules_unload");abort(-1);}function _ERR_reason_error_string(){err("missing function: ERR_reason_error_string");abort(-1);}function ___assert_fail(condition,filename,line,func){abort("Assertion failed: "+UTF8ToString(condition)+", at: "+[filename?UTF8ToString(filename):"unknown filename",line,func?UTF8ToString(func):"unknown function"]);}function ___cxa_allocate_exception(size){return _malloc(size+24)+24}var exceptionCaught=[];function exception_addRef(info){info.add_ref();}var uncaughtExceptionCount=0;function ___cxa_begin_catch(ptr){var info=new ExceptionInfo(ptr);if(!info.get_caught()){info.set_caught(true);uncaughtExceptionCount--;}info.set_rethrown(false);exceptionCaught.push(info);exception_addRef(info);return info.get_exception_ptr()}var exceptionLast=0;function ExceptionInfo(excPtr){this.excPtr=excPtr;this.ptr=excPtr-24;this.set_type=function(type){HEAPU32[this.ptr+4>>2]=type;};this.get_type=function(){return HEAPU32[this.ptr+4>>2]};this.set_destructor=function(destructor){HEAPU32[this.ptr+8>>2]=destructor;};this.get_destructor=function(){return HEAPU32[this.ptr+8>>2]};this.set_refcount=function(refcount){HEAP32[this.ptr>>2]=refcount;};this.set_caught=function(caught){caught=caught?1:0;HEAP8[this.ptr+12>>0]=caught;};this.get_caught=function(){return HEAP8[this.ptr+12>>0]!=0};this.set_rethrown=function(rethrown){rethrown=rethrown?1:0;HEAP8[this.ptr+13>>0]=rethrown;};this.get_rethrown=function(){return HEAP8[this.ptr+13>>0]!=0};this.init=function(type,destructor){this.set_adjusted_ptr(0);this.set_type(type);this.set_destructor(destructor);this.set_refcount(0);this.set_caught(false);this.set_rethrown(false);};this.add_ref=function(){var value=HEAP32[this.ptr>>2];HEAP32[this.ptr>>2]=value+1;};this.release_ref=function(){var prev=HEAP32[this.ptr>>2];HEAP32[this.ptr>>2]=prev-1;return prev===1};this.set_adjusted_ptr=function(adjustedPtr){HEAPU32[this.ptr+16>>2]=adjustedPtr;};this.get_adjusted_ptr=function(){return HEAPU32[this.ptr+16>>2]};this.get_exception_ptr=function(){var isPointer=___cxa_is_pointer_type(this.get_type());if(isPointer){return HEAPU32[this.excPtr>>2]}var adjusted=this.get_adjusted_ptr();if(adjusted!==0)return adjusted;return this.excPtr};}function ___cxa_free_exception(ptr){return _free(new ExceptionInfo(ptr).ptr)}function exception_decRef(info){if(info.release_ref()&&!info.get_rethrown()){var destructor=info.get_destructor();if(destructor){getWasmTableEntry(destructor)(info.excPtr);}___cxa_free_exception(info.excPtr);}}function ___cxa_end_catch(){_setThrew(0);var info=exceptionCaught.pop();exception_decRef(info);exceptionLast=0;}function ___resumeException(ptr){if(!exceptionLast){exceptionLast=ptr;}throw ptr}function ___cxa_find_matching_catch_2(){var thrown=exceptionLast;if(!thrown){setTempRet0(0);return 0}var info=new ExceptionInfo(thrown);info.set_adjusted_ptr(thrown);var thrownType=info.get_type();if(!thrownType){setTempRet0(0);return thrown}var typeArray=Array.prototype.slice.call(arguments);for(var i=0;i<typeArray.length;i++){var caughtType=typeArray[i];if(caughtType===0||caughtType===thrownType){break}var adjusted_ptr_addr=info.ptr+16;if(___cxa_can_catch(caughtType,thrownType,adjusted_ptr_addr)){setTempRet0(caughtType);return thrown}}setTempRet0(thrownType);return thrown}function ___cxa_find_matching_catch_3(){var thrown=exceptionLast;if(!thrown){setTempRet0(0);return 0}var info=new ExceptionInfo(thrown);info.set_adjusted_ptr(thrown);var thrownType=info.get_type();if(!thrownType){setTempRet0(0);return thrown}var typeArray=Array.prototype.slice.call(arguments);for(var i=0;i<typeArray.length;i++){var caughtType=typeArray[i];if(caughtType===0||caughtType===thrownType){break}var adjusted_ptr_addr=info.ptr+16;if(___cxa_can_catch(caughtType,thrownType,adjusted_ptr_addr)){setTempRet0(caughtType);return thrown}}setTempRet0(thrownType);return thrown}function ___cxa_rethrow(){var info=exceptionCaught.pop();if(!info){abort("no exception to throw");}var ptr=info.excPtr;if(!info.get_rethrown()){exceptionCaught.push(info);info.set_rethrown(true);info.set_caught(false);uncaughtExceptionCount++;}exceptionLast=ptr;throw ptr}function ___cxa_throw(ptr,type,destructor){var info=new ExceptionInfo(ptr);info.init(type,destructor);exceptionLast=ptr;uncaughtExceptionCount++;throw ptr}function ___cxa_uncaught_exceptions(){return uncaughtExceptionCount}function setErrNo(value){HEAP32[___errno_location()>>2]=value;return value}var PATH={isAbs:path=>path.charAt(0)==="/",splitPath:filename=>{var splitPathRe=/^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;return splitPathRe.exec(filename).slice(1)},normalizeArray:(parts,allowAboveRoot)=>{var up=0;for(var i=parts.length-1;i>=0;i--){var last=parts[i];if(last==="."){parts.splice(i,1);}else if(last===".."){parts.splice(i,1);up++;}else if(up){parts.splice(i,1);up--;}}if(allowAboveRoot){for(;up;up--){parts.unshift("..");}}return parts},normalize:path=>{var isAbsolute=PATH.isAbs(path),trailingSlash=path.substr(-1)==="/";path=PATH.normalizeArray(path.split("/").filter(p=>!!p),!isAbsolute).join("/");if(!path&&!isAbsolute){path=".";}if(path&&trailingSlash){path+="/";}return (isAbsolute?"/":"")+path},dirname:path=>{var result=PATH.splitPath(path),root=result[0],dir=result[1];if(!root&&!dir){return "."}if(dir){dir=dir.substr(0,dir.length-1);}return root+dir},basename:path=>{if(path==="/")return "/";path=PATH.normalize(path);path=path.replace(/\/$/,"");var lastSlash=path.lastIndexOf("/");if(lastSlash===-1)return path;return path.substr(lastSlash+1)},join:function(){var paths=Array.prototype.slice.call(arguments,0);return PATH.normalize(paths.join("/"))},join2:(l,r)=>{return PATH.normalize(l+"/"+r)}};function getRandomDevice(){if(typeof crypto=="object"&&typeof crypto["getRandomValues"]=="function"){var randomBuffer=new Uint8Array(1);return function(){crypto.getRandomValues(randomBuffer);return randomBuffer[0]}}else if(ENVIRONMENT_IS_NODE){try{var crypto_module=require("crypto");return function(){return crypto_module["randomBytes"](1)[0]}}catch(e){}}return function(){abort("randomDevice");}}var PATH_FS={resolve:function(){var resolvedPath="",resolvedAbsolute=false;for(var i=arguments.length-1;i>=-1&&!resolvedAbsolute;i--){var path=i>=0?arguments[i]:FS.cwd();if(typeof path!="string"){throw new TypeError("Arguments to path.resolve must be strings")}else if(!path){return ""}resolvedPath=path+"/"+resolvedPath;resolvedAbsolute=PATH.isAbs(path);}resolvedPath=PATH.normalizeArray(resolvedPath.split("/").filter(p=>!!p),!resolvedAbsolute).join("/");return (resolvedAbsolute?"/":"")+resolvedPath||"."},relative:(from,to)=>{from=PATH_FS.resolve(from).substr(1);to=PATH_FS.resolve(to).substr(1);function trim(arr){var start=0;for(;start<arr.length;start++){if(arr[start]!=="")break}var end=arr.length-1;for(;end>=0;end--){if(arr[end]!=="")break}if(start>end)return [];return arr.slice(start,end-start+1)}var fromParts=trim(from.split("/"));var toParts=trim(to.split("/"));var length=Math.min(fromParts.length,toParts.length);var samePartsLength=length;for(var i=0;i<length;i++){if(fromParts[i]!==toParts[i]){samePartsLength=i;break}}var outputParts=[];for(var i=samePartsLength;i<fromParts.length;i++){outputParts.push("..");}outputParts=outputParts.concat(toParts.slice(samePartsLength));return outputParts.join("/")}};var TTY={ttys:[],init:function(){},shutdown:function(){},register:function(dev,ops){TTY.ttys[dev]={input:[],output:[],ops:ops};FS.registerDevice(dev,TTY.stream_ops);},stream_ops:{open:function(stream){var tty=TTY.ttys[stream.node.rdev];if(!tty){throw new FS.ErrnoError(43)}stream.tty=tty;stream.seekable=false;},close:function(stream){stream.tty.ops.flush(stream.tty);},flush:function(stream){stream.tty.ops.flush(stream.tty);},read:function(stream,buffer,offset,length,pos){if(!stream.tty||!stream.tty.ops.get_char){throw new FS.ErrnoError(60)}var bytesRead=0;for(var i=0;i<length;i++){var result;try{result=stream.tty.ops.get_char(stream.tty);}catch(e){throw new FS.ErrnoError(29)}if(result===undefined&&bytesRead===0){throw new FS.ErrnoError(6)}if(result===null||result===undefined)break;bytesRead++;buffer[offset+i]=result;}if(bytesRead){stream.node.timestamp=Date.now();}return bytesRead},write:function(stream,buffer,offset,length,pos){if(!stream.tty||!stream.tty.ops.put_char){throw new FS.ErrnoError(60)}try{for(var i=0;i<length;i++){stream.tty.ops.put_char(stream.tty,buffer[offset+i]);}}catch(e){throw new FS.ErrnoError(29)}if(length){stream.node.timestamp=Date.now();}return i}},default_tty_ops:{get_char:function(tty){if(!tty.input.length){var result=null;if(ENVIRONMENT_IS_NODE){var BUFSIZE=256;var buf=Buffer.alloc(BUFSIZE);var bytesRead=0;try{bytesRead=fs.readSync(process.stdin.fd,buf,0,BUFSIZE,-1);}catch(e){if(e.toString().includes("EOF"))bytesRead=0;else throw e}if(bytesRead>0){result=buf.slice(0,bytesRead).toString("utf-8");}else {result=null;}}else if(typeof window!="undefined"&&typeof window.prompt=="function"){result=window.prompt("Input: ");if(result!==null){result+="\n";}}else if(typeof readline=="function"){result=readline();if(result!==null){result+="\n";}}if(!result){return null}tty.input=intArrayFromString(result,true);}return tty.input.shift()},put_char:function(tty,val){if(val===null||val===10){out(UTF8ArrayToString(tty.output,0));tty.output=[];}else {if(val!=0)tty.output.push(val);}},flush:function(tty){if(tty.output&&tty.output.length>0){out(UTF8ArrayToString(tty.output,0));tty.output=[];}}},default_tty1_ops:{put_char:function(tty,val){if(val===null||val===10){err(UTF8ArrayToString(tty.output,0));tty.output=[];}else {if(val!=0)tty.output.push(val);}},flush:function(tty){if(tty.output&&tty.output.length>0){err(UTF8ArrayToString(tty.output,0));tty.output=[];}}}};function mmapAlloc(size){abort();}var MEMFS={ops_table:null,mount:function(mount){return MEMFS.createNode(null,"/",16384|511,0)},createNode:function(parent,name,mode,dev){if(FS.isBlkdev(mode)||FS.isFIFO(mode)){throw new FS.ErrnoError(63)}if(!MEMFS.ops_table){MEMFS.ops_table={dir:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr,lookup:MEMFS.node_ops.lookup,mknod:MEMFS.node_ops.mknod,rename:MEMFS.node_ops.rename,unlink:MEMFS.node_ops.unlink,rmdir:MEMFS.node_ops.rmdir,readdir:MEMFS.node_ops.readdir,symlink:MEMFS.node_ops.symlink},stream:{llseek:MEMFS.stream_ops.llseek}},file:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr},stream:{llseek:MEMFS.stream_ops.llseek,read:MEMFS.stream_ops.read,write:MEMFS.stream_ops.write,allocate:MEMFS.stream_ops.allocate,mmap:MEMFS.stream_ops.mmap,msync:MEMFS.stream_ops.msync}},link:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr,readlink:MEMFS.node_ops.readlink},stream:{}},chrdev:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr},stream:FS.chrdev_stream_ops}};}var node=FS.createNode(parent,name,mode,dev);if(FS.isDir(node.mode)){node.node_ops=MEMFS.ops_table.dir.node;node.stream_ops=MEMFS.ops_table.dir.stream;node.contents={};}else if(FS.isFile(node.mode)){node.node_ops=MEMFS.ops_table.file.node;node.stream_ops=MEMFS.ops_table.file.stream;node.usedBytes=0;node.contents=null;}else if(FS.isLink(node.mode)){node.node_ops=MEMFS.ops_table.link.node;node.stream_ops=MEMFS.ops_table.link.stream;}else if(FS.isChrdev(node.mode)){node.node_ops=MEMFS.ops_table.chrdev.node;node.stream_ops=MEMFS.ops_table.chrdev.stream;}node.timestamp=Date.now();if(parent){parent.contents[name]=node;parent.timestamp=node.timestamp;}return node},getFileDataAsTypedArray:function(node){if(!node.contents)return new Uint8Array(0);if(node.contents.subarray)return node.contents.subarray(0,node.usedBytes);return new Uint8Array(node.contents)},expandFileStorage:function(node,newCapacity){var prevCapacity=node.contents?node.contents.length:0;if(prevCapacity>=newCapacity)return;var CAPACITY_DOUBLING_MAX=1024*1024;newCapacity=Math.max(newCapacity,prevCapacity*(prevCapacity<CAPACITY_DOUBLING_MAX?2:1.125)>>>0);if(prevCapacity!=0)newCapacity=Math.max(newCapacity,256);var oldContents=node.contents;node.contents=new Uint8Array(newCapacity);if(node.usedBytes>0)node.contents.set(oldContents.subarray(0,node.usedBytes),0);},resizeFileStorage:function(node,newSize){if(node.usedBytes==newSize)return;if(newSize==0){node.contents=null;node.usedBytes=0;}else {var oldContents=node.contents;node.contents=new Uint8Array(newSize);if(oldContents){node.contents.set(oldContents.subarray(0,Math.min(newSize,node.usedBytes)));}node.usedBytes=newSize;}},node_ops:{getattr:function(node){var attr={};attr.dev=FS.isChrdev(node.mode)?node.id:1;attr.ino=node.id;attr.mode=node.mode;attr.nlink=1;attr.uid=0;attr.gid=0;attr.rdev=node.rdev;if(FS.isDir(node.mode)){attr.size=4096;}else if(FS.isFile(node.mode)){attr.size=node.usedBytes;}else if(FS.isLink(node.mode)){attr.size=node.link.length;}else {attr.size=0;}attr.atime=new Date(node.timestamp);attr.mtime=new Date(node.timestamp);attr.ctime=new Date(node.timestamp);attr.blksize=4096;attr.blocks=Math.ceil(attr.size/attr.blksize);return attr},setattr:function(node,attr){if(attr.mode!==undefined){node.mode=attr.mode;}if(attr.timestamp!==undefined){node.timestamp=attr.timestamp;}if(attr.size!==undefined){MEMFS.resizeFileStorage(node,attr.size);}},lookup:function(parent,name){throw FS.genericErrors[44]},mknod:function(parent,name,mode,dev){return MEMFS.createNode(parent,name,mode,dev)},rename:function(old_node,new_dir,new_name){if(FS.isDir(old_node.mode)){var new_node;try{new_node=FS.lookupNode(new_dir,new_name);}catch(e){}if(new_node){for(var i in new_node.contents){throw new FS.ErrnoError(55)}}}delete old_node.parent.contents[old_node.name];old_node.parent.timestamp=Date.now();old_node.name=new_name;new_dir.contents[new_name]=old_node;new_dir.timestamp=old_node.parent.timestamp;old_node.parent=new_dir;},unlink:function(parent,name){delete parent.contents[name];parent.timestamp=Date.now();},rmdir:function(parent,name){var node=FS.lookupNode(parent,name);for(var i in node.contents){throw new FS.ErrnoError(55)}delete parent.contents[name];parent.timestamp=Date.now();},readdir:function(node){var entries=[".",".."];for(var key in node.contents){if(!node.contents.hasOwnProperty(key)){continue}entries.push(key);}return entries},symlink:function(parent,newname,oldpath){var node=MEMFS.createNode(parent,newname,511|40960,0);node.link=oldpath;return node},readlink:function(node){if(!FS.isLink(node.mode)){throw new FS.ErrnoError(28)}return node.link}},stream_ops:{read:function(stream,buffer,offset,length,position){var contents=stream.node.contents;if(position>=stream.node.usedBytes)return 0;var size=Math.min(stream.node.usedBytes-position,length);if(size>8&&contents.subarray){buffer.set(contents.subarray(position,position+size),offset);}else {for(var i=0;i<size;i++)buffer[offset+i]=contents[position+i];}return size},write:function(stream,buffer,offset,length,position,canOwn){if(buffer.buffer===HEAP8.buffer){canOwn=false;}if(!length)return 0;var node=stream.node;node.timestamp=Date.now();if(buffer.subarray&&(!node.contents||node.contents.subarray)){if(canOwn){node.contents=buffer.subarray(offset,offset+length);node.usedBytes=length;return length}else if(node.usedBytes===0&&position===0){node.contents=buffer.slice(offset,offset+length);node.usedBytes=length;return length}else if(position+length<=node.usedBytes){node.contents.set(buffer.subarray(offset,offset+length),position);return length}}MEMFS.expandFileStorage(node,position+length);if(node.contents.subarray&&buffer.subarray){node.contents.set(buffer.subarray(offset,offset+length),position);}else {for(var i=0;i<length;i++){node.contents[position+i]=buffer[offset+i];}}node.usedBytes=Math.max(node.usedBytes,position+length);return length},llseek:function(stream,offset,whence){var position=offset;if(whence===1){position+=stream.position;}else if(whence===2){if(FS.isFile(stream.node.mode)){position+=stream.node.usedBytes;}}if(position<0){throw new FS.ErrnoError(28)}return position},allocate:function(stream,offset,length){MEMFS.expandFileStorage(stream.node,offset+length);stream.node.usedBytes=Math.max(stream.node.usedBytes,offset+length);},mmap:function(stream,address,length,position,prot,flags){if(address!==0){throw new FS.ErrnoError(28)}if(!FS.isFile(stream.node.mode)){throw new FS.ErrnoError(43)}var ptr;var allocated;var contents=stream.node.contents;if(!(flags&2)&&contents.buffer===buffer){allocated=false;ptr=contents.byteOffset;}else {if(position>0||position+length<contents.length){if(contents.subarray){contents=contents.subarray(position,position+length);}else {contents=Array.prototype.slice.call(contents,position,position+length);}}allocated=true;ptr=mmapAlloc();if(!ptr){throw new FS.ErrnoError(48)}HEAP8.set(contents,ptr);}return {ptr:ptr,allocated:allocated}},msync:function(stream,buffer,offset,length,mmapFlags){if(!FS.isFile(stream.node.mode)){throw new FS.ErrnoError(43)}if(mmapFlags&2){return 0}MEMFS.stream_ops.write(stream,buffer,0,length,offset,false);return 0}}};function asyncLoad(url,onload,onerror,noRunDep){var dep=!noRunDep?getUniqueRunDependency("al "+url):"";readAsync(url,function(arrayBuffer){assert(arrayBuffer,'Loading data file "'+url+'" failed (no arrayBuffer).');onload(new Uint8Array(arrayBuffer));if(dep)removeRunDependency();},function(event){if(onerror){onerror();}else {throw 'Loading data file "'+url+'" failed.'}});if(dep)addRunDependency();}var FS={root:null,mounts:[],devices:{},streams:[],nextInode:1,nameTable:null,currentPath:"/",initialized:false,ignorePermissions:true,ErrnoError:null,genericErrors:{},filesystems:null,syncFSRequests:0,lookupPath:(path,opts={})=>{path=PATH_FS.resolve(FS.cwd(),path);if(!path)return {path:"",node:null};var defaults={follow_mount:true,recurse_count:0};opts=Object.assign(defaults,opts);if(opts.recurse_count>8){throw new FS.ErrnoError(32)}var parts=PATH.normalizeArray(path.split("/").filter(p=>!!p),false);var current=FS.root;var current_path="/";for(var i=0;i<parts.length;i++){var islast=i===parts.length-1;if(islast&&opts.parent){break}current=FS.lookupNode(current,parts[i]);current_path=PATH.join2(current_path,parts[i]);if(FS.isMountpoint(current)){if(!islast||islast&&opts.follow_mount){current=current.mounted.root;}}if(!islast||opts.follow){var count=0;while(FS.isLink(current.mode)){var link=FS.readlink(current_path);current_path=PATH_FS.resolve(PATH.dirname(current_path),link);var lookup=FS.lookupPath(current_path,{recurse_count:opts.recurse_count+1});current=lookup.node;if(count++>40){throw new FS.ErrnoError(32)}}}}return {path:current_path,node:current}},getPath:node=>{var path;while(true){if(FS.isRoot(node)){var mount=node.mount.mountpoint;if(!path)return mount;return mount[mount.length-1]!=="/"?mount+"/"+path:mount+path}path=path?node.name+"/"+path:node.name;node=node.parent;}},hashName:(parentid,name)=>{var hash=0;for(var i=0;i<name.length;i++){hash=(hash<<5)-hash+name.charCodeAt(i)|0;}return (parentid+hash>>>0)%FS.nameTable.length},hashAddNode:node=>{var hash=FS.hashName(node.parent.id,node.name);node.name_next=FS.nameTable[hash];FS.nameTable[hash]=node;},hashRemoveNode:node=>{var hash=FS.hashName(node.parent.id,node.name);if(FS.nameTable[hash]===node){FS.nameTable[hash]=node.name_next;}else {var current=FS.nameTable[hash];while(current){if(current.name_next===node){current.name_next=node.name_next;break}current=current.name_next;}}},lookupNode:(parent,name)=>{var errCode=FS.mayLookup(parent);if(errCode){throw new FS.ErrnoError(errCode,parent)}var hash=FS.hashName(parent.id,name);for(var node=FS.nameTable[hash];node;node=node.name_next){var nodeName=node.name;if(node.parent.id===parent.id&&nodeName===name){return node}}return FS.lookup(parent,name)},createNode:(parent,name,mode,rdev)=>{var node=new FS.FSNode(parent,name,mode,rdev);FS.hashAddNode(node);return node},destroyNode:node=>{FS.hashRemoveNode(node);},isRoot:node=>{return node===node.parent},isMountpoint:node=>{return !!node.mounted},isFile:mode=>{return (mode&61440)===32768},isDir:mode=>{return (mode&61440)===16384},isLink:mode=>{return (mode&61440)===40960},isChrdev:mode=>{return (mode&61440)===8192},isBlkdev:mode=>{return (mode&61440)===24576},isFIFO:mode=>{return (mode&61440)===4096},isSocket:mode=>{return (mode&49152)===49152},flagModes:{"r":0,"r+":2,"w":577,"w+":578,"a":1089,"a+":1090},modeStringToFlags:str=>{var flags=FS.flagModes[str];if(typeof flags=="undefined"){throw new Error("Unknown file open mode: "+str)}return flags},flagsToPermissionString:flag=>{var perms=["r","w","rw"][flag&3];if(flag&512){perms+="w";}return perms},nodePermissions:(node,perms)=>{if(FS.ignorePermissions){return 0}if(perms.includes("r")&&!(node.mode&292)){return 2}else if(perms.includes("w")&&!(node.mode&146)){return 2}else if(perms.includes("x")&&!(node.mode&73)){return 2}return 0},mayLookup:dir=>{var errCode=FS.nodePermissions(dir,"x");if(errCode)return errCode;if(!dir.node_ops.lookup)return 2;return 0},mayCreate:(dir,name)=>{try{var node=FS.lookupNode(dir,name);return 20}catch(e){}return FS.nodePermissions(dir,"wx")},mayDelete:(dir,name,isdir)=>{var node;try{node=FS.lookupNode(dir,name);}catch(e){return e.errno}var errCode=FS.nodePermissions(dir,"wx");if(errCode){return errCode}if(isdir){if(!FS.isDir(node.mode)){return 54}if(FS.isRoot(node)||FS.getPath(node)===FS.cwd()){return 10}}else {if(FS.isDir(node.mode)){return 31}}return 0},mayOpen:(node,flags)=>{if(!node){return 44}if(FS.isLink(node.mode)){return 32}else if(FS.isDir(node.mode)){if(FS.flagsToPermissionString(flags)!=="r"||flags&512){return 31}}return FS.nodePermissions(node,FS.flagsToPermissionString(flags))},MAX_OPEN_FDS:4096,nextfd:(fd_start=0,fd_end=FS.MAX_OPEN_FDS)=>{for(var fd=fd_start;fd<=fd_end;fd++){if(!FS.streams[fd]){return fd}}throw new FS.ErrnoError(33)},getStream:fd=>FS.streams[fd],createStream:(stream,fd_start,fd_end)=>{if(!FS.FSStream){FS.FSStream=function(){this.shared={};};FS.FSStream.prototype={object:{get:function(){return this.node},set:function(val){this.node=val;}},isRead:{get:function(){return (this.flags&2097155)!==1}},isWrite:{get:function(){return (this.flags&2097155)!==0}},isAppend:{get:function(){return this.flags&1024}},flags:{get:function(){return this.shared.flags},set:function(val){this.shared.flags=val;}},position:{get function(){return this.shared.position},set:function(val){this.shared.position=val;}}};}stream=Object.assign(new FS.FSStream,stream);var fd=FS.nextfd(fd_start,fd_end);stream.fd=fd;FS.streams[fd]=stream;return stream},closeStream:fd=>{FS.streams[fd]=null;},chrdev_stream_ops:{open:stream=>{var device=FS.getDevice(stream.node.rdev);stream.stream_ops=device.stream_ops;if(stream.stream_ops.open){stream.stream_ops.open(stream);}},llseek:()=>{throw new FS.ErrnoError(70)}},major:dev=>dev>>8,minor:dev=>dev&255,makedev:(ma,mi)=>ma<<8|mi,registerDevice:(dev,ops)=>{FS.devices[dev]={stream_ops:ops};},getDevice:dev=>FS.devices[dev],getMounts:mount=>{var mounts=[];var check=[mount];while(check.length){var m=check.pop();mounts.push(m);check.push.apply(check,m.mounts);}return mounts},syncfs:(populate,callback)=>{if(typeof populate=="function"){callback=populate;populate=false;}FS.syncFSRequests++;if(FS.syncFSRequests>1){err("warning: "+FS.syncFSRequests+" FS.syncfs operations in flight at once, probably just doing extra work");}var mounts=FS.getMounts(FS.root.mount);var completed=0;function doCallback(errCode){FS.syncFSRequests--;return callback(errCode)}function done(errCode){if(errCode){if(!done.errored){done.errored=true;return doCallback(errCode)}return}if(++completed>=mounts.length){doCallback(null);}}mounts.forEach(mount=>{if(!mount.type.syncfs){return done(null)}mount.type.syncfs(mount,populate,done);});},mount:(type,opts,mountpoint)=>{var root=mountpoint==="/";var pseudo=!mountpoint;var node;if(root&&FS.root){throw new FS.ErrnoError(10)}else if(!root&&!pseudo){var lookup=FS.lookupPath(mountpoint,{follow_mount:false});mountpoint=lookup.path;node=lookup.node;if(FS.isMountpoint(node)){throw new FS.ErrnoError(10)}if(!FS.isDir(node.mode)){throw new FS.ErrnoError(54)}}var mount={type:type,opts:opts,mountpoint:mountpoint,mounts:[]};var mountRoot=type.mount(mount);mountRoot.mount=mount;mount.root=mountRoot;if(root){FS.root=mountRoot;}else if(node){node.mounted=mount;if(node.mount){node.mount.mounts.push(mount);}}return mountRoot},unmount:mountpoint=>{var lookup=FS.lookupPath(mountpoint,{follow_mount:false});if(!FS.isMountpoint(lookup.node)){throw new FS.ErrnoError(28)}var node=lookup.node;var mount=node.mounted;var mounts=FS.getMounts(mount);Object.keys(FS.nameTable).forEach(hash=>{var current=FS.nameTable[hash];while(current){var next=current.name_next;if(mounts.includes(current.mount)){FS.destroyNode(current);}current=next;}});node.mounted=null;var idx=node.mount.mounts.indexOf(mount);node.mount.mounts.splice(idx,1);},lookup:(parent,name)=>{return parent.node_ops.lookup(parent,name)},mknod:(path,mode,dev)=>{var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;var name=PATH.basename(path);if(!name||name==="."||name===".."){throw new FS.ErrnoError(28)}var errCode=FS.mayCreate(parent,name);if(errCode){throw new FS.ErrnoError(errCode)}if(!parent.node_ops.mknod){throw new FS.ErrnoError(63)}return parent.node_ops.mknod(parent,name,mode,dev)},create:(path,mode)=>{mode=mode!==undefined?mode:438;mode&=4095;mode|=32768;return FS.mknod(path,mode,0)},mkdir:(path,mode)=>{mode=mode!==undefined?mode:511;mode&=511|512;mode|=16384;return FS.mknod(path,mode,0)},mkdirTree:(path,mode)=>{var dirs=path.split("/");var d="";for(var i=0;i<dirs.length;++i){if(!dirs[i])continue;d+="/"+dirs[i];try{FS.mkdir(d,mode);}catch(e){if(e.errno!=20)throw e}}},mkdev:(path,mode,dev)=>{if(typeof dev=="undefined"){dev=mode;mode=438;}mode|=8192;return FS.mknod(path,mode,dev)},symlink:(oldpath,newpath)=>{if(!PATH_FS.resolve(oldpath)){throw new FS.ErrnoError(44)}var lookup=FS.lookupPath(newpath,{parent:true});var parent=lookup.node;if(!parent){throw new FS.ErrnoError(44)}var newname=PATH.basename(newpath);var errCode=FS.mayCreate(parent,newname);if(errCode){throw new FS.ErrnoError(errCode)}if(!parent.node_ops.symlink){throw new FS.ErrnoError(63)}return parent.node_ops.symlink(parent,newname,oldpath)},rename:(old_path,new_path)=>{var old_dirname=PATH.dirname(old_path);var new_dirname=PATH.dirname(new_path);var old_name=PATH.basename(old_path);var new_name=PATH.basename(new_path);var lookup,old_dir,new_dir;lookup=FS.lookupPath(old_path,{parent:true});old_dir=lookup.node;lookup=FS.lookupPath(new_path,{parent:true});new_dir=lookup.node;if(!old_dir||!new_dir)throw new FS.ErrnoError(44);if(old_dir.mount!==new_dir.mount){throw new FS.ErrnoError(75)}var old_node=FS.lookupNode(old_dir,old_name);var relative=PATH_FS.relative(old_path,new_dirname);if(relative.charAt(0)!=="."){throw new FS.ErrnoError(28)}relative=PATH_FS.relative(new_path,old_dirname);if(relative.charAt(0)!=="."){throw new FS.ErrnoError(55)}var new_node;try{new_node=FS.lookupNode(new_dir,new_name);}catch(e){}if(old_node===new_node){return}var isdir=FS.isDir(old_node.mode);var errCode=FS.mayDelete(old_dir,old_name,isdir);if(errCode){throw new FS.ErrnoError(errCode)}errCode=new_node?FS.mayDelete(new_dir,new_name,isdir):FS.mayCreate(new_dir,new_name);if(errCode){throw new FS.ErrnoError(errCode)}if(!old_dir.node_ops.rename){throw new FS.ErrnoError(63)}if(FS.isMountpoint(old_node)||new_node&&FS.isMountpoint(new_node)){throw new FS.ErrnoError(10)}if(new_dir!==old_dir){errCode=FS.nodePermissions(old_dir,"w");if(errCode){throw new FS.ErrnoError(errCode)}}FS.hashRemoveNode(old_node);try{old_dir.node_ops.rename(old_node,new_dir,new_name);}catch(e){throw e}finally{FS.hashAddNode(old_node);}},rmdir:path=>{var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;var name=PATH.basename(path);var node=FS.lookupNode(parent,name);var errCode=FS.mayDelete(parent,name,true);if(errCode){throw new FS.ErrnoError(errCode)}if(!parent.node_ops.rmdir){throw new FS.ErrnoError(63)}if(FS.isMountpoint(node)){throw new FS.ErrnoError(10)}parent.node_ops.rmdir(parent,name);FS.destroyNode(node);},readdir:path=>{var lookup=FS.lookupPath(path,{follow:true});var node=lookup.node;if(!node.node_ops.readdir){throw new FS.ErrnoError(54)}return node.node_ops.readdir(node)},unlink:path=>{var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;if(!parent){throw new FS.ErrnoError(44)}var name=PATH.basename(path);var node=FS.lookupNode(parent,name);var errCode=FS.mayDelete(parent,name,false);if(errCode){throw new FS.ErrnoError(errCode)}if(!parent.node_ops.unlink){throw new FS.ErrnoError(63)}if(FS.isMountpoint(node)){throw new FS.ErrnoError(10)}parent.node_ops.unlink(parent,name);FS.destroyNode(node);},readlink:path=>{var lookup=FS.lookupPath(path);var link=lookup.node;if(!link){throw new FS.ErrnoError(44)}if(!link.node_ops.readlink){throw new FS.ErrnoError(28)}return PATH_FS.resolve(FS.getPath(link.parent),link.node_ops.readlink(link))},stat:(path,dontFollow)=>{var lookup=FS.lookupPath(path,{follow:!dontFollow});var node=lookup.node;if(!node){throw new FS.ErrnoError(44)}if(!node.node_ops.getattr){throw new FS.ErrnoError(63)}return node.node_ops.getattr(node)},lstat:path=>{return FS.stat(path,true)},chmod:(path,mode,dontFollow)=>{var node;if(typeof path=="string"){var lookup=FS.lookupPath(path,{follow:!dontFollow});node=lookup.node;}else {node=path;}if(!node.node_ops.setattr){throw new FS.ErrnoError(63)}node.node_ops.setattr(node,{mode:mode&4095|node.mode&~4095,timestamp:Date.now()});},lchmod:(path,mode)=>{FS.chmod(path,mode,true);},fchmod:(fd,mode)=>{var stream=FS.getStream(fd);if(!stream){throw new FS.ErrnoError(8)}FS.chmod(stream.node,mode);},chown:(path,uid,gid,dontFollow)=>{var node;if(typeof path=="string"){var lookup=FS.lookupPath(path,{follow:!dontFollow});node=lookup.node;}else {node=path;}if(!node.node_ops.setattr){throw new FS.ErrnoError(63)}node.node_ops.setattr(node,{timestamp:Date.now()});},lchown:(path,uid,gid)=>{FS.chown(path,uid,gid,true);},fchown:(fd,uid,gid)=>{var stream=FS.getStream(fd);if(!stream){throw new FS.ErrnoError(8)}FS.chown(stream.node,uid,gid);},truncate:(path,len)=>{if(len<0){throw new FS.ErrnoError(28)}var node;if(typeof path=="string"){var lookup=FS.lookupPath(path,{follow:true});node=lookup.node;}else {node=path;}if(!node.node_ops.setattr){throw new FS.ErrnoError(63)}if(FS.isDir(node.mode)){throw new FS.ErrnoError(31)}if(!FS.isFile(node.mode)){throw new FS.ErrnoError(28)}var errCode=FS.nodePermissions(node,"w");if(errCode){throw new FS.ErrnoError(errCode)}node.node_ops.setattr(node,{size:len,timestamp:Date.now()});},ftruncate:(fd,len)=>{var stream=FS.getStream(fd);if(!stream){throw new FS.ErrnoError(8)}if((stream.flags&2097155)===0){throw new FS.ErrnoError(28)}FS.truncate(stream.node,len);},utime:(path,atime,mtime)=>{var lookup=FS.lookupPath(path,{follow:true});var node=lookup.node;node.node_ops.setattr(node,{timestamp:Math.max(atime,mtime)});},open:(path,flags,mode)=>{if(path===""){throw new FS.ErrnoError(44)}flags=typeof flags=="string"?FS.modeStringToFlags(flags):flags;mode=typeof mode=="undefined"?438:mode;if(flags&64){mode=mode&4095|32768;}else {mode=0;}var node;if(typeof path=="object"){node=path;}else {path=PATH.normalize(path);try{var lookup=FS.lookupPath(path,{follow:!(flags&131072)});node=lookup.node;}catch(e){}}var created=false;if(flags&64){if(node){if(flags&128){throw new FS.ErrnoError(20)}}else {node=FS.mknod(path,mode,0);created=true;}}if(!node){throw new FS.ErrnoError(44)}if(FS.isChrdev(node.mode)){flags&=~512;}if(flags&65536&&!FS.isDir(node.mode)){throw new FS.ErrnoError(54)}if(!created){var errCode=FS.mayOpen(node,flags);if(errCode){throw new FS.ErrnoError(errCode)}}if(flags&512&&!created){FS.truncate(node,0);}flags&=~(128|512|131072);var stream=FS.createStream({node:node,path:FS.getPath(node),flags:flags,seekable:true,position:0,stream_ops:node.stream_ops,ungotten:[],error:false});if(stream.stream_ops.open){stream.stream_ops.open(stream);}if(Module["logReadFiles"]&&!(flags&1)){if(!FS.readFiles)FS.readFiles={};if(!(path in FS.readFiles)){FS.readFiles[path]=1;}}return stream},close:stream=>{if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if(stream.getdents)stream.getdents=null;try{if(stream.stream_ops.close){stream.stream_ops.close(stream);}}catch(e){throw e}finally{FS.closeStream(stream.fd);}stream.fd=null;},isClosed:stream=>{return stream.fd===null},llseek:(stream,offset,whence)=>{if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if(!stream.seekable||!stream.stream_ops.llseek){throw new FS.ErrnoError(70)}if(whence!=0&&whence!=1&&whence!=2){throw new FS.ErrnoError(28)}stream.position=stream.stream_ops.llseek(stream,offset,whence);stream.ungotten=[];return stream.position},read:(stream,buffer,offset,length,position)=>{if(length<0||position<0){throw new FS.ErrnoError(28)}if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if((stream.flags&2097155)===1){throw new FS.ErrnoError(8)}if(FS.isDir(stream.node.mode)){throw new FS.ErrnoError(31)}if(!stream.stream_ops.read){throw new FS.ErrnoError(28)}var seeking=typeof position!="undefined";if(!seeking){position=stream.position;}else if(!stream.seekable){throw new FS.ErrnoError(70)}var bytesRead=stream.stream_ops.read(stream,buffer,offset,length,position);if(!seeking)stream.position+=bytesRead;return bytesRead},write:(stream,buffer,offset,length,position,canOwn)=>{if(length<0||position<0){throw new FS.ErrnoError(28)}if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if((stream.flags&2097155)===0){throw new FS.ErrnoError(8)}if(FS.isDir(stream.node.mode)){throw new FS.ErrnoError(31)}if(!stream.stream_ops.write){throw new FS.ErrnoError(28)}if(stream.seekable&&stream.flags&1024){FS.llseek(stream,0,2);}var seeking=typeof position!="undefined";if(!seeking){position=stream.position;}else if(!stream.seekable){throw new FS.ErrnoError(70)}var bytesWritten=stream.stream_ops.write(stream,buffer,offset,length,position,canOwn);if(!seeking)stream.position+=bytesWritten;return bytesWritten},allocate:(stream,offset,length)=>{if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if(offset<0||length<=0){throw new FS.ErrnoError(28)}if((stream.flags&2097155)===0){throw new FS.ErrnoError(8)}if(!FS.isFile(stream.node.mode)&&!FS.isDir(stream.node.mode)){throw new FS.ErrnoError(43)}if(!stream.stream_ops.allocate){throw new FS.ErrnoError(138)}stream.stream_ops.allocate(stream,offset,length);},mmap:(stream,address,length,position,prot,flags)=>{if((prot&2)!==0&&(flags&2)===0&&(stream.flags&2097155)!==2){throw new FS.ErrnoError(2)}if((stream.flags&2097155)===1){throw new FS.ErrnoError(2)}if(!stream.stream_ops.mmap){throw new FS.ErrnoError(43)}return stream.stream_ops.mmap(stream,address,length,position,prot,flags)},msync:(stream,buffer,offset,length,mmapFlags)=>{if(!stream||!stream.stream_ops.msync){return 0}return stream.stream_ops.msync(stream,buffer,offset,length,mmapFlags)},munmap:stream=>0,ioctl:(stream,cmd,arg)=>{if(!stream.stream_ops.ioctl){throw new FS.ErrnoError(59)}return stream.stream_ops.ioctl(stream,cmd,arg)},readFile:(path,opts={})=>{opts.flags=opts.flags||0;opts.encoding=opts.encoding||"binary";if(opts.encoding!=="utf8"&&opts.encoding!=="binary"){throw new Error('Invalid encoding type "'+opts.encoding+'"')}var ret;var stream=FS.open(path,opts.flags);var stat=FS.stat(path);var length=stat.size;var buf=new Uint8Array(length);FS.read(stream,buf,0,length,0);if(opts.encoding==="utf8"){ret=UTF8ArrayToString(buf,0);}else if(opts.encoding==="binary"){ret=buf;}FS.close(stream);return ret},writeFile:(path,data,opts={})=>{opts.flags=opts.flags||577;var stream=FS.open(path,opts.flags,opts.mode);if(typeof data=="string"){var buf=new Uint8Array(lengthBytesUTF8(data)+1);var actualNumBytes=stringToUTF8Array(data,buf,0,buf.length);FS.write(stream,buf,0,actualNumBytes,undefined,opts.canOwn);}else if(ArrayBuffer.isView(data)){FS.write(stream,data,0,data.byteLength,undefined,opts.canOwn);}else {throw new Error("Unsupported data type")}FS.close(stream);},cwd:()=>FS.currentPath,chdir:path=>{var lookup=FS.lookupPath(path,{follow:true});if(lookup.node===null){throw new FS.ErrnoError(44)}if(!FS.isDir(lookup.node.mode)){throw new FS.ErrnoError(54)}var errCode=FS.nodePermissions(lookup.node,"x");if(errCode){throw new FS.ErrnoError(errCode)}FS.currentPath=lookup.path;},createDefaultDirectories:()=>{FS.mkdir("/tmp");FS.mkdir("/home");FS.mkdir("/home/web_user");},createDefaultDevices:()=>{FS.mkdir("/dev");FS.registerDevice(FS.makedev(1,3),{read:()=>0,write:(stream,buffer,offset,length,pos)=>length});FS.mkdev("/dev/null",FS.makedev(1,3));TTY.register(FS.makedev(5,0),TTY.default_tty_ops);TTY.register(FS.makedev(6,0),TTY.default_tty1_ops);FS.mkdev("/dev/tty",FS.makedev(5,0));FS.mkdev("/dev/tty1",FS.makedev(6,0));var random_device=getRandomDevice();FS.createDevice("/dev","random",random_device);FS.createDevice("/dev","urandom",random_device);FS.mkdir("/dev/shm");FS.mkdir("/dev/shm/tmp");},createSpecialDirectories:()=>{FS.mkdir("/proc");var proc_self=FS.mkdir("/proc/self");FS.mkdir("/proc/self/fd");FS.mount({mount:()=>{var node=FS.createNode(proc_self,"fd",16384|511,73);node.node_ops={lookup:(parent,name)=>{var fd=+name;var stream=FS.getStream(fd);if(!stream)throw new FS.ErrnoError(8);var ret={parent:null,mount:{mountpoint:"fake"},node_ops:{readlink:()=>stream.path}};ret.parent=ret;return ret}};return node}},{},"/proc/self/fd");},createStandardStreams:()=>{if(Module["stdin"]){FS.createDevice("/dev","stdin",Module["stdin"]);}else {FS.symlink("/dev/tty","/dev/stdin");}if(Module["stdout"]){FS.createDevice("/dev","stdout",null,Module["stdout"]);}else {FS.symlink("/dev/tty","/dev/stdout");}if(Module["stderr"]){FS.createDevice("/dev","stderr",null,Module["stderr"]);}else {FS.symlink("/dev/tty1","/dev/stderr");}FS.open("/dev/stdin",0);FS.open("/dev/stdout",1);FS.open("/dev/stderr",1);},ensureErrnoError:()=>{if(FS.ErrnoError)return;FS.ErrnoError=function ErrnoError(errno,node){this.node=node;this.setErrno=function(errno){this.errno=errno;};this.setErrno(errno);this.message="FS error";};FS.ErrnoError.prototype=new Error;FS.ErrnoError.prototype.constructor=FS.ErrnoError;[44].forEach(code=>{FS.genericErrors[code]=new FS.ErrnoError(code);FS.genericErrors[code].stack="<generic error, no stack>";});},staticInit:()=>{FS.ensureErrnoError();FS.nameTable=new Array(4096);FS.mount(MEMFS,{},"/");FS.createDefaultDirectories();FS.createDefaultDevices();FS.createSpecialDirectories();FS.filesystems={"MEMFS":MEMFS};},init:(input,output,error)=>{FS.init.initialized=true;FS.ensureErrnoError();Module["stdin"]=input||Module["stdin"];Module["stdout"]=output||Module["stdout"];Module["stderr"]=error||Module["stderr"];FS.createStandardStreams();},quit:()=>{FS.init.initialized=false;for(var i=0;i<FS.streams.length;i++){var stream=FS.streams[i];if(!stream){continue}FS.close(stream);}},getMode:(canRead,canWrite)=>{var mode=0;if(canRead)mode|=292|73;if(canWrite)mode|=146;return mode},findObject:(path,dontResolveLastLink)=>{var ret=FS.analyzePath(path,dontResolveLastLink);if(ret.exists){return ret.object}else {return null}},analyzePath:(path,dontResolveLastLink)=>{try{var lookup=FS.lookupPath(path,{follow:!dontResolveLastLink});path=lookup.path;}catch(e){}var ret={isRoot:false,exists:false,error:0,name:null,path:null,object:null,parentExists:false,parentPath:null,parentObject:null};try{var lookup=FS.lookupPath(path,{parent:true});ret.parentExists=true;ret.parentPath=lookup.path;ret.parentObject=lookup.node;ret.name=PATH.basename(path);lookup=FS.lookupPath(path,{follow:!dontResolveLastLink});ret.exists=true;ret.path=lookup.path;ret.object=lookup.node;ret.name=lookup.node.name;ret.isRoot=lookup.path==="/";}catch(e){ret.error=e.errno;}return ret},createPath:(parent,path,canRead,canWrite)=>{parent=typeof parent=="string"?parent:FS.getPath(parent);var parts=path.split("/").reverse();while(parts.length){var part=parts.pop();if(!part)continue;var current=PATH.join2(parent,part);try{FS.mkdir(current);}catch(e){}parent=current;}return current},createFile:(parent,name,properties,canRead,canWrite)=>{var path=PATH.join2(typeof parent=="string"?parent:FS.getPath(parent),name);var mode=FS.getMode(canRead,canWrite);return FS.create(path,mode)},createDataFile:(parent,name,data,canRead,canWrite,canOwn)=>{var path=name;if(parent){parent=typeof parent=="string"?parent:FS.getPath(parent);path=name?PATH.join2(parent,name):parent;}var mode=FS.getMode(canRead,canWrite);var node=FS.create(path,mode);if(data){if(typeof data=="string"){var arr=new Array(data.length);for(var i=0,len=data.length;i<len;++i)arr[i]=data.charCodeAt(i);data=arr;}FS.chmod(node,mode|146);var stream=FS.open(node,577);FS.write(stream,data,0,data.length,0,canOwn);FS.close(stream);FS.chmod(node,mode);}return node},createDevice:(parent,name,input,output)=>{var path=PATH.join2(typeof parent=="string"?parent:FS.getPath(parent),name);var mode=FS.getMode(!!input,!!output);if(!FS.createDevice.major)FS.createDevice.major=64;var dev=FS.makedev(FS.createDevice.major++,0);FS.registerDevice(dev,{open:stream=>{stream.seekable=false;},close:stream=>{if(output&&output.buffer&&output.buffer.length){output(10);}},read:(stream,buffer,offset,length,pos)=>{var bytesRead=0;for(var i=0;i<length;i++){var result;try{result=input();}catch(e){throw new FS.ErrnoError(29)}if(result===undefined&&bytesRead===0){throw new FS.ErrnoError(6)}if(result===null||result===undefined)break;bytesRead++;buffer[offset+i]=result;}if(bytesRead){stream.node.timestamp=Date.now();}return bytesRead},write:(stream,buffer,offset,length,pos)=>{for(var i=0;i<length;i++){try{output(buffer[offset+i]);}catch(e){throw new FS.ErrnoError(29)}}if(length){stream.node.timestamp=Date.now();}return i}});return FS.mkdev(path,mode,dev)},forceLoadFile:obj=>{if(obj.isDevice||obj.isFolder||obj.link||obj.contents)return true;if(typeof XMLHttpRequest!="undefined"){throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.")}else if(read_){try{obj.contents=intArrayFromString(read_(obj.url),true);obj.usedBytes=obj.contents.length;}catch(e){throw new FS.ErrnoError(29)}}else {throw new Error("Cannot load without read() or XMLHttpRequest.")}},createLazyFile:(parent,name,url,canRead,canWrite)=>{function LazyUint8Array(){this.lengthKnown=false;this.chunks=[];}LazyUint8Array.prototype.get=function LazyUint8Array_get(idx){if(idx>this.length-1||idx<0){return undefined}var chunkOffset=idx%this.chunkSize;var chunkNum=idx/this.chunkSize|0;return this.getter(chunkNum)[chunkOffset]};LazyUint8Array.prototype.setDataGetter=function LazyUint8Array_setDataGetter(getter){this.getter=getter;};LazyUint8Array.prototype.cacheLength=function LazyUint8Array_cacheLength(){var xhr=new XMLHttpRequest;xhr.open("HEAD",url,false);xhr.send(null);if(!(xhr.status>=200&&xhr.status<300||xhr.status===304))throw new Error("Couldn't load "+url+". Status: "+xhr.status);var datalength=Number(xhr.getResponseHeader("Content-length"));var header;var hasByteServing=(header=xhr.getResponseHeader("Accept-Ranges"))&&header==="bytes";var usesGzip=(header=xhr.getResponseHeader("Content-Encoding"))&&header==="gzip";var chunkSize=1024*1024;if(!hasByteServing)chunkSize=datalength;var doXHR=(from,to)=>{if(from>to)throw new Error("invalid range ("+from+", "+to+") or no bytes requested!");if(to>datalength-1)throw new Error("only "+datalength+" bytes available! programmer error!");var xhr=new XMLHttpRequest;xhr.open("GET",url,false);if(datalength!==chunkSize)xhr.setRequestHeader("Range","bytes="+from+"-"+to);xhr.responseType="arraybuffer";if(xhr.overrideMimeType){xhr.overrideMimeType("text/plain; charset=x-user-defined");}xhr.send(null);if(!(xhr.status>=200&&xhr.status<300||xhr.status===304))throw new Error("Couldn't load "+url+". Status: "+xhr.status);if(xhr.response!==undefined){return new Uint8Array(xhr.response||[])}else {return intArrayFromString(xhr.responseText||"",true)}};var lazyArray=this;lazyArray.setDataGetter(chunkNum=>{var start=chunkNum*chunkSize;var end=(chunkNum+1)*chunkSize-1;end=Math.min(end,datalength-1);if(typeof lazyArray.chunks[chunkNum]=="undefined"){lazyArray.chunks[chunkNum]=doXHR(start,end);}if(typeof lazyArray.chunks[chunkNum]=="undefined")throw new Error("doXHR failed!");return lazyArray.chunks[chunkNum]});if(usesGzip||!datalength){chunkSize=datalength=1;datalength=this.getter(0).length;chunkSize=datalength;out("LazyFiles on gzip forces download of the whole file when length is accessed");}this._length=datalength;this._chunkSize=chunkSize;this.lengthKnown=true;};if(typeof XMLHttpRequest!="undefined"){if(!ENVIRONMENT_IS_WORKER)throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";var lazyArray=new LazyUint8Array;Object.defineProperties(lazyArray,{length:{get:function(){if(!this.lengthKnown){this.cacheLength();}return this._length}},chunkSize:{get:function(){if(!this.lengthKnown){this.cacheLength();}return this._chunkSize}}});var properties={isDevice:false,contents:lazyArray};}else {var properties={isDevice:false,url:url};}var node=FS.createFile(parent,name,properties,canRead,canWrite);if(properties.contents){node.contents=properties.contents;}else if(properties.url){node.contents=null;node.url=properties.url;}Object.defineProperties(node,{usedBytes:{get:function(){return this.contents.length}}});var stream_ops={};var keys=Object.keys(node.stream_ops);keys.forEach(key=>{var fn=node.stream_ops[key];stream_ops[key]=function forceLoadLazyFile(){FS.forceLoadFile(node);return fn.apply(null,arguments)};});stream_ops.read=((stream,buffer,offset,length,position)=>{FS.forceLoadFile(node);var contents=stream.node.contents;if(position>=contents.length)return 0;var size=Math.min(contents.length-position,length);if(contents.slice){for(var i=0;i<size;i++){buffer[offset+i]=contents[position+i];}}else {for(var i=0;i<size;i++){buffer[offset+i]=contents.get(position+i);}}return size});node.stream_ops=stream_ops;return node},createPreloadedFile:(parent,name,url,canRead,canWrite,onload,onerror,dontCreateFile,canOwn,preFinish)=>{var fullname=name?PATH_FS.resolve(PATH.join2(parent,name)):parent;function processData(byteArray){function finish(byteArray){if(preFinish)preFinish();if(!dontCreateFile){FS.createDataFile(parent,name,byteArray,canRead,canWrite,canOwn);}if(onload)onload();removeRunDependency();}if(Browser.handledByPreloadPlugin(byteArray,fullname,finish,()=>{if(onerror)onerror();removeRunDependency();})){return}finish(byteArray);}addRunDependency();if(typeof url=="string"){asyncLoad(url,byteArray=>processData(byteArray),onerror);}else {processData(url);}},indexedDB:()=>{return window.indexedDB||window.mozIndexedDB||window.webkitIndexedDB||window.msIndexedDB},DB_NAME:()=>{return "EM_FS_"+window.location.pathname},DB_VERSION:20,DB_STORE_NAME:"FILE_DATA",saveFilesToDB:(paths,onload,onerror)=>{onload=onload||(()=>{});onerror=onerror||(()=>{});var indexedDB=FS.indexedDB();try{var openRequest=indexedDB.open(FS.DB_NAME(),FS.DB_VERSION);}catch(e){return onerror(e)}openRequest.onupgradeneeded=(()=>{out("creating db");var db=openRequest.result;db.createObjectStore(FS.DB_STORE_NAME);});openRequest.onsuccess=(()=>{var db=openRequest.result;var transaction=db.transaction([FS.DB_STORE_NAME],"readwrite");var files=transaction.objectStore(FS.DB_STORE_NAME);var ok=0,fail=0,total=paths.length;function finish(){if(fail==0)onload();else onerror();}paths.forEach(path=>{var putRequest=files.put(FS.analyzePath(path).object.contents,path);putRequest.onsuccess=(()=>{ok++;if(ok+fail==total)finish();});putRequest.onerror=(()=>{fail++;if(ok+fail==total)finish();});});transaction.onerror=onerror;});openRequest.onerror=onerror;},loadFilesFromDB:(paths,onload,onerror)=>{onload=onload||(()=>{});onerror=onerror||(()=>{});var indexedDB=FS.indexedDB();try{var openRequest=indexedDB.open(FS.DB_NAME(),FS.DB_VERSION);}catch(e){return onerror(e)}openRequest.onupgradeneeded=onerror;openRequest.onsuccess=(()=>{var db=openRequest.result;try{var transaction=db.transaction([FS.DB_STORE_NAME],"readonly");}catch(e){onerror(e);return}var files=transaction.objectStore(FS.DB_STORE_NAME);var ok=0,fail=0,total=paths.length;function finish(){if(fail==0)onload();else onerror();}paths.forEach(path=>{var getRequest=files.get(path);getRequest.onsuccess=(()=>{if(FS.analyzePath(path).exists){FS.unlink(path);}FS.createDataFile(PATH.dirname(path),PATH.basename(path),getRequest.result,true,true,true);ok++;if(ok+fail==total)finish();});getRequest.onerror=(()=>{fail++;if(ok+fail==total)finish();});});transaction.onerror=onerror;});openRequest.onerror=onerror;}};var SYSCALLS={DEFAULT_POLLMASK:5,calculateAt:function(dirfd,path,allowEmpty){if(PATH.isAbs(path)){return path}var dir;if(dirfd===-100){dir=FS.cwd();}else {var dirstream=FS.getStream(dirfd);if(!dirstream)throw new FS.ErrnoError(8);dir=dirstream.path;}if(path.length==0){if(!allowEmpty){throw new FS.ErrnoError(44)}return dir}return PATH.join2(dir,path)},doStat:function(func,path,buf){try{var stat=func(path);}catch(e){if(e&&e.node&&PATH.normalize(path)!==PATH.normalize(FS.getPath(e.node))){return -54}throw e}HEAP32[buf>>2]=stat.dev;HEAP32[buf+4>>2]=0;HEAP32[buf+8>>2]=stat.ino;HEAP32[buf+12>>2]=stat.mode;HEAP32[buf+16>>2]=stat.nlink;HEAP32[buf+20>>2]=stat.uid;HEAP32[buf+24>>2]=stat.gid;HEAP32[buf+28>>2]=stat.rdev;HEAP32[buf+32>>2]=0;tempI64=[stat.size>>>0,(tempDouble=stat.size,+Math.abs(tempDouble)>=1?tempDouble>0?(Math.min(+Math.floor(tempDouble/4294967296),4294967295)|0)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[buf+40>>2]=tempI64[0],HEAP32[buf+44>>2]=tempI64[1];HEAP32[buf+48>>2]=4096;HEAP32[buf+52>>2]=stat.blocks;HEAP32[buf+56>>2]=stat.atime.getTime()/1e3|0;HEAP32[buf+60>>2]=0;HEAP32[buf+64>>2]=stat.mtime.getTime()/1e3|0;HEAP32[buf+68>>2]=0;HEAP32[buf+72>>2]=stat.ctime.getTime()/1e3|0;HEAP32[buf+76>>2]=0;tempI64=[stat.ino>>>0,(tempDouble=stat.ino,+Math.abs(tempDouble)>=1?tempDouble>0?(Math.min(+Math.floor(tempDouble/4294967296),4294967295)|0)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[buf+80>>2]=tempI64[0],HEAP32[buf+84>>2]=tempI64[1];return 0},doMsync:function(addr,stream,len,flags,offset){var buffer=HEAPU8.slice(addr,addr+len);FS.msync(stream,buffer,offset,len,flags);},varargs:undefined,get:function(){SYSCALLS.varargs+=4;var ret=HEAP32[SYSCALLS.varargs-4>>2];return ret},getStr:function(ptr){var ret=UTF8ToString(ptr);return ret},getStreamFromFD:function(fd){var stream=FS.getStream(fd);if(!stream)throw new FS.ErrnoError(8);return stream}};function ___syscall_fcntl64(fd,cmd,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(fd);switch(cmd){case 0:{var arg=SYSCALLS.get();if(arg<0){return -28}var newStream;newStream=FS.createStream(stream,arg);return newStream.fd}case 1:case 2:return 0;case 3:return stream.flags;case 4:{var arg=SYSCALLS.get();stream.flags|=arg;return 0}case 5:{var arg=SYSCALLS.get();var offset=0;HEAP16[arg+offset>>1]=2;return 0}case 6:case 7:return 0;case 16:case 8:return -28;case 9:setErrNo(28);return -1;default:{return -28}}}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return -e.errno}}function ___syscall_ioctl(fd,op,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(fd);switch(op){case 21509:case 21505:{if(!stream.tty)return -59;return 0}case 21510:case 21511:case 21512:case 21506:case 21507:case 21508:{if(!stream.tty)return -59;return 0}case 21519:{if(!stream.tty)return -59;var argp=SYSCALLS.get();HEAP32[argp>>2]=0;return 0}case 21520:{if(!stream.tty)return -59;return -28}case 21531:{var argp=SYSCALLS.get();return FS.ioctl(stream,op,argp)}case 21523:{if(!stream.tty)return -59;return 0}case 21524:{if(!stream.tty)return -59;return 0}default:abort("bad ioctl syscall "+op);}}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return -e.errno}}function ___syscall_mkdirat(dirfd,path,mode){try{path=SYSCALLS.getStr(path);path=SYSCALLS.calculateAt(dirfd,path);path=PATH.normalize(path);if(path[path.length-1]==="/")path=path.substr(0,path.length-1);FS.mkdir(path,mode,0);return 0}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return -e.errno}}function ___syscall_openat(dirfd,path,flags,varargs){SYSCALLS.varargs=varargs;try{path=SYSCALLS.getStr(path);path=SYSCALLS.calculateAt(dirfd,path);var mode=varargs?SYSCALLS.get():0;return FS.open(path,flags,mode).fd}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return -e.errno}}function ___syscall_stat64(path,buf){try{path=SYSCALLS.getStr(path);return SYSCALLS.doStat(FS.stat,path,buf)}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return -e.errno}}function __embind_register_bigint(primitiveType,name,size,minRange,maxRange){}function getShiftFromSize(size){switch(size){case 1:return 0;case 2:return 1;case 4:return 2;case 8:return 3;default:throw new TypeError("Unknown type size: "+size)}}function embind_init_charCodes(){var codes=new Array(256);for(var i=0;i<256;++i){codes[i]=String.fromCharCode(i);}embind_charCodes=codes;}var embind_charCodes=undefined;function readLatin1String(ptr){var ret="";var c=ptr;while(HEAPU8[c]){ret+=embind_charCodes[HEAPU8[c++]];}return ret}var awaitingDependencies={};var registeredTypes={};var typeDependencies={};var char_0=48;var char_9=57;function makeLegalFunctionName(name){if(undefined===name){return "_unknown"}name=name.replace(/[^a-zA-Z0-9_]/g,"$");var f=name.charCodeAt(0);if(f>=char_0&&f<=char_9){return "_"+name}return name}function createNamedFunction(name,body){name=makeLegalFunctionName(name);return function(){return body.apply(this,arguments)}}function extendError(baseErrorType,errorName){var errorClass=createNamedFunction(errorName,function(message){this.name=errorName;this.message=message;var stack=new Error(message).stack;if(stack!==undefined){this.stack=this.toString()+"\n"+stack.replace(/^Error(:[^\n]*)?\n/,"");}});errorClass.prototype=Object.create(baseErrorType.prototype);errorClass.prototype.constructor=errorClass;errorClass.prototype.toString=function(){if(this.message===undefined){return this.name}else {return this.name+": "+this.message}};return errorClass}var BindingError=undefined;function throwBindingError(message){throw new BindingError(message)}var InternalError=undefined;function throwInternalError(message){throw new InternalError(message)}function whenDependentTypesAreResolved(myTypes,dependentTypes,getTypeConverters){myTypes.forEach(function(type){typeDependencies[type]=dependentTypes;});function onComplete(typeConverters){var myTypeConverters=getTypeConverters(typeConverters);if(myTypeConverters.length!==myTypes.length){throwInternalError("Mismatched type converter count");}for(var i=0;i<myTypes.length;++i){registerType(myTypes[i],myTypeConverters[i]);}}var typeConverters=new Array(dependentTypes.length);var unregisteredTypes=[];var registered=0;dependentTypes.forEach((dt,i)=>{if(registeredTypes.hasOwnProperty(dt)){typeConverters[i]=registeredTypes[dt];}else {unregisteredTypes.push(dt);if(!awaitingDependencies.hasOwnProperty(dt)){awaitingDependencies[dt]=[];}awaitingDependencies[dt].push(()=>{typeConverters[i]=registeredTypes[dt];++registered;if(registered===unregisteredTypes.length){onComplete(typeConverters);}});}});if(0===unregisteredTypes.length){onComplete(typeConverters);}}function registerType(rawType,registeredInstance,options={}){if(!("argPackAdvance"in registeredInstance)){throw new TypeError("registerType registeredInstance requires argPackAdvance")}var name=registeredInstance.name;if(!rawType){throwBindingError('type "'+name+'" must have a positive integer typeid pointer');}if(registeredTypes.hasOwnProperty(rawType)){if(options.ignoreDuplicateRegistrations){return}else {throwBindingError("Cannot register type '"+name+"' twice");}}registeredTypes[rawType]=registeredInstance;delete typeDependencies[rawType];if(awaitingDependencies.hasOwnProperty(rawType)){var callbacks=awaitingDependencies[rawType];delete awaitingDependencies[rawType];callbacks.forEach(cb=>cb());}}function __embind_register_bool(rawType,name,size,trueValue,falseValue){var shift=getShiftFromSize(size);name=readLatin1String(name);registerType(rawType,{name:name,"fromWireType":function(wt){return !!wt},"toWireType":function(destructors,o){return o?trueValue:falseValue},"argPackAdvance":8,"readValueFromPointer":function(pointer){var heap;if(size===1){heap=HEAP8;}else if(size===2){heap=HEAP16;}else if(size===4){heap=HEAP32;}else {throw new TypeError("Unknown boolean type size: "+name)}return this["fromWireType"](heap[pointer>>shift])},destructorFunction:null});}var emval_free_list=[];var emval_handle_array=[{},{value:undefined},{value:null},{value:true},{value:false}];function __emval_decref(handle){if(handle>4&&0===--emval_handle_array[handle].refcount){emval_handle_array[handle]=undefined;emval_free_list.push(handle);}}function count_emval_handles(){var count=0;for(var i=5;i<emval_handle_array.length;++i){if(emval_handle_array[i]!==undefined){++count;}}return count}function get_first_emval(){for(var i=5;i<emval_handle_array.length;++i){if(emval_handle_array[i]!==undefined){return emval_handle_array[i]}}return null}function init_emval(){Module["count_emval_handles"]=count_emval_handles;Module["get_first_emval"]=get_first_emval;}var Emval={toValue:handle=>{if(!handle){throwBindingError("Cannot use deleted val. handle = "+handle);}return emval_handle_array[handle].value},toHandle:value=>{switch(value){case undefined:return 1;case null:return 2;case true:return 3;case false:return 4;default:{var handle=emval_free_list.length?emval_free_list.pop():emval_handle_array.length;emval_handle_array[handle]={refcount:1,value:value};return handle}}}};function simpleReadValueFromPointer(pointer){return this["fromWireType"](HEAPU32[pointer>>2])}function __embind_register_emval(rawType,name){name=readLatin1String(name);registerType(rawType,{name:name,"fromWireType":function(handle){var rv=Emval.toValue(handle);__emval_decref(handle);return rv},"toWireType":function(destructors,value){return Emval.toHandle(value)},"argPackAdvance":8,"readValueFromPointer":simpleReadValueFromPointer,destructorFunction:null});}function floatReadValueFromPointer(name,shift){switch(shift){case 2:return function(pointer){return this["fromWireType"](HEAPF32[pointer>>2])};case 3:return function(pointer){return this["fromWireType"](HEAPF64[pointer>>3])};default:throw new TypeError("Unknown float type: "+name)}}function __embind_register_float(rawType,name,size){var shift=getShiftFromSize(size);name=readLatin1String(name);registerType(rawType,{name:name,"fromWireType":function(value){return value},"toWireType":function(destructors,value){return value},"argPackAdvance":8,"readValueFromPointer":floatReadValueFromPointer(name,shift),destructorFunction:null});}function runDestructors(destructors){while(destructors.length){var ptr=destructors.pop();var del=destructors.pop();del(ptr);}}function craftInvokerFunction(humanName,argTypes,classType,cppInvokerFunc,cppTargetFunc){var argCount=argTypes.length;if(argCount<2){throwBindingError("argTypes array size mismatch! Must at least get return value and 'this' types!");}var isClassMethodFunc=argTypes[1]!==null&&classType!==null;var needsDestructorStack=false;for(var i=1;i<argTypes.length;++i){if(argTypes[i]!==null&&argTypes[i].destructorFunction===undefined){needsDestructorStack=true;break}}var returns=argTypes[0].name!=="void";var expectedArgCount=argCount-2;var argsWired=new Array(expectedArgCount);var invokerFuncArgs=[];var destructors=[];return function(){if(arguments.length!==expectedArgCount){throwBindingError("function "+humanName+" called with "+arguments.length+" arguments, expected "+expectedArgCount+" args!");}destructors.length=0;var thisWired;invokerFuncArgs.length=isClassMethodFunc?2:1;invokerFuncArgs[0]=cppTargetFunc;if(isClassMethodFunc){thisWired=argTypes[1]["toWireType"](destructors,this);invokerFuncArgs[1]=thisWired;}for(var i=0;i<expectedArgCount;++i){argsWired[i]=argTypes[i+2]["toWireType"](destructors,arguments[i]);invokerFuncArgs.push(argsWired[i]);}var rv=cppInvokerFunc.apply(null,invokerFuncArgs);function onDone(rv){if(needsDestructorStack){runDestructors(destructors);}else {for(var i=isClassMethodFunc?1:2;i<argTypes.length;i++){var param=i===1?thisWired:argsWired[i-2];if(argTypes[i].destructorFunction!==null){argTypes[i].destructorFunction(param);}}}if(returns){return argTypes[0]["fromWireType"](rv)}}return onDone(rv)}}function ensureOverloadTable(proto,methodName,humanName){if(undefined===proto[methodName].overloadTable){var prevFunc=proto[methodName];proto[methodName]=function(){if(!proto[methodName].overloadTable.hasOwnProperty(arguments.length)){throwBindingError("Function '"+humanName+"' called with an invalid number of arguments ("+arguments.length+") - expects one of ("+proto[methodName].overloadTable+")!");}return proto[methodName].overloadTable[arguments.length].apply(this,arguments)};proto[methodName].overloadTable=[];proto[methodName].overloadTable[prevFunc.argCount]=prevFunc;}}function exposePublicSymbol(name,value,numArguments){if(Module.hasOwnProperty(name)){if(undefined===numArguments||undefined!==Module[name].overloadTable&&undefined!==Module[name].overloadTable[numArguments]){throwBindingError("Cannot register public name '"+name+"' twice");}ensureOverloadTable(Module,name,name);if(Module.hasOwnProperty(numArguments)){throwBindingError("Cannot register multiple overloads of a function with the same number of arguments ("+numArguments+")!");}Module[name].overloadTable[numArguments]=value;}else {Module[name]=value;if(undefined!==numArguments){Module[name].numArguments=numArguments;}}}function heap32VectorToArray(count,firstElement){var array=[];for(var i=0;i<count;i++){array.push(HEAP32[(firstElement>>2)+i]);}return array}function replacePublicSymbol(name,value,numArguments){if(!Module.hasOwnProperty(name)){throwInternalError("Replacing nonexistant public symbol");}if(undefined!==Module[name].overloadTable&&undefined!==numArguments){Module[name].overloadTable[numArguments]=value;}else {Module[name]=value;Module[name].argCount=numArguments;}}function dynCallLegacy(sig,ptr,args){var f=Module["dynCall_"+sig];return args&&args.length?f.apply(null,[ptr].concat(args)):f.call(null,ptr)}function dynCall(sig,ptr,args){if(sig.includes("j")){return dynCallLegacy(sig,ptr,args)}return getWasmTableEntry(ptr).apply(null,args)}function getDynCaller(sig,ptr){var argCache=[];return function(){argCache.length=0;Object.assign(argCache,arguments);return dynCall(sig,ptr,argCache)}}function embind__requireFunction(signature,rawFunction){signature=readLatin1String(signature);function makeDynCaller(){if(signature.includes("j")){return getDynCaller(signature,rawFunction)}return getWasmTableEntry(rawFunction)}var fp=makeDynCaller();if(typeof fp!="function"){throwBindingError("unknown function pointer with signature "+signature+": "+rawFunction);}return fp}var UnboundTypeError=undefined;function getTypeName(type){var ptr=___getTypeName(type);var rv=readLatin1String(ptr);_free(ptr);return rv}function throwUnboundTypeError(message,types){var unboundTypes=[];var seen={};function visit(type){if(seen[type]){return}if(registeredTypes[type]){return}if(typeDependencies[type]){typeDependencies[type].forEach(visit);return}unboundTypes.push(type);seen[type]=true;}types.forEach(visit);throw new UnboundTypeError(message+": "+unboundTypes.map(getTypeName).join([", "]))}function __embind_register_function(name,argCount,rawArgTypesAddr,signature,rawInvoker,fn){var argTypes=heap32VectorToArray(argCount,rawArgTypesAddr);name=readLatin1String(name);rawInvoker=embind__requireFunction(signature,rawInvoker);exposePublicSymbol(name,function(){throwUnboundTypeError("Cannot call "+name+" due to unbound types",argTypes);},argCount-1);whenDependentTypesAreResolved([],argTypes,function(argTypes){var invokerArgsArray=[argTypes[0],null].concat(argTypes.slice(1));replacePublicSymbol(name,craftInvokerFunction(name,invokerArgsArray,null,rawInvoker,fn),argCount-1);return []});}function integerReadValueFromPointer(name,shift,signed){switch(shift){case 0:return signed?function readS8FromPointer(pointer){return HEAP8[pointer]}:function readU8FromPointer(pointer){return HEAPU8[pointer]};case 1:return signed?function readS16FromPointer(pointer){return HEAP16[pointer>>1]}:function readU16FromPointer(pointer){return HEAPU16[pointer>>1]};case 2:return signed?function readS32FromPointer(pointer){return HEAP32[pointer>>2]}:function readU32FromPointer(pointer){return HEAPU32[pointer>>2]};default:throw new TypeError("Unknown integer type: "+name)}}function __embind_register_integer(primitiveType,name,size,minRange,maxRange){name=readLatin1String(name);var shift=getShiftFromSize(size);var fromWireType=value=>value;if(minRange===0){var bitshift=32-8*size;fromWireType=(value=>value<<bitshift>>>bitshift);}var isUnsignedType=name.includes("unsigned");var checkAssertions=(value,toTypeName)=>{};var toWireType;if(isUnsignedType){toWireType=function(destructors,value){checkAssertions(value,this.name);return value>>>0};}else {toWireType=function(destructors,value){checkAssertions(value,this.name);return value};}registerType(primitiveType,{name:name,"fromWireType":fromWireType,"toWireType":toWireType,"argPackAdvance":8,"readValueFromPointer":integerReadValueFromPointer(name,shift,minRange!==0),destructorFunction:null});}function __embind_register_memory_view(rawType,dataTypeIndex,name){var typeMapping=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array];var TA=typeMapping[dataTypeIndex];function decodeMemoryView(handle){handle=handle>>2;var heap=HEAPU32;var size=heap[handle];var data=heap[handle+1];return new TA(buffer,data,size)}name=readLatin1String(name);registerType(rawType,{name:name,"fromWireType":decodeMemoryView,"argPackAdvance":8,"readValueFromPointer":decodeMemoryView},{ignoreDuplicateRegistrations:true});}function __embind_register_std_string(rawType,name){name=readLatin1String(name);var stdStringIsUTF8=name==="std::string";registerType(rawType,{name:name,"fromWireType":function(value){var length=HEAPU32[value>>2];var str;if(stdStringIsUTF8){var decodeStartPtr=value+4;for(var i=0;i<=length;++i){var currentBytePtr=value+4+i;if(i==length||HEAPU8[currentBytePtr]==0){var maxRead=currentBytePtr-decodeStartPtr;var stringSegment=UTF8ToString(decodeStartPtr,maxRead);if(str===undefined){str=stringSegment;}else {str+=String.fromCharCode(0);str+=stringSegment;}decodeStartPtr=currentBytePtr+1;}}}else {var a=new Array(length);for(var i=0;i<length;++i){a[i]=String.fromCharCode(HEAPU8[value+4+i]);}str=a.join("");}_free(value);return str},"toWireType":function(destructors,value){if(value instanceof ArrayBuffer){value=new Uint8Array(value);}var getLength;var valueIsOfTypeString=typeof value=="string";if(!(valueIsOfTypeString||value instanceof Uint8Array||value instanceof Uint8ClampedArray||value instanceof Int8Array)){throwBindingError("Cannot pass non-string to std::string");}if(stdStringIsUTF8&&valueIsOfTypeString){getLength=(()=>lengthBytesUTF8(value));}else {getLength=(()=>value.length);}var length=getLength();var ptr=_malloc(4+length+1);HEAPU32[ptr>>2]=length;if(stdStringIsUTF8&&valueIsOfTypeString){stringToUTF8(value,ptr+4,length+1);}else {if(valueIsOfTypeString){for(var i=0;i<length;++i){var charCode=value.charCodeAt(i);if(charCode>255){_free(ptr);throwBindingError("String has UTF-16 code units that do not fit in 8 bits");}HEAPU8[ptr+4+i]=charCode;}}else {for(var i=0;i<length;++i){HEAPU8[ptr+4+i]=value[i];}}}if(destructors!==null){destructors.push(_free,ptr);}return ptr},"argPackAdvance":8,"readValueFromPointer":simpleReadValueFromPointer,destructorFunction:function(ptr){_free(ptr);}});}function __embind_register_std_wstring(rawType,charSize,name){name=readLatin1String(name);var decodeString,encodeString,getHeap,lengthBytesUTF,shift;if(charSize===2){decodeString=UTF16ToString;encodeString=stringToUTF16;lengthBytesUTF=lengthBytesUTF16;getHeap=(()=>HEAPU16);shift=1;}else if(charSize===4){decodeString=UTF32ToString;encodeString=stringToUTF32;lengthBytesUTF=lengthBytesUTF32;getHeap=(()=>HEAPU32);shift=2;}registerType(rawType,{name:name,"fromWireType":function(value){var length=HEAPU32[value>>2];var HEAP=getHeap();var str;var decodeStartPtr=value+4;for(var i=0;i<=length;++i){var currentBytePtr=value+4+i*charSize;if(i==length||HEAP[currentBytePtr>>shift]==0){var maxReadBytes=currentBytePtr-decodeStartPtr;var stringSegment=decodeString(decodeStartPtr,maxReadBytes);if(str===undefined){str=stringSegment;}else {str+=String.fromCharCode(0);str+=stringSegment;}decodeStartPtr=currentBytePtr+charSize;}}_free(value);return str},"toWireType":function(destructors,value){if(!(typeof value=="string")){throwBindingError("Cannot pass non-string to C++ string type "+name);}var length=lengthBytesUTF(value);var ptr=_malloc(4+length+charSize);HEAPU32[ptr>>2]=length>>shift;encodeString(value,ptr+4,length+charSize);if(destructors!==null){destructors.push(_free,ptr);}return ptr},"argPackAdvance":8,"readValueFromPointer":simpleReadValueFromPointer,destructorFunction:function(ptr){_free(ptr);}});}function __embind_register_void(rawType,name){name=readLatin1String(name);registerType(rawType,{isVoid:true,name:name,"argPackAdvance":0,"fromWireType":function(){return undefined},"toWireType":function(destructors,o){return undefined}});}function __emscripten_date_now(){return Date.now()}var nowIsMonotonic=true;function __emscripten_get_now_is_monotonic(){return nowIsMonotonic}function __emscripten_get_progname(str,len){stringToUTF8(thisProgram,str,len);}function requireRegisteredType(rawType,humanName){var impl=registeredTypes[rawType];if(undefined===impl){throwBindingError(humanName+" has unknown type "+getTypeName(rawType));}return impl}function __emval_lookupTypes(argCount,argTypes){var a=new Array(argCount);for(var i=0;i<argCount;++i){a[i]=requireRegisteredType(HEAP32[(argTypes>>2)+i],"parameter "+i);}return a}function __emval_call(handle,argCount,argTypes,argv){handle=Emval.toValue(handle);var types=__emval_lookupTypes(argCount,argTypes);var args=new Array(argCount);for(var i=0;i<argCount;++i){var type=types[i];args[i]=type["readValueFromPointer"](argv);argv+=type["argPackAdvance"];}var rv=handle.apply(undefined,args);return Emval.toHandle(rv)}function __emval_equals(first,second){first=Emval.toValue(first);second=Emval.toValue(second);return first==second}function __emval_incref(handle){if(handle>4){emval_handle_array[handle].refcount+=1;}}function __emval_take_value(type,argv){type=requireRegisteredType(type,"_emval_take_value");var v=type["readValueFromPointer"](argv);return Emval.toHandle(v)}function __gmtime_js(time,tmPtr){var date=new Date(HEAP32[time>>2]*1e3);HEAP32[tmPtr>>2]=date.getUTCSeconds();HEAP32[tmPtr+4>>2]=date.getUTCMinutes();HEAP32[tmPtr+8>>2]=date.getUTCHours();HEAP32[tmPtr+12>>2]=date.getUTCDate();HEAP32[tmPtr+16>>2]=date.getUTCMonth();HEAP32[tmPtr+20>>2]=date.getUTCFullYear()-1900;HEAP32[tmPtr+24>>2]=date.getUTCDay();var start=Date.UTC(date.getUTCFullYear(),0,1,0,0,0,0);var yday=(date.getTime()-start)/(1e3*60*60*24)|0;HEAP32[tmPtr+28>>2]=yday;}function __mktime_js(tmPtr){var date=new Date(HEAP32[tmPtr+20>>2]+1900,HEAP32[tmPtr+16>>2],HEAP32[tmPtr+12>>2],HEAP32[tmPtr+8>>2],HEAP32[tmPtr+4>>2],HEAP32[tmPtr>>2],0);var dst=HEAP32[tmPtr+32>>2];var guessedOffset=date.getTimezoneOffset();var start=new Date(date.getFullYear(),0,1);var summerOffset=new Date(date.getFullYear(),6,1).getTimezoneOffset();var winterOffset=start.getTimezoneOffset();var dstOffset=Math.min(winterOffset,summerOffset);if(dst<0){HEAP32[tmPtr+32>>2]=Number(summerOffset!=winterOffset&&dstOffset==guessedOffset);}else if(dst>0!=(dstOffset==guessedOffset)){var nonDstOffset=Math.max(winterOffset,summerOffset);var trueOffset=dst>0?dstOffset:nonDstOffset;date.setTime(date.getTime()+(trueOffset-guessedOffset)*6e4);}HEAP32[tmPtr+24>>2]=date.getDay();var yday=(date.getTime()-start.getTime())/(1e3*60*60*24)|0;HEAP32[tmPtr+28>>2]=yday;HEAP32[tmPtr>>2]=date.getSeconds();HEAP32[tmPtr+4>>2]=date.getMinutes();HEAP32[tmPtr+8>>2]=date.getHours();HEAP32[tmPtr+12>>2]=date.getDate();HEAP32[tmPtr+16>>2]=date.getMonth();return date.getTime()/1e3|0}function _tzset_impl(timezone,daylight,tzname){var currentYear=(new Date).getFullYear();var winter=new Date(currentYear,0,1);var summer=new Date(currentYear,6,1);var winterOffset=winter.getTimezoneOffset();var summerOffset=summer.getTimezoneOffset();var stdTimezoneOffset=Math.max(winterOffset,summerOffset);HEAP32[timezone>>2]=stdTimezoneOffset*60;HEAP32[daylight>>2]=Number(winterOffset!=summerOffset);function extractZone(date){var match=date.toTimeString().match(/\(([A-Za-z ]+)\)$/);return match?match[1]:"GMT"}var winterName=extractZone(winter);var summerName=extractZone(summer);var winterNamePtr=allocateUTF8(winterName);var summerNamePtr=allocateUTF8(summerName);if(summerOffset<winterOffset){HEAP32[tzname>>2]=winterNamePtr;HEAP32[tzname+4>>2]=summerNamePtr;}else {HEAP32[tzname>>2]=summerNamePtr;HEAP32[tzname+4>>2]=winterNamePtr;}}function __tzset_js(timezone,daylight,tzname){if(__tzset_js.called)return;__tzset_js.called=true;_tzset_impl(timezone,daylight,tzname);}function _abort(){abort("");}function _emscripten_get_heap_max(){return 2147483648}function emscripten_realloc_buffer(size){try{wasmMemory.grow(size-buffer.byteLength+65535>>>16);updateGlobalBufferAndViews(wasmMemory.buffer);return 1}catch(e){}}function _emscripten_resize_heap(requestedSize){var oldSize=HEAPU8.length;requestedSize=requestedSize>>>0;var maxHeapSize=_emscripten_get_heap_max();if(requestedSize>maxHeapSize){return false}let alignUp=(x,multiple)=>x+(multiple-x%multiple)%multiple;for(var cutDown=1;cutDown<=4;cutDown*=2){var overGrownHeapSize=oldSize*(1+.2/cutDown);overGrownHeapSize=Math.min(overGrownHeapSize,requestedSize+100663296);var newSize=Math.min(maxHeapSize,alignUp(Math.max(requestedSize,overGrownHeapSize),65536));var replacement=emscripten_realloc_buffer(newSize);if(replacement){return true}}return false}var ENV={};function getExecutableName(){return thisProgram||"./this.program"}function getEnvStrings(){if(!getEnvStrings.strings){var lang=(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8";var env={"USER":"web_user","LOGNAME":"web_user","PATH":"/","PWD":"/","HOME":"/home/web_user","LANG":lang,"_":getExecutableName()};for(var x in ENV){if(ENV[x]===undefined)delete env[x];else env[x]=ENV[x];}var strings=[];for(var x in env){strings.push(x+"="+env[x]);}getEnvStrings.strings=strings;}return getEnvStrings.strings}function _environ_get(__environ,environ_buf){var bufSize=0;getEnvStrings().forEach(function(string,i){var ptr=environ_buf+bufSize;HEAP32[__environ+i*4>>2]=ptr;writeAsciiToMemory(string,ptr);bufSize+=string.length+1;});return 0}function _environ_sizes_get(penviron_count,penviron_buf_size){var strings=getEnvStrings();HEAP32[penviron_count>>2]=strings.length;var bufSize=0;strings.forEach(function(string){bufSize+=string.length+1;});HEAP32[penviron_buf_size>>2]=bufSize;return 0}function _exit(status){exit(status);}function _fd_close(fd){try{var stream=SYSCALLS.getStreamFromFD(fd);FS.close(stream);return 0}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return e.errno}}function doReadv(stream,iov,iovcnt,offset){var ret=0;for(var i=0;i<iovcnt;i++){var ptr=HEAPU32[iov>>2];var len=HEAPU32[iov+4>>2];iov+=8;var curr=FS.read(stream,HEAP8,ptr,len,offset);if(curr<0)return -1;ret+=curr;if(curr<len)break}return ret}function _fd_read(fd,iov,iovcnt,pnum){try{var stream=SYSCALLS.getStreamFromFD(fd);var num=doReadv(stream,iov,iovcnt);HEAP32[pnum>>2]=num;return 0}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return e.errno}}function _fd_seek(fd,offset_low,offset_high,whence,newOffset){try{var stream=SYSCALLS.getStreamFromFD(fd);var HIGH_OFFSET=4294967296;var offset=offset_high*HIGH_OFFSET+(offset_low>>>0);var DOUBLE_LIMIT=9007199254740992;if(offset<=-DOUBLE_LIMIT||offset>=DOUBLE_LIMIT){return 61}FS.llseek(stream,offset,whence);tempI64=[stream.position>>>0,(tempDouble=stream.position,+Math.abs(tempDouble)>=1?tempDouble>0?(Math.min(+Math.floor(tempDouble/4294967296),4294967295)|0)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[newOffset>>2]=tempI64[0],HEAP32[newOffset+4>>2]=tempI64[1];if(stream.getdents&&offset===0&&whence===0)stream.getdents=null;return 0}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return e.errno}}function doWritev(stream,iov,iovcnt,offset){var ret=0;for(var i=0;i<iovcnt;i++){var ptr=HEAPU32[iov>>2];var len=HEAPU32[iov+4>>2];iov+=8;var curr=FS.write(stream,HEAP8,ptr,len,offset);if(curr<0)return -1;ret+=curr;}return ret}function _fd_write(fd,iov,iovcnt,pnum){try{var stream=SYSCALLS.getStreamFromFD(fd);var num=doWritev(stream,iov,iovcnt);HEAP32[pnum>>2]=num;return 0}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return e.errno}}function _getTempRet0(){return getTempRet0()}function _llvm_eh_typeid_for(type){return type}function _proc_exit(code){procExit(code);}function _setTempRet0(val){setTempRet0(val);}function __isLeapYear(year){return year%4===0&&(year%100!==0||year%400===0)}function __arraySum(array,index){var sum=0;for(var i=0;i<=index;sum+=array[i++]){}return sum}var __MONTH_DAYS_LEAP=[31,29,31,30,31,30,31,31,30,31,30,31];var __MONTH_DAYS_REGULAR=[31,28,31,30,31,30,31,31,30,31,30,31];function __addDays(date,days){var newDate=new Date(date.getTime());while(days>0){var leap=__isLeapYear(newDate.getFullYear());var currentMonth=newDate.getMonth();var daysInCurrentMonth=(leap?__MONTH_DAYS_LEAP:__MONTH_DAYS_REGULAR)[currentMonth];if(days>daysInCurrentMonth-newDate.getDate()){days-=daysInCurrentMonth-newDate.getDate()+1;newDate.setDate(1);if(currentMonth<11){newDate.setMonth(currentMonth+1);}else {newDate.setMonth(0);newDate.setFullYear(newDate.getFullYear()+1);}}else {newDate.setDate(newDate.getDate()+days);return newDate}}return newDate}function _strftime(s,maxsize,format,tm){var tm_zone=HEAP32[tm+40>>2];var date={tm_sec:HEAP32[tm>>2],tm_min:HEAP32[tm+4>>2],tm_hour:HEAP32[tm+8>>2],tm_mday:HEAP32[tm+12>>2],tm_mon:HEAP32[tm+16>>2],tm_year:HEAP32[tm+20>>2],tm_wday:HEAP32[tm+24>>2],tm_yday:HEAP32[tm+28>>2],tm_isdst:HEAP32[tm+32>>2],tm_gmtoff:HEAP32[tm+36>>2],tm_zone:tm_zone?UTF8ToString(tm_zone):""};var pattern=UTF8ToString(format);var EXPANSION_RULES_1={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var rule in EXPANSION_RULES_1){pattern=pattern.replace(new RegExp(rule,"g"),EXPANSION_RULES_1[rule]);}var WEEKDAYS=["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"];var MONTHS=["January","February","March","April","May","June","July","August","September","October","November","December"];function leadingSomething(value,digits,character){var str=typeof value=="number"?value.toString():value||"";while(str.length<digits){str=character[0]+str;}return str}function leadingNulls(value,digits){return leadingSomething(value,digits,"0")}function compareByDay(date1,date2){function sgn(value){return value<0?-1:value>0?1:0}var compare;if((compare=sgn(date1.getFullYear()-date2.getFullYear()))===0){if((compare=sgn(date1.getMonth()-date2.getMonth()))===0){compare=sgn(date1.getDate()-date2.getDate());}}return compare}function getFirstWeekStartDate(janFourth){switch(janFourth.getDay()){case 0:return new Date(janFourth.getFullYear()-1,11,29);case 1:return janFourth;case 2:return new Date(janFourth.getFullYear(),0,3);case 3:return new Date(janFourth.getFullYear(),0,2);case 4:return new Date(janFourth.getFullYear(),0,1);case 5:return new Date(janFourth.getFullYear()-1,11,31);case 6:return new Date(janFourth.getFullYear()-1,11,30)}}function getWeekBasedYear(date){var thisDate=__addDays(new Date(date.tm_year+1900,0,1),date.tm_yday);var janFourthThisYear=new Date(thisDate.getFullYear(),0,4);var janFourthNextYear=new Date(thisDate.getFullYear()+1,0,4);var firstWeekStartThisYear=getFirstWeekStartDate(janFourthThisYear);var firstWeekStartNextYear=getFirstWeekStartDate(janFourthNextYear);if(compareByDay(firstWeekStartThisYear,thisDate)<=0){if(compareByDay(firstWeekStartNextYear,thisDate)<=0){return thisDate.getFullYear()+1}else {return thisDate.getFullYear()}}else {return thisDate.getFullYear()-1}}var EXPANSION_RULES_2={"%a":function(date){return WEEKDAYS[date.tm_wday].substring(0,3)},"%A":function(date){return WEEKDAYS[date.tm_wday]},"%b":function(date){return MONTHS[date.tm_mon].substring(0,3)},"%B":function(date){return MONTHS[date.tm_mon]},"%C":function(date){var year=date.tm_year+1900;return leadingNulls(year/100|0,2)},"%d":function(date){return leadingNulls(date.tm_mday,2)},"%e":function(date){return leadingSomething(date.tm_mday,2," ")},"%g":function(date){return getWeekBasedYear(date).toString().substring(2)},"%G":function(date){return getWeekBasedYear(date)},"%H":function(date){return leadingNulls(date.tm_hour,2)},"%I":function(date){var twelveHour=date.tm_hour;if(twelveHour==0)twelveHour=12;else if(twelveHour>12)twelveHour-=12;return leadingNulls(twelveHour,2)},"%j":function(date){return leadingNulls(date.tm_mday+__arraySum(__isLeapYear(date.tm_year+1900)?__MONTH_DAYS_LEAP:__MONTH_DAYS_REGULAR,date.tm_mon-1),3)},"%m":function(date){return leadingNulls(date.tm_mon+1,2)},"%M":function(date){return leadingNulls(date.tm_min,2)},"%n":function(){return "\n"},"%p":function(date){if(date.tm_hour>=0&&date.tm_hour<12){return "AM"}else {return "PM"}},"%S":function(date){return leadingNulls(date.tm_sec,2)},"%t":function(){return "\t"},"%u":function(date){return date.tm_wday||7},"%U":function(date){var days=date.tm_yday+7-date.tm_wday;return leadingNulls(Math.floor(days/7),2)},"%V":function(date){var val=Math.floor((date.tm_yday+7-(date.tm_wday+6)%7)/7);if((date.tm_wday+371-date.tm_yday-2)%7<=2){val++;}if(!val){val=52;var dec31=(date.tm_wday+7-date.tm_yday-1)%7;if(dec31==4||dec31==5&&__isLeapYear(date.tm_year%400-1)){val++;}}else if(val==53){var jan1=(date.tm_wday+371-date.tm_yday)%7;if(jan1!=4&&(jan1!=3||!__isLeapYear(date.tm_year)))val=1;}return leadingNulls(val,2)},"%w":function(date){return date.tm_wday},"%W":function(date){var days=date.tm_yday+7-(date.tm_wday+6)%7;return leadingNulls(Math.floor(days/7),2)},"%y":function(date){return (date.tm_year+1900).toString().substring(2)},"%Y":function(date){return date.tm_year+1900},"%z":function(date){var off=date.tm_gmtoff;var ahead=off>=0;off=Math.abs(off)/60;off=off/60*100+off%60;return (ahead?"+":"-")+String("0000"+off).slice(-4)},"%Z":function(date){return date.tm_zone},"%%":function(){return "%"}};pattern=pattern.replace(/%%/g,"\0\0");for(var rule in EXPANSION_RULES_2){if(pattern.includes(rule)){pattern=pattern.replace(new RegExp(rule,"g"),EXPANSION_RULES_2[rule](date));}}pattern=pattern.replace(/\0\0/g,"%");var bytes=intArrayFromString(pattern,false);if(bytes.length>maxsize){return 0}writeArrayToMemory(bytes,s);return bytes.length-1}function _strftime_l(s,maxsize,format,tm){return _strftime(s,maxsize,format,tm)}function _v4_generate_JIT_code(){err("missing function: v4_generate_JIT_code");abort(-1);}var FSNode=function(parent,name,mode,rdev){if(!parent){parent=this;}this.parent=parent;this.mount=parent.mount;this.mounted=null;this.id=FS.nextInode++;this.name=name;this.mode=mode;this.node_ops={};this.stream_ops={};this.rdev=rdev;};var readMode=292|73;var writeMode=146;Object.defineProperties(FSNode.prototype,{read:{get:function(){return (this.mode&readMode)===readMode},set:function(val){val?this.mode|=readMode:this.mode&=~readMode;}},write:{get:function(){return (this.mode&writeMode)===writeMode},set:function(val){val?this.mode|=writeMode:this.mode&=~writeMode;}},isFolder:{get:function(){return FS.isDir(this.mode)}},isDevice:{get:function(){return FS.isChrdev(this.mode)}}});FS.FSNode=FSNode;FS.staticInit();embind_init_charCodes();BindingError=Module["BindingError"]=extendError(Error,"BindingError");InternalError=Module["InternalError"]=extendError(Error,"InternalError");init_emval();UnboundTypeError=Module["UnboundTypeError"]=extendError(Error,"UnboundTypeError");function intArrayFromString(stringy,dontAddNull,length){var len=length>0?length:lengthBytesUTF8(stringy)+1;var u8array=new Array(len);var numBytesWritten=stringToUTF8Array(stringy,u8array,0,u8array.length);if(dontAddNull)u8array.length=numBytesWritten;return u8array}function intArrayToString(array){var ret=[];for(var i=0;i<array.length;i++){var chr=array[i];if(chr>255){chr&=255;}ret.push(String.fromCharCode(chr));}return ret.join("")}var asmLibraryArg={"ya":_CONF_modules_unload,"Aa":_ERR_reason_error_string,"j":___assert_fail,"d":___cxa_allocate_exception,"m":___cxa_begin_catch,"o":___cxa_end_catch,"b":___cxa_find_matching_catch_2,"c":___cxa_find_matching_catch_3,"w":___cxa_free_exception,"O":___cxa_rethrow,"e":___cxa_throw,"ha":___cxa_uncaught_exceptions,"i":___resumeException,"N":___syscall_fcntl64,"fa":___syscall_ioctl,"ma":___syscall_mkdirat,"R":___syscall_openat,"ka":___syscall_stat64,"Z":__embind_register_bigint,"va":__embind_register_bool,"ua":__embind_register_emval,"U":__embind_register_float,"s":__embind_register_function,"y":__embind_register_integer,"u":__embind_register_memory_view,"T":__embind_register_std_string,"J":__embind_register_std_wstring,"wa":__embind_register_void,"H":__emscripten_date_now,"pa":__emscripten_get_now_is_monotonic,"la":__emscripten_get_progname,"Da":__emval_call,"Ea":__emval_decref,"Ca":__emval_equals,"V":__emval_incref,"za":__emval_take_value,"qa":__gmtime_js,"ra":__mktime_js,"sa":__tzset_js,"D":_abort,"ja":_emscripten_get_heap_max,"ia":_emscripten_resize_heap,"na":_environ_get,"oa":_environ_sizes_get,"S":_exit,"I":_fd_close,"Q":_fd_read,"Y":_fd_seek,"P":_fd_write,"a":_getTempRet0,"K":invoke_diii,"L":invoke_fiii,"t":invoke_i,"f":invoke_ii,"h":invoke_iii,"p":invoke_iiii,"n":invoke_iiiii,"ga":invoke_iiiiid,"A":invoke_iiiiii,"v":invoke_iiiiiii,"M":invoke_iiiiiiii,"F":invoke_iiiiiiiiiiii,"W":invoke_iiiiij,"ba":invoke_ji,"aa":invoke_jii,"$":invoke_jiii,"da":invoke_jiiii,"l":invoke_v,"r":invoke_vi,"g":invoke_vii,"k":invoke_viii,"x":invoke_viiii,"G":invoke_viiiii,"Ba":invoke_viiiiii,"z":invoke_viiiiiii,"B":invoke_viiiiiiiiii,"E":invoke_viiiiiiiiiiiiiii,"_":invoke_viiiji,"ca":invoke_viij,"X":invoke_viijii,"q":_llvm_eh_typeid_for,"ta":_proc_exit,"C":_setTempRet0,"ea":_strftime_l,"xa":_v4_generate_JIT_code};createWasm();Module["___wasm_call_ctors"]=function(){return (Module["___wasm_call_ctors"]=Module["asm"]["Ga"]).apply(null,arguments)};var _malloc=Module["_malloc"]=function(){return (_malloc=Module["_malloc"]=Module["asm"]["Ha"]).apply(null,arguments)};Module["__ZN5boost13serialization16singleton_module8get_lockEv"]=function(){return (Module["__ZN5boost13serialization16singleton_module8get_lockEv"]=Module["asm"]["Ja"]).apply(null,arguments)};var _free=Module["_free"]=function(){return (_free=Module["_free"]=Module["asm"]["Ka"]).apply(null,arguments)};var ___errno_location=Module["___errno_location"]=function(){return (___errno_location=Module["___errno_location"]=Module["asm"]["La"]).apply(null,arguments)};var ___getTypeName=Module["___getTypeName"]=function(){return (___getTypeName=Module["___getTypeName"]=Module["asm"]["Ma"]).apply(null,arguments)};Module["___embind_register_native_and_builtin_types"]=function(){return (Module["___embind_register_native_and_builtin_types"]=Module["asm"]["Na"]).apply(null,arguments)};var _setThrew=Module["_setThrew"]=function(){return (_setThrew=Module["_setThrew"]=Module["asm"]["Oa"]).apply(null,arguments)};var stackSave=Module["stackSave"]=function(){return (stackSave=Module["stackSave"]=Module["asm"]["Pa"]).apply(null,arguments)};var stackRestore=Module["stackRestore"]=function(){return (stackRestore=Module["stackRestore"]=Module["asm"]["Qa"]).apply(null,arguments)};var ___cxa_can_catch=Module["___cxa_can_catch"]=function(){return (___cxa_can_catch=Module["___cxa_can_catch"]=Module["asm"]["Ra"]).apply(null,arguments)};var ___cxa_is_pointer_type=Module["___cxa_is_pointer_type"]=function(){return (___cxa_is_pointer_type=Module["___cxa_is_pointer_type"]=Module["asm"]["Sa"]).apply(null,arguments)};var dynCall_ji=Module["dynCall_ji"]=function(){return (dynCall_ji=Module["dynCall_ji"]=Module["asm"]["Ta"]).apply(null,arguments)};Module["dynCall_vijjjdi"]=function(){return (Module["dynCall_vijjjdi"]=Module["asm"]["Ua"]).apply(null,arguments)};Module["dynCall_vij"]=function(){return (Module["dynCall_vij"]=Module["asm"]["Va"]).apply(null,arguments)};Module["dynCall_vijj"]=function(){return (Module["dynCall_vijj"]=Module["asm"]["Wa"]).apply(null,arguments)};var dynCall_viijii=Module["dynCall_viijii"]=function(){return (dynCall_viijii=Module["dynCall_viijii"]=Module["asm"]["Xa"]).apply(null,arguments)};var dynCall_jiiii=Module["dynCall_jiiii"]=function(){return (dynCall_jiiii=Module["dynCall_jiiii"]=Module["asm"]["Ya"]).apply(null,arguments)};var dynCall_viij=Module["dynCall_viij"]=function(){return (dynCall_viij=Module["dynCall_viij"]=Module["asm"]["Za"]).apply(null,arguments)};Module["dynCall_viiji"]=function(){return (Module["dynCall_viiji"]=Module["asm"]["_a"]).apply(null,arguments)};var dynCall_jii=Module["dynCall_jii"]=function(){return (dynCall_jii=Module["dynCall_jii"]=Module["asm"]["$a"]).apply(null,arguments)};var dynCall_jiii=Module["dynCall_jiii"]=function(){return (dynCall_jiii=Module["dynCall_jiii"]=Module["asm"]["ab"]).apply(null,arguments)};var dynCall_viiiji=Module["dynCall_viiiji"]=function(){return (dynCall_viiiji=Module["dynCall_viiiji"]=Module["asm"]["bb"]).apply(null,arguments)};Module["dynCall_vijiiii"]=function(){return (Module["dynCall_vijiiii"]=Module["asm"]["cb"]).apply(null,arguments)};Module["dynCall_iiiij"]=function(){return (Module["dynCall_iiiij"]=Module["asm"]["db"]).apply(null,arguments)};Module["dynCall_jiji"]=function(){return (Module["dynCall_jiji"]=Module["asm"]["eb"]).apply(null,arguments)};var dynCall_iiiiij=Module["dynCall_iiiiij"]=function(){return (dynCall_iiiiij=Module["dynCall_iiiiij"]=Module["asm"]["fb"]).apply(null,arguments)};Module["dynCall_iiiiijj"]=function(){return (Module["dynCall_iiiiijj"]=Module["asm"]["gb"]).apply(null,arguments)};Module["dynCall_iiiiiijj"]=function(){return (Module["dynCall_iiiiiijj"]=Module["asm"]["hb"]).apply(null,arguments)};function invoke_viiii(index,a1,a2,a3,a4){var sp=stackSave();try{getWasmTableEntry(index)(a1,a2,a3,a4);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_vii(index,a1,a2){var sp=stackSave();try{getWasmTableEntry(index)(a1,a2);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_iii(index,a1,a2){var sp=stackSave();try{return getWasmTableEntry(index)(a1,a2)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_v(index){var sp=stackSave();try{getWasmTableEntry(index)();}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_ii(index,a1){var sp=stackSave();try{return getWasmTableEntry(index)(a1)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_iiii(index,a1,a2,a3){var sp=stackSave();try{return getWasmTableEntry(index)(a1,a2,a3)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_viii(index,a1,a2,a3){var sp=stackSave();try{getWasmTableEntry(index)(a1,a2,a3);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_iiiiii(index,a1,a2,a3,a4,a5){var sp=stackSave();try{return getWasmTableEntry(index)(a1,a2,a3,a4,a5)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_vi(index,a1){var sp=stackSave();try{getWasmTableEntry(index)(a1);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_iiiii(index,a1,a2,a3,a4){var sp=stackSave();try{return getWasmTableEntry(index)(a1,a2,a3,a4)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_iiiiiii(index,a1,a2,a3,a4,a5,a6){var sp=stackSave();try{return getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_viiiii(index,a1,a2,a3,a4,a5){var sp=stackSave();try{getWasmTableEntry(index)(a1,a2,a3,a4,a5);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_viiiiii(index,a1,a2,a3,a4,a5,a6){var sp=stackSave();try{getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_iiiiid(index,a1,a2,a3,a4,a5){var sp=stackSave();try{return getWasmTableEntry(index)(a1,a2,a3,a4,a5)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_iiiiiiii(index,a1,a2,a3,a4,a5,a6,a7){var sp=stackSave();try{return getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6,a7)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_fiii(index,a1,a2,a3){var sp=stackSave();try{return getWasmTableEntry(index)(a1,a2,a3)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_diii(index,a1,a2,a3){var sp=stackSave();try{return getWasmTableEntry(index)(a1,a2,a3)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_i(index){var sp=stackSave();try{return getWasmTableEntry(index)()}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_viiiiiii(index,a1,a2,a3,a4,a5,a6,a7){var sp=stackSave();try{getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6,a7);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_iiiiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11){var sp=stackSave();try{return getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_viiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10){var sp=stackSave();try{getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_viiiiiiiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15){var sp=stackSave();try{getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_jiiii(index,a1,a2,a3,a4){var sp=stackSave();try{return dynCall_jiiii(index,a1,a2,a3,a4)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_viij(index,a1,a2,a3,a4){var sp=stackSave();try{dynCall_viij(index,a1,a2,a3,a4);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_ji(index,a1){var sp=stackSave();try{return dynCall_ji(index,a1)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_jii(index,a1,a2){var sp=stackSave();try{return dynCall_jii(index,a1,a2)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_jiii(index,a1,a2,a3){var sp=stackSave();try{return dynCall_jiii(index,a1,a2,a3)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_viiiji(index,a1,a2,a3,a4,a5,a6){var sp=stackSave();try{dynCall_viiiji(index,a1,a2,a3,a4,a5,a6);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_viijii(index,a1,a2,a3,a4,a5,a6){var sp=stackSave();try{dynCall_viijii(index,a1,a2,a3,a4,a5,a6);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_iiiiij(index,a1,a2,a3,a4,a5,a6){var sp=stackSave();try{return dynCall_iiiiij(index,a1,a2,a3,a4,a5,a6)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}Module["UTF8ToString"]=UTF8ToString;Module["stringToUTF8"]=stringToUTF8;Module["lengthBytesUTF8"]=lengthBytesUTF8;Module["addFunction"]=addFunction;Module["getTempRet0"]=getTempRet0;Module["intArrayToString"]=intArrayToString;var calledRun;function ExitStatus(status){this.name="ExitStatus";this.message="Program terminated with exit("+status+")";this.status=status;}dependenciesFulfilled=function runCaller(){if(!calledRun)run();if(!calledRun)dependenciesFulfilled=runCaller;};function run(args){if(runDependencies>0){return}preRun();if(runDependencies>0){return}function doRun(){if(calledRun)return;calledRun=true;Module["calledRun"]=true;if(ABORT)return;initRuntime();readyPromiseResolve(Module);if(Module["onRuntimeInitialized"])Module["onRuntimeInitialized"]();postRun();}if(Module["setStatus"]){Module["setStatus"]("Running...");setTimeout(function(){setTimeout(function(){Module["setStatus"]("");},1);doRun();},1);}else {doRun();}}Module["run"]=run;function exit(status,implicit){procExit(status);}function procExit(code){if(!keepRuntimeAlive()){if(Module["onExit"])Module["onExit"](code);ABORT=true;}quit_(code,new ExitStatus(code));}if(Module["preInit"]){if(typeof Module["preInit"]=="function")Module["preInit"]=[Module["preInit"]];while(Module["preInit"].length>0){Module["preInit"].pop()();}}run();


		  return monero_javascript.ready
		}
		);
		})();
		module.exports = monero_javascript;
} (monero_wallet_keys));
	return monero_wallet_keys.exports;
}

var monero_wallet_full = {exports: {}};

var hasRequiredMonero_wallet_full;

function requireMonero_wallet_full () {
	if (hasRequiredMonero_wallet_full) return monero_wallet_full.exports;
	hasRequiredMonero_wallet_full = 1;
	(function (module, exports) {
		var monero_javascript = (() => {
		  var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;
		  if (typeof __filename !== 'undefined') _scriptDir = _scriptDir || __filename;
		  return (
		function(monero_javascript) {
		  monero_javascript = monero_javascript || {};

		var Module=typeof monero_javascript!="undefined"?monero_javascript:{};var readyPromiseResolve,readyPromiseReject;Module["ready"]=new Promise(function(resolve,reject){readyPromiseResolve=resolve;readyPromiseReject=reject;});var moduleOverrides=Object.assign({},Module);var thisProgram="./this.program";var quit_=(status,toThrow)=>{throw toThrow};var ENVIRONMENT_IS_WEB=typeof window=="object";var ENVIRONMENT_IS_WORKER=typeof importScripts=="function";var ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";var scriptDirectory="";function locateFile(path){if(Module["locateFile"]){return Module["locateFile"](path,scriptDirectory)}return scriptDirectory+path}var read_,readAsync,readBinary;function logExceptionOnExit(e){if(e instanceof ExitStatus)return;let toLog=e;err("exiting due to exception: "+toLog);}var fs;var nodePath;var requireNodeFS;if(ENVIRONMENT_IS_NODE){if(ENVIRONMENT_IS_WORKER){scriptDirectory=require$$0$1.dirname(scriptDirectory)+"/";}else {scriptDirectory=__dirname+"/";}requireNodeFS=(()=>{if(!nodePath){fs=require$$1$1;nodePath=require$$0$1;}});read_=function shell_read(filename,binary){requireNodeFS();filename=nodePath["normalize"](filename);return fs.readFileSync(filename,binary?undefined:"utf8")};readBinary=(filename=>{var ret=read_(filename,true);if(!ret.buffer){ret=new Uint8Array(ret);}return ret});readAsync=((filename,onload,onerror)=>{requireNodeFS();filename=nodePath["normalize"](filename);fs.readFile(filename,function(err,data){if(err)onerror(err);else onload(data.buffer);});});if(process["argv"].length>1){thisProgram=process["argv"][1].replace(/\\/g,"/");}process["argv"].slice(2);process["on"]("unhandledRejection",function(reason){throw reason});quit_=((status,toThrow)=>{if(keepRuntimeAlive()){process["exitCode"]=status;throw toThrow}logExceptionOnExit(toThrow);process["exit"](status);});Module["inspect"]=function(){return "[Emscripten Module object]"};}else if(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER){if(ENVIRONMENT_IS_WORKER){scriptDirectory=self.location.href;}else if(typeof document!="undefined"&&document.currentScript){scriptDirectory=document.currentScript.src;}if(_scriptDir){scriptDirectory=_scriptDir;}if(scriptDirectory.indexOf("blob:")!==0){scriptDirectory=scriptDirectory.substr(0,scriptDirectory.replace(/[?#].*/,"").lastIndexOf("/")+1);}else {scriptDirectory="";}{read_=(url=>{var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.send(null);return xhr.responseText});if(ENVIRONMENT_IS_WORKER){readBinary=(url=>{var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.responseType="arraybuffer";xhr.send(null);return new Uint8Array(xhr.response)});}readAsync=((url,onload,onerror)=>{var xhr=new XMLHttpRequest;xhr.open("GET",url,true);xhr.responseType="arraybuffer";xhr.onload=(()=>{if(xhr.status==200||xhr.status==0&&xhr.response){onload(xhr.response);return}onerror();});xhr.onerror=onerror;xhr.send(null);});}}else;var out=Module["print"]||console.log.bind(console);var err=Module["printErr"]||console.warn.bind(console);Object.assign(Module,moduleOverrides);moduleOverrides=null;if(Module["arguments"])Module["arguments"];if(Module["thisProgram"])thisProgram=Module["thisProgram"];if(Module["quit"])quit_=Module["quit"];function uleb128Encode(n){if(n<128){return [n]}return [n%128|128,n>>7]}function convertJsFunctionToWasm(func,sig){if(typeof WebAssembly.Function=="function"){var typeNames={"i":"i32","j":"i64","f":"f32","d":"f64"};var type={parameters:[],results:sig[0]=="v"?[]:[typeNames[sig[0]]]};for(var i=1;i<sig.length;++i){type.parameters.push(typeNames[sig[i]]);}return new WebAssembly.Function(type,func)}var typeSection=[1,96];var sigRet=sig.slice(0,1);var sigParam=sig.slice(1);var typeCodes={"i":127,"j":126,"f":125,"d":124};typeSection=typeSection.concat(uleb128Encode(sigParam.length));for(var i=0;i<sigParam.length;++i){typeSection.push(typeCodes[sigParam[i]]);}if(sigRet=="v"){typeSection.push(0);}else {typeSection=typeSection.concat([1,typeCodes[sigRet]]);}typeSection=[1].concat(uleb128Encode(typeSection.length),typeSection);var bytes=new Uint8Array([0,97,115,109,1,0,0,0].concat(typeSection,[2,7,1,1,101,1,102,0,0,7,5,1,1,102,0,0]));var module=new WebAssembly.Module(bytes);var instance=new WebAssembly.Instance(module,{"e":{"f":func}});var wrappedFunc=instance.exports["f"];return wrappedFunc}var freeTableIndexes=[];var functionsInTableMap;function getEmptyTableSlot(){if(freeTableIndexes.length){return freeTableIndexes.pop()}try{wasmTable.grow(1);}catch(err){if(!(err instanceof RangeError)){throw err}throw "Unable to grow wasm table. Set ALLOW_TABLE_GROWTH."}return wasmTable.length-1}function updateTableMap(offset,count){for(var i=offset;i<offset+count;i++){var item=getWasmTableEntry(i);if(item){functionsInTableMap.set(item,i);}}}function addFunction(func,sig){if(!functionsInTableMap){functionsInTableMap=new WeakMap;updateTableMap(0,wasmTable.length);}if(functionsInTableMap.has(func)){return functionsInTableMap.get(func)}var ret=getEmptyTableSlot();try{setWasmTableEntry(ret,func);}catch(err){if(!(err instanceof TypeError)){throw err}var wrapped=convertJsFunctionToWasm(func,sig);setWasmTableEntry(ret,wrapped);}functionsInTableMap.set(func,ret);return ret}var tempRet0=0;var setTempRet0=value=>{tempRet0=value;};var getTempRet0=()=>tempRet0;var wasmBinary;if(Module["wasmBinary"])wasmBinary=Module["wasmBinary"];var noExitRuntime=Module["noExitRuntime"]||true;if(typeof WebAssembly!="object"){abort("no native wasm support detected");}var wasmMemory;var ABORT=false;var EXITSTATUS;function assert(condition,text){if(!condition){abort(text);}}var UTF8Decoder=typeof TextDecoder!="undefined"?new TextDecoder("utf8"):undefined;function UTF8ArrayToString(heapOrArray,idx,maxBytesToRead){var endIdx=idx+maxBytesToRead;var endPtr=idx;while(heapOrArray[endPtr]&&!(endPtr>=endIdx))++endPtr;if(endPtr-idx>16&&heapOrArray.buffer&&UTF8Decoder){return UTF8Decoder.decode(heapOrArray.subarray(idx,endPtr))}else {var str="";while(idx<endPtr){var u0=heapOrArray[idx++];if(!(u0&128)){str+=String.fromCharCode(u0);continue}var u1=heapOrArray[idx++]&63;if((u0&224)==192){str+=String.fromCharCode((u0&31)<<6|u1);continue}var u2=heapOrArray[idx++]&63;if((u0&240)==224){u0=(u0&15)<<12|u1<<6|u2;}else {u0=(u0&7)<<18|u1<<12|u2<<6|heapOrArray[idx++]&63;}if(u0<65536){str+=String.fromCharCode(u0);}else {var ch=u0-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023);}}}return str}function UTF8ToString(ptr,maxBytesToRead){return ptr?UTF8ArrayToString(HEAPU8,ptr,maxBytesToRead):""}function stringToUTF8Array(str,heap,outIdx,maxBytesToWrite){if(!(maxBytesToWrite>0))return 0;var startIdx=outIdx;var endIdx=outIdx+maxBytesToWrite-1;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343){var u1=str.charCodeAt(++i);u=65536+((u&1023)<<10)|u1&1023;}if(u<=127){if(outIdx>=endIdx)break;heap[outIdx++]=u;}else if(u<=2047){if(outIdx+1>=endIdx)break;heap[outIdx++]=192|u>>6;heap[outIdx++]=128|u&63;}else if(u<=65535){if(outIdx+2>=endIdx)break;heap[outIdx++]=224|u>>12;heap[outIdx++]=128|u>>6&63;heap[outIdx++]=128|u&63;}else {if(outIdx+3>=endIdx)break;heap[outIdx++]=240|u>>18;heap[outIdx++]=128|u>>12&63;heap[outIdx++]=128|u>>6&63;heap[outIdx++]=128|u&63;}}heap[outIdx]=0;return outIdx-startIdx}function stringToUTF8(str,outPtr,maxBytesToWrite){return stringToUTF8Array(str,HEAPU8,outPtr,maxBytesToWrite)}function lengthBytesUTF8(str){var len=0;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343)u=65536+((u&1023)<<10)|str.charCodeAt(++i)&1023;if(u<=127)++len;else if(u<=2047)len+=2;else if(u<=65535)len+=3;else len+=4;}return len}var UTF16Decoder=typeof TextDecoder!="undefined"?new TextDecoder("utf-16le"):undefined;function UTF16ToString(ptr,maxBytesToRead){var endPtr=ptr;var idx=endPtr>>1;var maxIdx=idx+maxBytesToRead/2;while(!(idx>=maxIdx)&&HEAPU16[idx])++idx;endPtr=idx<<1;if(endPtr-ptr>32&&UTF16Decoder){return UTF16Decoder.decode(HEAPU8.subarray(ptr,endPtr))}else {var str="";for(var i=0;!(i>=maxBytesToRead/2);++i){var codeUnit=HEAP16[ptr+i*2>>1];if(codeUnit==0)break;str+=String.fromCharCode(codeUnit);}return str}}function stringToUTF16(str,outPtr,maxBytesToWrite){if(maxBytesToWrite===undefined){maxBytesToWrite=2147483647;}if(maxBytesToWrite<2)return 0;maxBytesToWrite-=2;var startPtr=outPtr;var numCharsToWrite=maxBytesToWrite<str.length*2?maxBytesToWrite/2:str.length;for(var i=0;i<numCharsToWrite;++i){var codeUnit=str.charCodeAt(i);HEAP16[outPtr>>1]=codeUnit;outPtr+=2;}HEAP16[outPtr>>1]=0;return outPtr-startPtr}function lengthBytesUTF16(str){return str.length*2}function UTF32ToString(ptr,maxBytesToRead){var i=0;var str="";while(!(i>=maxBytesToRead/4)){var utf32=HEAP32[ptr+i*4>>2];if(utf32==0)break;++i;if(utf32>=65536){var ch=utf32-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023);}else {str+=String.fromCharCode(utf32);}}return str}function stringToUTF32(str,outPtr,maxBytesToWrite){if(maxBytesToWrite===undefined){maxBytesToWrite=2147483647;}if(maxBytesToWrite<4)return 0;var startPtr=outPtr;var endPtr=startPtr+maxBytesToWrite-4;for(var i=0;i<str.length;++i){var codeUnit=str.charCodeAt(i);if(codeUnit>=55296&&codeUnit<=57343){var trailSurrogate=str.charCodeAt(++i);codeUnit=65536+((codeUnit&1023)<<10)|trailSurrogate&1023;}HEAP32[outPtr>>2]=codeUnit;outPtr+=4;if(outPtr+4>endPtr)break}HEAP32[outPtr>>2]=0;return outPtr-startPtr}function lengthBytesUTF32(str){var len=0;for(var i=0;i<str.length;++i){var codeUnit=str.charCodeAt(i);if(codeUnit>=55296&&codeUnit<=57343)++i;len+=4;}return len}function allocateUTF8(str){var size=lengthBytesUTF8(str)+1;var ret=_malloc(size);if(ret)stringToUTF8Array(str,HEAP8,ret,size);return ret}function writeArrayToMemory(array,buffer){HEAP8.set(array,buffer);}function writeAsciiToMemory(str,buffer,dontAddNull){for(var i=0;i<str.length;++i){HEAP8[buffer++>>0]=str.charCodeAt(i);}if(!dontAddNull)HEAP8[buffer>>0]=0;}var buffer,HEAP8,HEAPU8,HEAP16,HEAPU16,HEAP32,HEAPU32,HEAPF32,HEAPF64;function updateGlobalBufferAndViews(buf){buffer=buf;Module["HEAP8"]=HEAP8=new Int8Array(buf);Module["HEAP16"]=HEAP16=new Int16Array(buf);Module["HEAP32"]=HEAP32=new Int32Array(buf);Module["HEAPU8"]=HEAPU8=new Uint8Array(buf);Module["HEAPU16"]=HEAPU16=new Uint16Array(buf);Module["HEAPU32"]=HEAPU32=new Uint32Array(buf);Module["HEAPF32"]=HEAPF32=new Float32Array(buf);Module["HEAPF64"]=HEAPF64=new Float64Array(buf);}Module["INITIAL_MEMORY"]||16777216;var wasmTable;var __ATPRERUN__=[];var __ATINIT__=[];var __ATPOSTRUN__=[];function keepRuntimeAlive(){return noExitRuntime}function preRun(){if(Module["preRun"]){if(typeof Module["preRun"]=="function")Module["preRun"]=[Module["preRun"]];while(Module["preRun"].length){addOnPreRun(Module["preRun"].shift());}}callRuntimeCallbacks(__ATPRERUN__);}function initRuntime(){if(!Module["noFSInit"]&&!FS.init.initialized)FS.init();FS.ignorePermissions=false;callRuntimeCallbacks(__ATINIT__);}function postRun(){if(Module["postRun"]){if(typeof Module["postRun"]=="function")Module["postRun"]=[Module["postRun"]];while(Module["postRun"].length){addOnPostRun(Module["postRun"].shift());}}callRuntimeCallbacks(__ATPOSTRUN__);}function addOnPreRun(cb){__ATPRERUN__.unshift(cb);}function addOnInit(cb){__ATINIT__.unshift(cb);}function addOnPostRun(cb){__ATPOSTRUN__.unshift(cb);}var runDependencies=0;var dependenciesFulfilled=null;function getUniqueRunDependency(id){return id}function addRunDependency(id){runDependencies++;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies);}}function removeRunDependency(id){runDependencies--;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies);}if(runDependencies==0){if(dependenciesFulfilled){var callback=dependenciesFulfilled;dependenciesFulfilled=null;callback();}}}function abort(what){{if(Module["onAbort"]){Module["onAbort"](what);}}what="Aborted("+what+")";err(what);ABORT=true;EXITSTATUS=1;what+=". Build with -sASSERTIONS for more info.";var e=new WebAssembly.RuntimeError(what);readyPromiseReject(e);throw e}var dataURIPrefix="data:application/octet-stream;base64,";function isDataURI(filename){return filename.startsWith(dataURIPrefix)}function isFileURI(filename){return filename.startsWith("file://")}var wasmBinaryFile;wasmBinaryFile="monero_wallet_full.wasm";if(!isDataURI(wasmBinaryFile)){wasmBinaryFile=locateFile(wasmBinaryFile);}function getBinary(file){try{if(file==wasmBinaryFile&&wasmBinary){return new Uint8Array(wasmBinary)}if(readBinary){return readBinary(file)}else {throw "both async and sync fetching of the wasm failed"}}catch(err){abort(err);}}function getBinaryPromise(){if(!wasmBinary&&(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER)){if(typeof fetch=="function"&&!isFileURI(wasmBinaryFile)){return fetch(wasmBinaryFile,{credentials:"same-origin"}).then(function(response){if(!response["ok"]){throw "failed to load wasm binary file at '"+wasmBinaryFile+"'"}return response["arrayBuffer"]()}).catch(function(){return getBinary(wasmBinaryFile)})}else {if(readAsync){return new Promise(function(resolve,reject){readAsync(wasmBinaryFile,function(response){resolve(new Uint8Array(response));},reject);})}}}return Promise.resolve().then(function(){return getBinary(wasmBinaryFile)})}function createWasm(){var info={"a":asmLibraryArg};function receiveInstance(instance,module){var exports=instance.exports;exports=Asyncify.instrumentWasmExports(exports);Module["asm"]=exports;wasmMemory=Module["asm"]["zb"];updateGlobalBufferAndViews(wasmMemory.buffer);wasmTable=Module["asm"]["Cb"];addOnInit(Module["asm"]["Ab"]);removeRunDependency();}addRunDependency();function receiveInstantiationResult(result){receiveInstance(result["instance"]);}function instantiateArrayBuffer(receiver){return getBinaryPromise().then(function(binary){return WebAssembly.instantiate(binary,info)}).then(function(instance){return instance}).then(receiver,function(reason){err("failed to asynchronously prepare wasm: "+reason);abort(reason);})}function instantiateAsync(){if(!wasmBinary&&typeof WebAssembly.instantiateStreaming=="function"&&!isDataURI(wasmBinaryFile)&&!isFileURI(wasmBinaryFile)&&typeof fetch=="function"){return fetch(wasmBinaryFile,{credentials:"same-origin"}).then(function(response){var result=WebAssembly.instantiateStreaming(response,info);return result.then(receiveInstantiationResult,function(reason){err("wasm streaming compile failed: "+reason);err("falling back to ArrayBuffer instantiation");return instantiateArrayBuffer(receiveInstantiationResult)})})}else {return instantiateArrayBuffer(receiveInstantiationResult)}}if(Module["instantiateWasm"]){try{var exports=Module["instantiateWasm"](info,receiveInstance);exports=Asyncify.instrumentWasmExports(exports);return exports}catch(e){err("Module.instantiateWasm callback failed with error: "+e);return false}}instantiateAsync().catch(readyPromiseReject);return {}}var tempDouble;var tempI64;function js_send_binary_request(uri,username,password,reject_unauthorized_fn_id,method,body,body_length,timeout){const monerojs=requireMoneroJavascript();const HttpClient=monerojs.HttpClient;const LibraryUtils=monerojs.LibraryUtils;const GenUtils=monerojs.GenUtils;return Asyncify.handleSleep(function(wakeUp){LibraryUtils.loadFullModule().then(module=>{let ptr=body;let length=body_length;let view=new Uint8Array(length);for(let i=0;i<length;i++){view[i]=Module.HEAPU8[ptr/Uint8Array.BYTES_PER_ELEMENT+i];}let wakeUpCalled=false;HttpClient.request({method:UTF8ToString(method),uri:UTF8ToString(uri),username:UTF8ToString(username),password:UTF8ToString(password),body:view,resolveWithFullResponse:true,rejectUnauthorized:LibraryUtils.isRejectUnauthorized(UTF8ToString(reject_unauthorized_fn_id)),requestApi:GenUtils.isFirefox()?"xhr":"fetch"}).then(resp=>{let respBin=resp.body;if(!(respBin instanceof Uint8Array)){console.error("resp is not uint8array");console.error(respBin);}let nDataBytes=respBin.length*respBin.BYTES_PER_ELEMENT;let bodyPtr=Module._malloc(nDataBytes);let heap=new Uint8Array(Module.HEAPU8.buffer,bodyPtr,nDataBytes);heap.set(new Uint8Array(respBin.buffer,respBin.byteOffset,nDataBytes));let respContainer={code:resp.statusCode,message:resp.statusText,headers:resp.headers,bodyPtr:bodyPtr,bodyLength:respBin.length};let respStr=JSON.stringify(respContainer);let lengthBytes=Module.lengthBytesUTF8(respStr)+1;let ptr=Module._malloc(lengthBytes);Module.stringToUTF8(respStr,ptr,lengthBytes);wakeUpCalled=true;wakeUp(ptr);}).catch(err=>{if(wakeUpCalled){console.error("Error caught in JS after previously calling wakeUp(): "+err);throw new Error("Error caught in JS after previously calling wakeUp(): "+err)}let str=err.message?err.message:""+err;str=JSON.stringify({error:str});let lengthBytes=Module.lengthBytesUTF8(str)+1;let ptr=Module._malloc(lengthBytes);Module.stringToUTF8(str,ptr,lengthBytes);wakeUpCalled=true;wakeUp(ptr);});}).catch(err=>{throw new Error("Could not load full wasm module")});})}function js_send_json_request(uri,username,password,reject_unauthorized_fn_id,method,body,timeout){const monerojs=requireMoneroJavascript();const HttpClient=monerojs.HttpClient;const LibraryUtils=monerojs.LibraryUtils;const GenUtils=monerojs.GenUtils;return Asyncify.handleSleep(function(wakeUp){let wakeUpCalled=false;HttpClient.request({method:UTF8ToString(method),uri:UTF8ToString(uri),username:UTF8ToString(username),password:UTF8ToString(password),body:UTF8ToString(body),resolveWithFullResponse:true,rejectUnauthorized:LibraryUtils.isRejectUnauthorized(UTF8ToString(reject_unauthorized_fn_id)),requestApi:GenUtils.isFirefox()?"xhr":"fetch"}).then(resp=>{let respContainer={code:resp.statusCode,message:resp.statusText,body:resp.body,headers:resp.headers};let respStr=JSON.stringify(respContainer);let lengthBytes=Module.lengthBytesUTF8(respStr)+1;let ptr=Module._malloc(lengthBytes);Module.stringToUTF8(respStr,ptr,lengthBytes);wakeUpCalled=true;wakeUp(ptr);}).catch(err=>{if(wakeUpCalled){console.error("Error caught in JS after previously calling wakeUp(): "+err);throw new Error("Error caught in JS after previously calling wakeUp(): "+err)}let str=err.message?err.message:""+err;str=JSON.stringify({error:str});let lengthBytes=Module.lengthBytesUTF8(str)+1;let ptr=Module._malloc(lengthBytes);Module.stringToUTF8(str,ptr,lengthBytes);wakeUpCalled=true;wakeUp(ptr);});})}function callRuntimeCallbacks(callbacks){while(callbacks.length>0){var callback=callbacks.shift();if(typeof callback=="function"){callback(Module);continue}var func=callback.func;if(typeof func=="number"){if(callback.arg===undefined){(function(){dynCall_v.call(null,func);})();}else {(function(a1){dynCall_vi.apply(null,[func,a1]);})(callback.arg);}}else {func(callback.arg===undefined?null:callback.arg);}}}function getWasmTableEntry(funcPtr){return wasmTable.get(funcPtr)}function handleException(e){if(e instanceof ExitStatus||e=="unwind"){return EXITSTATUS}quit_(1,e);}function setWasmTableEntry(idx,func){wasmTable.set(idx,func);}function _BIO_free(){err("missing function: BIO_free");abort(-1);}function _BIO_new_mem_buf(){err("missing function: BIO_new_mem_buf");abort(-1);}function _CONF_modules_unload(){err("missing function: CONF_modules_unload");abort(-1);}function _CRYPTO_free(){err("missing function: CRYPTO_free");abort(-1);}function _ERR_reason_error_string(){err("missing function: ERR_reason_error_string");abort(-1);}function _PEM_read_bio(){err("missing function: PEM_read_bio");abort(-1);}function _PEM_write(){err("missing function: PEM_write");abort(-1);}function __ZN2hw6trezor12register_allEv(){err("missing function: _ZN2hw6trezor12register_allEv");abort(-1);}function __ZN4epee13file_io_utils19load_file_to_stringERKNSt3__212basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEERS7_m(){err("missing function: _ZN4epee13file_io_utils19load_file_to_stringERKNSt3__212basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEERS7_m");abort(-1);}function __ZN4epee13file_io_utils19save_string_to_fileERKNSt3__212basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEES9_(){err("missing function: _ZN4epee13file_io_utils19save_string_to_fileERKNSt3__212basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEES9_");abort(-1);}function __ZN5boost10filesystem6detail12current_pathEPNS_6system10error_codeE(){err("missing function: _ZN5boost10filesystem6detail12current_pathEPNS_6system10error_codeE");abort(-1);}function __ZN5boost10filesystem6detail18create_directoriesERKNS0_4pathEPNS_6system10error_codeE(){err("missing function: _ZN5boost10filesystem6detail18create_directoriesERKNS0_4pathEPNS_6system10error_codeE");abort(-1);}function __ZN5boost10filesystem6detail5spaceERKNS0_4pathEPNS_6system10error_codeE(){err("missing function: _ZN5boost10filesystem6detail5spaceERKNS0_4pathEPNS_6system10error_codeE");abort(-1);}function __ZN5boost10filesystem6detail6removeERKNS0_4pathEPNS_6system10error_codeE(){err("missing function: _ZN5boost10filesystem6detail6removeERKNS0_4pathEPNS_6system10error_codeE");abort(-1);}function __ZN5boost10filesystem6detail6statusERKNS0_4pathEPNS_6system10error_codeE(){err("missing function: _ZN5boost10filesystem6detail6statusERKNS0_4pathEPNS_6system10error_codeE");abort(-1);}function __ZN5boost10filesystem6detail9canonicalERKNS0_4pathES4_PNS_6system10error_codeE(){err("missing function: _ZN5boost10filesystem6detail9canonicalERKNS0_4pathES4_PNS_6system10error_codeE");abort(-1);}function __ZN5boost10filesystem6detail9copy_fileERKNS0_4pathES4_jPNS_6system10error_codeE(){err("missing function: _ZN5boost10filesystem6detail9copy_fileERKNS0_4pathES4_jPNS_6system10error_codeE");abort(-1);}function __ZNK5boost10filesystem4path11parent_pathEv(){err("missing function: _ZNK5boost10filesystem4path11parent_pathEv");abort(-1);}function __ZNK5tools6Notify6notifyEPKcS2_z(){err("missing function: _ZNK5tools6Notify6notifyEPKcS2_z");abort(-1);}function ___assert_fail(condition,filename,line,func){abort("Assertion failed: "+UTF8ToString(condition)+", at: "+[filename?UTF8ToString(filename):"unknown filename",line,func?UTF8ToString(func):"unknown function"]);}function ___cxa_allocate_exception(size){return _malloc(size+24)+24}var exceptionCaught=[];function exception_addRef(info){info.add_ref();}var uncaughtExceptionCount=0;function ___cxa_begin_catch(ptr){var info=new ExceptionInfo(ptr);if(!info.get_caught()){info.set_caught(true);uncaughtExceptionCount--;}info.set_rethrown(false);exceptionCaught.push(info);exception_addRef(info);return info.get_exception_ptr()}function ExceptionInfo(excPtr){this.excPtr=excPtr;this.ptr=excPtr-24;this.set_type=function(type){HEAPU32[this.ptr+4>>2]=type;};this.get_type=function(){return HEAPU32[this.ptr+4>>2]};this.set_destructor=function(destructor){HEAPU32[this.ptr+8>>2]=destructor;};this.get_destructor=function(){return HEAPU32[this.ptr+8>>2]};this.set_refcount=function(refcount){HEAP32[this.ptr>>2]=refcount;};this.set_caught=function(caught){caught=caught?1:0;HEAP8[this.ptr+12>>0]=caught;};this.get_caught=function(){return HEAP8[this.ptr+12>>0]!=0};this.set_rethrown=function(rethrown){rethrown=rethrown?1:0;HEAP8[this.ptr+13>>0]=rethrown;};this.get_rethrown=function(){return HEAP8[this.ptr+13>>0]!=0};this.init=function(type,destructor){this.set_adjusted_ptr(0);this.set_type(type);this.set_destructor(destructor);this.set_refcount(0);this.set_caught(false);this.set_rethrown(false);};this.add_ref=function(){var value=HEAP32[this.ptr>>2];HEAP32[this.ptr>>2]=value+1;};this.release_ref=function(){var prev=HEAP32[this.ptr>>2];HEAP32[this.ptr>>2]=prev-1;return prev===1};this.set_adjusted_ptr=function(adjustedPtr){HEAPU32[this.ptr+16>>2]=adjustedPtr;};this.get_adjusted_ptr=function(){return HEAPU32[this.ptr+16>>2]};this.get_exception_ptr=function(){var isPointer=___cxa_is_pointer_type(this.get_type());if(isPointer){return HEAPU32[this.excPtr>>2]}var adjusted=this.get_adjusted_ptr();if(adjusted!==0)return adjusted;return this.excPtr};}function ___cxa_free_exception(ptr){return _free(new ExceptionInfo(ptr).ptr)}function exception_decRef(info){if(info.release_ref()&&!info.get_rethrown()){var destructor=info.get_destructor();if(destructor){(function(a1){return dynCall_ii.apply(null,[destructor,a1])})(info.excPtr);}___cxa_free_exception(info.excPtr);}}function ___cxa_decrement_exception_refcount(ptr){if(!ptr)return;exception_decRef(new ExceptionInfo(ptr));}var exceptionLast=0;function ___cxa_end_catch(){_setThrew(0);var info=exceptionCaught.pop();exception_decRef(info);exceptionLast=0;}function ___resumeException(ptr){if(!exceptionLast){exceptionLast=ptr;}throw ptr}function ___cxa_find_matching_catch_2(){var thrown=exceptionLast;if(!thrown){setTempRet0(0);return 0}var info=new ExceptionInfo(thrown);info.set_adjusted_ptr(thrown);var thrownType=info.get_type();if(!thrownType){setTempRet0(0);return thrown}var typeArray=Array.prototype.slice.call(arguments);for(var i=0;i<typeArray.length;i++){var caughtType=typeArray[i];if(caughtType===0||caughtType===thrownType){break}var adjusted_ptr_addr=info.ptr+16;if(___cxa_can_catch(caughtType,thrownType,adjusted_ptr_addr)){setTempRet0(caughtType);return thrown}}setTempRet0(thrownType);return thrown}function ___cxa_find_matching_catch_3(){var thrown=exceptionLast;if(!thrown){setTempRet0(0);return 0}var info=new ExceptionInfo(thrown);info.set_adjusted_ptr(thrown);var thrownType=info.get_type();if(!thrownType){setTempRet0(0);return thrown}var typeArray=Array.prototype.slice.call(arguments);for(var i=0;i<typeArray.length;i++){var caughtType=typeArray[i];if(caughtType===0||caughtType===thrownType){break}var adjusted_ptr_addr=info.ptr+16;if(___cxa_can_catch(caughtType,thrownType,adjusted_ptr_addr)){setTempRet0(caughtType);return thrown}}setTempRet0(thrownType);return thrown}function ___cxa_find_matching_catch_6(){var thrown=exceptionLast;if(!thrown){setTempRet0(0);return 0}var info=new ExceptionInfo(thrown);info.set_adjusted_ptr(thrown);var thrownType=info.get_type();if(!thrownType){setTempRet0(0);return thrown}var typeArray=Array.prototype.slice.call(arguments);for(var i=0;i<typeArray.length;i++){var caughtType=typeArray[i];if(caughtType===0||caughtType===thrownType){break}var adjusted_ptr_addr=info.ptr+16;if(___cxa_can_catch(caughtType,thrownType,adjusted_ptr_addr)){setTempRet0(caughtType);return thrown}}setTempRet0(thrownType);return thrown}function ___cxa_find_matching_catch_7(){var thrown=exceptionLast;if(!thrown){setTempRet0(0);return 0}var info=new ExceptionInfo(thrown);info.set_adjusted_ptr(thrown);var thrownType=info.get_type();if(!thrownType){setTempRet0(0);return thrown}var typeArray=Array.prototype.slice.call(arguments);for(var i=0;i<typeArray.length;i++){var caughtType=typeArray[i];if(caughtType===0||caughtType===thrownType){break}var adjusted_ptr_addr=info.ptr+16;if(___cxa_can_catch(caughtType,thrownType,adjusted_ptr_addr)){setTempRet0(caughtType);return thrown}}setTempRet0(thrownType);return thrown}function ___cxa_increment_exception_refcount(ptr){if(!ptr)return;exception_addRef(new ExceptionInfo(ptr));}function ___cxa_rethrow(){var info=exceptionCaught.pop();if(!info){abort("no exception to throw");}var ptr=info.excPtr;if(!info.get_rethrown()){exceptionCaught.push(info);info.set_rethrown(true);info.set_caught(false);uncaughtExceptionCount++;}exceptionLast=ptr;throw ptr}function ___cxa_rethrow_primary_exception(ptr){if(!ptr)return;var info=new ExceptionInfo(ptr);exceptionCaught.push(info);info.set_rethrown(true);___cxa_rethrow();}function ___cxa_throw(ptr,type,destructor){var info=new ExceptionInfo(ptr);info.init(type,destructor);exceptionLast=ptr;uncaughtExceptionCount++;throw ptr}function ___cxa_uncaught_exceptions(){return uncaughtExceptionCount}function setErrNo(value){HEAP32[___errno_location()>>2]=value;return value}var PATH={isAbs:path=>path.charAt(0)==="/",splitPath:filename=>{var splitPathRe=/^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;return splitPathRe.exec(filename).slice(1)},normalizeArray:(parts,allowAboveRoot)=>{var up=0;for(var i=parts.length-1;i>=0;i--){var last=parts[i];if(last==="."){parts.splice(i,1);}else if(last===".."){parts.splice(i,1);up++;}else if(up){parts.splice(i,1);up--;}}if(allowAboveRoot){for(;up;up--){parts.unshift("..");}}return parts},normalize:path=>{var isAbsolute=PATH.isAbs(path),trailingSlash=path.substr(-1)==="/";path=PATH.normalizeArray(path.split("/").filter(p=>!!p),!isAbsolute).join("/");if(!path&&!isAbsolute){path=".";}if(path&&trailingSlash){path+="/";}return (isAbsolute?"/":"")+path},dirname:path=>{var result=PATH.splitPath(path),root=result[0],dir=result[1];if(!root&&!dir){return "."}if(dir){dir=dir.substr(0,dir.length-1);}return root+dir},basename:path=>{if(path==="/")return "/";path=PATH.normalize(path);path=path.replace(/\/$/,"");var lastSlash=path.lastIndexOf("/");if(lastSlash===-1)return path;return path.substr(lastSlash+1)},join:function(){var paths=Array.prototype.slice.call(arguments,0);return PATH.normalize(paths.join("/"))},join2:(l,r)=>{return PATH.normalize(l+"/"+r)}};function getRandomDevice(){if(typeof crypto=="object"&&typeof crypto["getRandomValues"]=="function"){var randomBuffer=new Uint8Array(1);return function(){crypto.getRandomValues(randomBuffer);return randomBuffer[0]}}else if(ENVIRONMENT_IS_NODE){try{var crypto_module=require("crypto");return function(){return crypto_module["randomBytes"](1)[0]}}catch(e){}}return function(){abort("randomDevice");}}var PATH_FS={resolve:function(){var resolvedPath="",resolvedAbsolute=false;for(var i=arguments.length-1;i>=-1&&!resolvedAbsolute;i--){var path=i>=0?arguments[i]:FS.cwd();if(typeof path!="string"){throw new TypeError("Arguments to path.resolve must be strings")}else if(!path){return ""}resolvedPath=path+"/"+resolvedPath;resolvedAbsolute=PATH.isAbs(path);}resolvedPath=PATH.normalizeArray(resolvedPath.split("/").filter(p=>!!p),!resolvedAbsolute).join("/");return (resolvedAbsolute?"/":"")+resolvedPath||"."},relative:(from,to)=>{from=PATH_FS.resolve(from).substr(1);to=PATH_FS.resolve(to).substr(1);function trim(arr){var start=0;for(;start<arr.length;start++){if(arr[start]!=="")break}var end=arr.length-1;for(;end>=0;end--){if(arr[end]!=="")break}if(start>end)return [];return arr.slice(start,end-start+1)}var fromParts=trim(from.split("/"));var toParts=trim(to.split("/"));var length=Math.min(fromParts.length,toParts.length);var samePartsLength=length;for(var i=0;i<length;i++){if(fromParts[i]!==toParts[i]){samePartsLength=i;break}}var outputParts=[];for(var i=samePartsLength;i<fromParts.length;i++){outputParts.push("..");}outputParts=outputParts.concat(toParts.slice(samePartsLength));return outputParts.join("/")}};var TTY={ttys:[],init:function(){},shutdown:function(){},register:function(dev,ops){TTY.ttys[dev]={input:[],output:[],ops:ops};FS.registerDevice(dev,TTY.stream_ops);},stream_ops:{open:function(stream){var tty=TTY.ttys[stream.node.rdev];if(!tty){throw new FS.ErrnoError(43)}stream.tty=tty;stream.seekable=false;},close:function(stream){stream.tty.ops.flush(stream.tty);},flush:function(stream){stream.tty.ops.flush(stream.tty);},read:function(stream,buffer,offset,length,pos){if(!stream.tty||!stream.tty.ops.get_char){throw new FS.ErrnoError(60)}var bytesRead=0;for(var i=0;i<length;i++){var result;try{result=stream.tty.ops.get_char(stream.tty);}catch(e){throw new FS.ErrnoError(29)}if(result===undefined&&bytesRead===0){throw new FS.ErrnoError(6)}if(result===null||result===undefined)break;bytesRead++;buffer[offset+i]=result;}if(bytesRead){stream.node.timestamp=Date.now();}return bytesRead},write:function(stream,buffer,offset,length,pos){if(!stream.tty||!stream.tty.ops.put_char){throw new FS.ErrnoError(60)}try{for(var i=0;i<length;i++){stream.tty.ops.put_char(stream.tty,buffer[offset+i]);}}catch(e){throw new FS.ErrnoError(29)}if(length){stream.node.timestamp=Date.now();}return i}},default_tty_ops:{get_char:function(tty){if(!tty.input.length){var result=null;if(ENVIRONMENT_IS_NODE){var BUFSIZE=256;var buf=Buffer.alloc(BUFSIZE);var bytesRead=0;try{bytesRead=fs.readSync(process.stdin.fd,buf,0,BUFSIZE,-1);}catch(e){if(e.toString().includes("EOF"))bytesRead=0;else throw e}if(bytesRead>0){result=buf.slice(0,bytesRead).toString("utf-8");}else {result=null;}}else if(typeof window!="undefined"&&typeof window.prompt=="function"){result=window.prompt("Input: ");if(result!==null){result+="\n";}}else if(typeof readline=="function"){result=readline();if(result!==null){result+="\n";}}if(!result){return null}tty.input=intArrayFromString(result,true);}return tty.input.shift()},put_char:function(tty,val){if(val===null||val===10){out(UTF8ArrayToString(tty.output,0));tty.output=[];}else {if(val!=0)tty.output.push(val);}},flush:function(tty){if(tty.output&&tty.output.length>0){out(UTF8ArrayToString(tty.output,0));tty.output=[];}}},default_tty1_ops:{put_char:function(tty,val){if(val===null||val===10){err(UTF8ArrayToString(tty.output,0));tty.output=[];}else {if(val!=0)tty.output.push(val);}},flush:function(tty){if(tty.output&&tty.output.length>0){err(UTF8ArrayToString(tty.output,0));tty.output=[];}}}};function zeroMemory(address,size){HEAPU8.fill(0,address,address+size);}function alignMemory(size,alignment){return Math.ceil(size/alignment)*alignment}function mmapAlloc(size){size=alignMemory(size,65536);var ptr=_emscripten_builtin_memalign(65536,size);if(!ptr)return 0;zeroMemory(ptr,size);return ptr}var MEMFS={ops_table:null,mount:function(mount){return MEMFS.createNode(null,"/",16384|511,0)},createNode:function(parent,name,mode,dev){if(FS.isBlkdev(mode)||FS.isFIFO(mode)){throw new FS.ErrnoError(63)}if(!MEMFS.ops_table){MEMFS.ops_table={dir:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr,lookup:MEMFS.node_ops.lookup,mknod:MEMFS.node_ops.mknod,rename:MEMFS.node_ops.rename,unlink:MEMFS.node_ops.unlink,rmdir:MEMFS.node_ops.rmdir,readdir:MEMFS.node_ops.readdir,symlink:MEMFS.node_ops.symlink},stream:{llseek:MEMFS.stream_ops.llseek}},file:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr},stream:{llseek:MEMFS.stream_ops.llseek,read:MEMFS.stream_ops.read,write:MEMFS.stream_ops.write,allocate:MEMFS.stream_ops.allocate,mmap:MEMFS.stream_ops.mmap,msync:MEMFS.stream_ops.msync}},link:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr,readlink:MEMFS.node_ops.readlink},stream:{}},chrdev:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr},stream:FS.chrdev_stream_ops}};}var node=FS.createNode(parent,name,mode,dev);if(FS.isDir(node.mode)){node.node_ops=MEMFS.ops_table.dir.node;node.stream_ops=MEMFS.ops_table.dir.stream;node.contents={};}else if(FS.isFile(node.mode)){node.node_ops=MEMFS.ops_table.file.node;node.stream_ops=MEMFS.ops_table.file.stream;node.usedBytes=0;node.contents=null;}else if(FS.isLink(node.mode)){node.node_ops=MEMFS.ops_table.link.node;node.stream_ops=MEMFS.ops_table.link.stream;}else if(FS.isChrdev(node.mode)){node.node_ops=MEMFS.ops_table.chrdev.node;node.stream_ops=MEMFS.ops_table.chrdev.stream;}node.timestamp=Date.now();if(parent){parent.contents[name]=node;parent.timestamp=node.timestamp;}return node},getFileDataAsTypedArray:function(node){if(!node.contents)return new Uint8Array(0);if(node.contents.subarray)return node.contents.subarray(0,node.usedBytes);return new Uint8Array(node.contents)},expandFileStorage:function(node,newCapacity){var prevCapacity=node.contents?node.contents.length:0;if(prevCapacity>=newCapacity)return;var CAPACITY_DOUBLING_MAX=1024*1024;newCapacity=Math.max(newCapacity,prevCapacity*(prevCapacity<CAPACITY_DOUBLING_MAX?2:1.125)>>>0);if(prevCapacity!=0)newCapacity=Math.max(newCapacity,256);var oldContents=node.contents;node.contents=new Uint8Array(newCapacity);if(node.usedBytes>0)node.contents.set(oldContents.subarray(0,node.usedBytes),0);},resizeFileStorage:function(node,newSize){if(node.usedBytes==newSize)return;if(newSize==0){node.contents=null;node.usedBytes=0;}else {var oldContents=node.contents;node.contents=new Uint8Array(newSize);if(oldContents){node.contents.set(oldContents.subarray(0,Math.min(newSize,node.usedBytes)));}node.usedBytes=newSize;}},node_ops:{getattr:function(node){var attr={};attr.dev=FS.isChrdev(node.mode)?node.id:1;attr.ino=node.id;attr.mode=node.mode;attr.nlink=1;attr.uid=0;attr.gid=0;attr.rdev=node.rdev;if(FS.isDir(node.mode)){attr.size=4096;}else if(FS.isFile(node.mode)){attr.size=node.usedBytes;}else if(FS.isLink(node.mode)){attr.size=node.link.length;}else {attr.size=0;}attr.atime=new Date(node.timestamp);attr.mtime=new Date(node.timestamp);attr.ctime=new Date(node.timestamp);attr.blksize=4096;attr.blocks=Math.ceil(attr.size/attr.blksize);return attr},setattr:function(node,attr){if(attr.mode!==undefined){node.mode=attr.mode;}if(attr.timestamp!==undefined){node.timestamp=attr.timestamp;}if(attr.size!==undefined){MEMFS.resizeFileStorage(node,attr.size);}},lookup:function(parent,name){throw FS.genericErrors[44]},mknod:function(parent,name,mode,dev){return MEMFS.createNode(parent,name,mode,dev)},rename:function(old_node,new_dir,new_name){if(FS.isDir(old_node.mode)){var new_node;try{new_node=FS.lookupNode(new_dir,new_name);}catch(e){}if(new_node){for(var i in new_node.contents){throw new FS.ErrnoError(55)}}}delete old_node.parent.contents[old_node.name];old_node.parent.timestamp=Date.now();old_node.name=new_name;new_dir.contents[new_name]=old_node;new_dir.timestamp=old_node.parent.timestamp;old_node.parent=new_dir;},unlink:function(parent,name){delete parent.contents[name];parent.timestamp=Date.now();},rmdir:function(parent,name){var node=FS.lookupNode(parent,name);for(var i in node.contents){throw new FS.ErrnoError(55)}delete parent.contents[name];parent.timestamp=Date.now();},readdir:function(node){var entries=[".",".."];for(var key in node.contents){if(!node.contents.hasOwnProperty(key)){continue}entries.push(key);}return entries},symlink:function(parent,newname,oldpath){var node=MEMFS.createNode(parent,newname,511|40960,0);node.link=oldpath;return node},readlink:function(node){if(!FS.isLink(node.mode)){throw new FS.ErrnoError(28)}return node.link}},stream_ops:{read:function(stream,buffer,offset,length,position){var contents=stream.node.contents;if(position>=stream.node.usedBytes)return 0;var size=Math.min(stream.node.usedBytes-position,length);if(size>8&&contents.subarray){buffer.set(contents.subarray(position,position+size),offset);}else {for(var i=0;i<size;i++)buffer[offset+i]=contents[position+i];}return size},write:function(stream,buffer,offset,length,position,canOwn){if(buffer.buffer===HEAP8.buffer){canOwn=false;}if(!length)return 0;var node=stream.node;node.timestamp=Date.now();if(buffer.subarray&&(!node.contents||node.contents.subarray)){if(canOwn){node.contents=buffer.subarray(offset,offset+length);node.usedBytes=length;return length}else if(node.usedBytes===0&&position===0){node.contents=buffer.slice(offset,offset+length);node.usedBytes=length;return length}else if(position+length<=node.usedBytes){node.contents.set(buffer.subarray(offset,offset+length),position);return length}}MEMFS.expandFileStorage(node,position+length);if(node.contents.subarray&&buffer.subarray){node.contents.set(buffer.subarray(offset,offset+length),position);}else {for(var i=0;i<length;i++){node.contents[position+i]=buffer[offset+i];}}node.usedBytes=Math.max(node.usedBytes,position+length);return length},llseek:function(stream,offset,whence){var position=offset;if(whence===1){position+=stream.position;}else if(whence===2){if(FS.isFile(stream.node.mode)){position+=stream.node.usedBytes;}}if(position<0){throw new FS.ErrnoError(28)}return position},allocate:function(stream,offset,length){MEMFS.expandFileStorage(stream.node,offset+length);stream.node.usedBytes=Math.max(stream.node.usedBytes,offset+length);},mmap:function(stream,address,length,position,prot,flags){if(address!==0){throw new FS.ErrnoError(28)}if(!FS.isFile(stream.node.mode)){throw new FS.ErrnoError(43)}var ptr;var allocated;var contents=stream.node.contents;if(!(flags&2)&&contents.buffer===buffer){allocated=false;ptr=contents.byteOffset;}else {if(position>0||position+length<contents.length){if(contents.subarray){contents=contents.subarray(position,position+length);}else {contents=Array.prototype.slice.call(contents,position,position+length);}}allocated=true;ptr=mmapAlloc(length);if(!ptr){throw new FS.ErrnoError(48)}HEAP8.set(contents,ptr);}return {ptr:ptr,allocated:allocated}},msync:function(stream,buffer,offset,length,mmapFlags){if(!FS.isFile(stream.node.mode)){throw new FS.ErrnoError(43)}if(mmapFlags&2){return 0}MEMFS.stream_ops.write(stream,buffer,0,length,offset,false);return 0}}};function asyncLoad(url,onload,onerror,noRunDep){var dep=!noRunDep?getUniqueRunDependency("al "+url):"";readAsync(url,function(arrayBuffer){assert(arrayBuffer,'Loading data file "'+url+'" failed (no arrayBuffer).');onload(new Uint8Array(arrayBuffer));if(dep)removeRunDependency();},function(event){if(onerror){onerror();}else {throw 'Loading data file "'+url+'" failed.'}});if(dep)addRunDependency();}var FS={root:null,mounts:[],devices:{},streams:[],nextInode:1,nameTable:null,currentPath:"/",initialized:false,ignorePermissions:true,ErrnoError:null,genericErrors:{},filesystems:null,syncFSRequests:0,lookupPath:(path,opts={})=>{path=PATH_FS.resolve(FS.cwd(),path);if(!path)return {path:"",node:null};var defaults={follow_mount:true,recurse_count:0};opts=Object.assign(defaults,opts);if(opts.recurse_count>8){throw new FS.ErrnoError(32)}var parts=PATH.normalizeArray(path.split("/").filter(p=>!!p),false);var current=FS.root;var current_path="/";for(var i=0;i<parts.length;i++){var islast=i===parts.length-1;if(islast&&opts.parent){break}current=FS.lookupNode(current,parts[i]);current_path=PATH.join2(current_path,parts[i]);if(FS.isMountpoint(current)){if(!islast||islast&&opts.follow_mount){current=current.mounted.root;}}if(!islast||opts.follow){var count=0;while(FS.isLink(current.mode)){var link=FS.readlink(current_path);current_path=PATH_FS.resolve(PATH.dirname(current_path),link);var lookup=FS.lookupPath(current_path,{recurse_count:opts.recurse_count+1});current=lookup.node;if(count++>40){throw new FS.ErrnoError(32)}}}}return {path:current_path,node:current}},getPath:node=>{var path;while(true){if(FS.isRoot(node)){var mount=node.mount.mountpoint;if(!path)return mount;return mount[mount.length-1]!=="/"?mount+"/"+path:mount+path}path=path?node.name+"/"+path:node.name;node=node.parent;}},hashName:(parentid,name)=>{var hash=0;for(var i=0;i<name.length;i++){hash=(hash<<5)-hash+name.charCodeAt(i)|0;}return (parentid+hash>>>0)%FS.nameTable.length},hashAddNode:node=>{var hash=FS.hashName(node.parent.id,node.name);node.name_next=FS.nameTable[hash];FS.nameTable[hash]=node;},hashRemoveNode:node=>{var hash=FS.hashName(node.parent.id,node.name);if(FS.nameTable[hash]===node){FS.nameTable[hash]=node.name_next;}else {var current=FS.nameTable[hash];while(current){if(current.name_next===node){current.name_next=node.name_next;break}current=current.name_next;}}},lookupNode:(parent,name)=>{var errCode=FS.mayLookup(parent);if(errCode){throw new FS.ErrnoError(errCode,parent)}var hash=FS.hashName(parent.id,name);for(var node=FS.nameTable[hash];node;node=node.name_next){var nodeName=node.name;if(node.parent.id===parent.id&&nodeName===name){return node}}return FS.lookup(parent,name)},createNode:(parent,name,mode,rdev)=>{var node=new FS.FSNode(parent,name,mode,rdev);FS.hashAddNode(node);return node},destroyNode:node=>{FS.hashRemoveNode(node);},isRoot:node=>{return node===node.parent},isMountpoint:node=>{return !!node.mounted},isFile:mode=>{return (mode&61440)===32768},isDir:mode=>{return (mode&61440)===16384},isLink:mode=>{return (mode&61440)===40960},isChrdev:mode=>{return (mode&61440)===8192},isBlkdev:mode=>{return (mode&61440)===24576},isFIFO:mode=>{return (mode&61440)===4096},isSocket:mode=>{return (mode&49152)===49152},flagModes:{"r":0,"r+":2,"w":577,"w+":578,"a":1089,"a+":1090},modeStringToFlags:str=>{var flags=FS.flagModes[str];if(typeof flags=="undefined"){throw new Error("Unknown file open mode: "+str)}return flags},flagsToPermissionString:flag=>{var perms=["r","w","rw"][flag&3];if(flag&512){perms+="w";}return perms},nodePermissions:(node,perms)=>{if(FS.ignorePermissions){return 0}if(perms.includes("r")&&!(node.mode&292)){return 2}else if(perms.includes("w")&&!(node.mode&146)){return 2}else if(perms.includes("x")&&!(node.mode&73)){return 2}return 0},mayLookup:dir=>{var errCode=FS.nodePermissions(dir,"x");if(errCode)return errCode;if(!dir.node_ops.lookup)return 2;return 0},mayCreate:(dir,name)=>{try{var node=FS.lookupNode(dir,name);return 20}catch(e){}return FS.nodePermissions(dir,"wx")},mayDelete:(dir,name,isdir)=>{var node;try{node=FS.lookupNode(dir,name);}catch(e){return e.errno}var errCode=FS.nodePermissions(dir,"wx");if(errCode){return errCode}if(isdir){if(!FS.isDir(node.mode)){return 54}if(FS.isRoot(node)||FS.getPath(node)===FS.cwd()){return 10}}else {if(FS.isDir(node.mode)){return 31}}return 0},mayOpen:(node,flags)=>{if(!node){return 44}if(FS.isLink(node.mode)){return 32}else if(FS.isDir(node.mode)){if(FS.flagsToPermissionString(flags)!=="r"||flags&512){return 31}}return FS.nodePermissions(node,FS.flagsToPermissionString(flags))},MAX_OPEN_FDS:4096,nextfd:(fd_start=0,fd_end=FS.MAX_OPEN_FDS)=>{for(var fd=fd_start;fd<=fd_end;fd++){if(!FS.streams[fd]){return fd}}throw new FS.ErrnoError(33)},getStream:fd=>FS.streams[fd],createStream:(stream,fd_start,fd_end)=>{if(!FS.FSStream){FS.FSStream=function(){this.shared={};};FS.FSStream.prototype={object:{get:function(){return this.node},set:function(val){this.node=val;}},isRead:{get:function(){return (this.flags&2097155)!==1}},isWrite:{get:function(){return (this.flags&2097155)!==0}},isAppend:{get:function(){return this.flags&1024}},flags:{get:function(){return this.shared.flags},set:function(val){this.shared.flags=val;}},position:{get function(){return this.shared.position},set:function(val){this.shared.position=val;}}};}stream=Object.assign(new FS.FSStream,stream);var fd=FS.nextfd(fd_start,fd_end);stream.fd=fd;FS.streams[fd]=stream;return stream},closeStream:fd=>{FS.streams[fd]=null;},chrdev_stream_ops:{open:stream=>{var device=FS.getDevice(stream.node.rdev);stream.stream_ops=device.stream_ops;if(stream.stream_ops.open){stream.stream_ops.open(stream);}},llseek:()=>{throw new FS.ErrnoError(70)}},major:dev=>dev>>8,minor:dev=>dev&255,makedev:(ma,mi)=>ma<<8|mi,registerDevice:(dev,ops)=>{FS.devices[dev]={stream_ops:ops};},getDevice:dev=>FS.devices[dev],getMounts:mount=>{var mounts=[];var check=[mount];while(check.length){var m=check.pop();mounts.push(m);check.push.apply(check,m.mounts);}return mounts},syncfs:(populate,callback)=>{if(typeof populate=="function"){callback=populate;populate=false;}FS.syncFSRequests++;if(FS.syncFSRequests>1){err("warning: "+FS.syncFSRequests+" FS.syncfs operations in flight at once, probably just doing extra work");}var mounts=FS.getMounts(FS.root.mount);var completed=0;function doCallback(errCode){FS.syncFSRequests--;return callback(errCode)}function done(errCode){if(errCode){if(!done.errored){done.errored=true;return doCallback(errCode)}return}if(++completed>=mounts.length){doCallback(null);}}mounts.forEach(mount=>{if(!mount.type.syncfs){return done(null)}mount.type.syncfs(mount,populate,done);});},mount:(type,opts,mountpoint)=>{var root=mountpoint==="/";var pseudo=!mountpoint;var node;if(root&&FS.root){throw new FS.ErrnoError(10)}else if(!root&&!pseudo){var lookup=FS.lookupPath(mountpoint,{follow_mount:false});mountpoint=lookup.path;node=lookup.node;if(FS.isMountpoint(node)){throw new FS.ErrnoError(10)}if(!FS.isDir(node.mode)){throw new FS.ErrnoError(54)}}var mount={type:type,opts:opts,mountpoint:mountpoint,mounts:[]};var mountRoot=type.mount(mount);mountRoot.mount=mount;mount.root=mountRoot;if(root){FS.root=mountRoot;}else if(node){node.mounted=mount;if(node.mount){node.mount.mounts.push(mount);}}return mountRoot},unmount:mountpoint=>{var lookup=FS.lookupPath(mountpoint,{follow_mount:false});if(!FS.isMountpoint(lookup.node)){throw new FS.ErrnoError(28)}var node=lookup.node;var mount=node.mounted;var mounts=FS.getMounts(mount);Object.keys(FS.nameTable).forEach(hash=>{var current=FS.nameTable[hash];while(current){var next=current.name_next;if(mounts.includes(current.mount)){FS.destroyNode(current);}current=next;}});node.mounted=null;var idx=node.mount.mounts.indexOf(mount);node.mount.mounts.splice(idx,1);},lookup:(parent,name)=>{return parent.node_ops.lookup(parent,name)},mknod:(path,mode,dev)=>{var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;var name=PATH.basename(path);if(!name||name==="."||name===".."){throw new FS.ErrnoError(28)}var errCode=FS.mayCreate(parent,name);if(errCode){throw new FS.ErrnoError(errCode)}if(!parent.node_ops.mknod){throw new FS.ErrnoError(63)}return parent.node_ops.mknod(parent,name,mode,dev)},create:(path,mode)=>{mode=mode!==undefined?mode:438;mode&=4095;mode|=32768;return FS.mknod(path,mode,0)},mkdir:(path,mode)=>{mode=mode!==undefined?mode:511;mode&=511|512;mode|=16384;return FS.mknod(path,mode,0)},mkdirTree:(path,mode)=>{var dirs=path.split("/");var d="";for(var i=0;i<dirs.length;++i){if(!dirs[i])continue;d+="/"+dirs[i];try{FS.mkdir(d,mode);}catch(e){if(e.errno!=20)throw e}}},mkdev:(path,mode,dev)=>{if(typeof dev=="undefined"){dev=mode;mode=438;}mode|=8192;return FS.mknod(path,mode,dev)},symlink:(oldpath,newpath)=>{if(!PATH_FS.resolve(oldpath)){throw new FS.ErrnoError(44)}var lookup=FS.lookupPath(newpath,{parent:true});var parent=lookup.node;if(!parent){throw new FS.ErrnoError(44)}var newname=PATH.basename(newpath);var errCode=FS.mayCreate(parent,newname);if(errCode){throw new FS.ErrnoError(errCode)}if(!parent.node_ops.symlink){throw new FS.ErrnoError(63)}return parent.node_ops.symlink(parent,newname,oldpath)},rename:(old_path,new_path)=>{var old_dirname=PATH.dirname(old_path);var new_dirname=PATH.dirname(new_path);var old_name=PATH.basename(old_path);var new_name=PATH.basename(new_path);var lookup,old_dir,new_dir;lookup=FS.lookupPath(old_path,{parent:true});old_dir=lookup.node;lookup=FS.lookupPath(new_path,{parent:true});new_dir=lookup.node;if(!old_dir||!new_dir)throw new FS.ErrnoError(44);if(old_dir.mount!==new_dir.mount){throw new FS.ErrnoError(75)}var old_node=FS.lookupNode(old_dir,old_name);var relative=PATH_FS.relative(old_path,new_dirname);if(relative.charAt(0)!=="."){throw new FS.ErrnoError(28)}relative=PATH_FS.relative(new_path,old_dirname);if(relative.charAt(0)!=="."){throw new FS.ErrnoError(55)}var new_node;try{new_node=FS.lookupNode(new_dir,new_name);}catch(e){}if(old_node===new_node){return}var isdir=FS.isDir(old_node.mode);var errCode=FS.mayDelete(old_dir,old_name,isdir);if(errCode){throw new FS.ErrnoError(errCode)}errCode=new_node?FS.mayDelete(new_dir,new_name,isdir):FS.mayCreate(new_dir,new_name);if(errCode){throw new FS.ErrnoError(errCode)}if(!old_dir.node_ops.rename){throw new FS.ErrnoError(63)}if(FS.isMountpoint(old_node)||new_node&&FS.isMountpoint(new_node)){throw new FS.ErrnoError(10)}if(new_dir!==old_dir){errCode=FS.nodePermissions(old_dir,"w");if(errCode){throw new FS.ErrnoError(errCode)}}FS.hashRemoveNode(old_node);try{old_dir.node_ops.rename(old_node,new_dir,new_name);}catch(e){throw e}finally{FS.hashAddNode(old_node);}},rmdir:path=>{var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;var name=PATH.basename(path);var node=FS.lookupNode(parent,name);var errCode=FS.mayDelete(parent,name,true);if(errCode){throw new FS.ErrnoError(errCode)}if(!parent.node_ops.rmdir){throw new FS.ErrnoError(63)}if(FS.isMountpoint(node)){throw new FS.ErrnoError(10)}parent.node_ops.rmdir(parent,name);FS.destroyNode(node);},readdir:path=>{var lookup=FS.lookupPath(path,{follow:true});var node=lookup.node;if(!node.node_ops.readdir){throw new FS.ErrnoError(54)}return node.node_ops.readdir(node)},unlink:path=>{var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;if(!parent){throw new FS.ErrnoError(44)}var name=PATH.basename(path);var node=FS.lookupNode(parent,name);var errCode=FS.mayDelete(parent,name,false);if(errCode){throw new FS.ErrnoError(errCode)}if(!parent.node_ops.unlink){throw new FS.ErrnoError(63)}if(FS.isMountpoint(node)){throw new FS.ErrnoError(10)}parent.node_ops.unlink(parent,name);FS.destroyNode(node);},readlink:path=>{var lookup=FS.lookupPath(path);var link=lookup.node;if(!link){throw new FS.ErrnoError(44)}if(!link.node_ops.readlink){throw new FS.ErrnoError(28)}return PATH_FS.resolve(FS.getPath(link.parent),link.node_ops.readlink(link))},stat:(path,dontFollow)=>{var lookup=FS.lookupPath(path,{follow:!dontFollow});var node=lookup.node;if(!node){throw new FS.ErrnoError(44)}if(!node.node_ops.getattr){throw new FS.ErrnoError(63)}return node.node_ops.getattr(node)},lstat:path=>{return FS.stat(path,true)},chmod:(path,mode,dontFollow)=>{var node;if(typeof path=="string"){var lookup=FS.lookupPath(path,{follow:!dontFollow});node=lookup.node;}else {node=path;}if(!node.node_ops.setattr){throw new FS.ErrnoError(63)}node.node_ops.setattr(node,{mode:mode&4095|node.mode&~4095,timestamp:Date.now()});},lchmod:(path,mode)=>{FS.chmod(path,mode,true);},fchmod:(fd,mode)=>{var stream=FS.getStream(fd);if(!stream){throw new FS.ErrnoError(8)}FS.chmod(stream.node,mode);},chown:(path,uid,gid,dontFollow)=>{var node;if(typeof path=="string"){var lookup=FS.lookupPath(path,{follow:!dontFollow});node=lookup.node;}else {node=path;}if(!node.node_ops.setattr){throw new FS.ErrnoError(63)}node.node_ops.setattr(node,{timestamp:Date.now()});},lchown:(path,uid,gid)=>{FS.chown(path,uid,gid,true);},fchown:(fd,uid,gid)=>{var stream=FS.getStream(fd);if(!stream){throw new FS.ErrnoError(8)}FS.chown(stream.node,uid,gid);},truncate:(path,len)=>{if(len<0){throw new FS.ErrnoError(28)}var node;if(typeof path=="string"){var lookup=FS.lookupPath(path,{follow:true});node=lookup.node;}else {node=path;}if(!node.node_ops.setattr){throw new FS.ErrnoError(63)}if(FS.isDir(node.mode)){throw new FS.ErrnoError(31)}if(!FS.isFile(node.mode)){throw new FS.ErrnoError(28)}var errCode=FS.nodePermissions(node,"w");if(errCode){throw new FS.ErrnoError(errCode)}node.node_ops.setattr(node,{size:len,timestamp:Date.now()});},ftruncate:(fd,len)=>{var stream=FS.getStream(fd);if(!stream){throw new FS.ErrnoError(8)}if((stream.flags&2097155)===0){throw new FS.ErrnoError(28)}FS.truncate(stream.node,len);},utime:(path,atime,mtime)=>{var lookup=FS.lookupPath(path,{follow:true});var node=lookup.node;node.node_ops.setattr(node,{timestamp:Math.max(atime,mtime)});},open:(path,flags,mode)=>{if(path===""){throw new FS.ErrnoError(44)}flags=typeof flags=="string"?FS.modeStringToFlags(flags):flags;mode=typeof mode=="undefined"?438:mode;if(flags&64){mode=mode&4095|32768;}else {mode=0;}var node;if(typeof path=="object"){node=path;}else {path=PATH.normalize(path);try{var lookup=FS.lookupPath(path,{follow:!(flags&131072)});node=lookup.node;}catch(e){}}var created=false;if(flags&64){if(node){if(flags&128){throw new FS.ErrnoError(20)}}else {node=FS.mknod(path,mode,0);created=true;}}if(!node){throw new FS.ErrnoError(44)}if(FS.isChrdev(node.mode)){flags&=~512;}if(flags&65536&&!FS.isDir(node.mode)){throw new FS.ErrnoError(54)}if(!created){var errCode=FS.mayOpen(node,flags);if(errCode){throw new FS.ErrnoError(errCode)}}if(flags&512&&!created){FS.truncate(node,0);}flags&=~(128|512|131072);var stream=FS.createStream({node:node,path:FS.getPath(node),flags:flags,seekable:true,position:0,stream_ops:node.stream_ops,ungotten:[],error:false});if(stream.stream_ops.open){stream.stream_ops.open(stream);}if(Module["logReadFiles"]&&!(flags&1)){if(!FS.readFiles)FS.readFiles={};if(!(path in FS.readFiles)){FS.readFiles[path]=1;}}return stream},close:stream=>{if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if(stream.getdents)stream.getdents=null;try{if(stream.stream_ops.close){stream.stream_ops.close(stream);}}catch(e){throw e}finally{FS.closeStream(stream.fd);}stream.fd=null;},isClosed:stream=>{return stream.fd===null},llseek:(stream,offset,whence)=>{if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if(!stream.seekable||!stream.stream_ops.llseek){throw new FS.ErrnoError(70)}if(whence!=0&&whence!=1&&whence!=2){throw new FS.ErrnoError(28)}stream.position=stream.stream_ops.llseek(stream,offset,whence);stream.ungotten=[];return stream.position},read:(stream,buffer,offset,length,position)=>{if(length<0||position<0){throw new FS.ErrnoError(28)}if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if((stream.flags&2097155)===1){throw new FS.ErrnoError(8)}if(FS.isDir(stream.node.mode)){throw new FS.ErrnoError(31)}if(!stream.stream_ops.read){throw new FS.ErrnoError(28)}var seeking=typeof position!="undefined";if(!seeking){position=stream.position;}else if(!stream.seekable){throw new FS.ErrnoError(70)}var bytesRead=stream.stream_ops.read(stream,buffer,offset,length,position);if(!seeking)stream.position+=bytesRead;return bytesRead},write:(stream,buffer,offset,length,position,canOwn)=>{if(length<0||position<0){throw new FS.ErrnoError(28)}if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if((stream.flags&2097155)===0){throw new FS.ErrnoError(8)}if(FS.isDir(stream.node.mode)){throw new FS.ErrnoError(31)}if(!stream.stream_ops.write){throw new FS.ErrnoError(28)}if(stream.seekable&&stream.flags&1024){FS.llseek(stream,0,2);}var seeking=typeof position!="undefined";if(!seeking){position=stream.position;}else if(!stream.seekable){throw new FS.ErrnoError(70)}var bytesWritten=stream.stream_ops.write(stream,buffer,offset,length,position,canOwn);if(!seeking)stream.position+=bytesWritten;return bytesWritten},allocate:(stream,offset,length)=>{if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if(offset<0||length<=0){throw new FS.ErrnoError(28)}if((stream.flags&2097155)===0){throw new FS.ErrnoError(8)}if(!FS.isFile(stream.node.mode)&&!FS.isDir(stream.node.mode)){throw new FS.ErrnoError(43)}if(!stream.stream_ops.allocate){throw new FS.ErrnoError(138)}stream.stream_ops.allocate(stream,offset,length);},mmap:(stream,address,length,position,prot,flags)=>{if((prot&2)!==0&&(flags&2)===0&&(stream.flags&2097155)!==2){throw new FS.ErrnoError(2)}if((stream.flags&2097155)===1){throw new FS.ErrnoError(2)}if(!stream.stream_ops.mmap){throw new FS.ErrnoError(43)}return stream.stream_ops.mmap(stream,address,length,position,prot,flags)},msync:(stream,buffer,offset,length,mmapFlags)=>{if(!stream||!stream.stream_ops.msync){return 0}return stream.stream_ops.msync(stream,buffer,offset,length,mmapFlags)},munmap:stream=>0,ioctl:(stream,cmd,arg)=>{if(!stream.stream_ops.ioctl){throw new FS.ErrnoError(59)}return stream.stream_ops.ioctl(stream,cmd,arg)},readFile:(path,opts={})=>{opts.flags=opts.flags||0;opts.encoding=opts.encoding||"binary";if(opts.encoding!=="utf8"&&opts.encoding!=="binary"){throw new Error('Invalid encoding type "'+opts.encoding+'"')}var ret;var stream=FS.open(path,opts.flags);var stat=FS.stat(path);var length=stat.size;var buf=new Uint8Array(length);FS.read(stream,buf,0,length,0);if(opts.encoding==="utf8"){ret=UTF8ArrayToString(buf,0);}else if(opts.encoding==="binary"){ret=buf;}FS.close(stream);return ret},writeFile:(path,data,opts={})=>{opts.flags=opts.flags||577;var stream=FS.open(path,opts.flags,opts.mode);if(typeof data=="string"){var buf=new Uint8Array(lengthBytesUTF8(data)+1);var actualNumBytes=stringToUTF8Array(data,buf,0,buf.length);FS.write(stream,buf,0,actualNumBytes,undefined,opts.canOwn);}else if(ArrayBuffer.isView(data)){FS.write(stream,data,0,data.byteLength,undefined,opts.canOwn);}else {throw new Error("Unsupported data type")}FS.close(stream);},cwd:()=>FS.currentPath,chdir:path=>{var lookup=FS.lookupPath(path,{follow:true});if(lookup.node===null){throw new FS.ErrnoError(44)}if(!FS.isDir(lookup.node.mode)){throw new FS.ErrnoError(54)}var errCode=FS.nodePermissions(lookup.node,"x");if(errCode){throw new FS.ErrnoError(errCode)}FS.currentPath=lookup.path;},createDefaultDirectories:()=>{FS.mkdir("/tmp");FS.mkdir("/home");FS.mkdir("/home/web_user");},createDefaultDevices:()=>{FS.mkdir("/dev");FS.registerDevice(FS.makedev(1,3),{read:()=>0,write:(stream,buffer,offset,length,pos)=>length});FS.mkdev("/dev/null",FS.makedev(1,3));TTY.register(FS.makedev(5,0),TTY.default_tty_ops);TTY.register(FS.makedev(6,0),TTY.default_tty1_ops);FS.mkdev("/dev/tty",FS.makedev(5,0));FS.mkdev("/dev/tty1",FS.makedev(6,0));var random_device=getRandomDevice();FS.createDevice("/dev","random",random_device);FS.createDevice("/dev","urandom",random_device);FS.mkdir("/dev/shm");FS.mkdir("/dev/shm/tmp");},createSpecialDirectories:()=>{FS.mkdir("/proc");var proc_self=FS.mkdir("/proc/self");FS.mkdir("/proc/self/fd");FS.mount({mount:()=>{var node=FS.createNode(proc_self,"fd",16384|511,73);node.node_ops={lookup:(parent,name)=>{var fd=+name;var stream=FS.getStream(fd);if(!stream)throw new FS.ErrnoError(8);var ret={parent:null,mount:{mountpoint:"fake"},node_ops:{readlink:()=>stream.path}};ret.parent=ret;return ret}};return node}},{},"/proc/self/fd");},createStandardStreams:()=>{if(Module["stdin"]){FS.createDevice("/dev","stdin",Module["stdin"]);}else {FS.symlink("/dev/tty","/dev/stdin");}if(Module["stdout"]){FS.createDevice("/dev","stdout",null,Module["stdout"]);}else {FS.symlink("/dev/tty","/dev/stdout");}if(Module["stderr"]){FS.createDevice("/dev","stderr",null,Module["stderr"]);}else {FS.symlink("/dev/tty1","/dev/stderr");}FS.open("/dev/stdin",0);FS.open("/dev/stdout",1);FS.open("/dev/stderr",1);},ensureErrnoError:()=>{if(FS.ErrnoError)return;FS.ErrnoError=function ErrnoError(errno,node){this.node=node;this.setErrno=function(errno){this.errno=errno;};this.setErrno(errno);this.message="FS error";};FS.ErrnoError.prototype=new Error;FS.ErrnoError.prototype.constructor=FS.ErrnoError;[44].forEach(code=>{FS.genericErrors[code]=new FS.ErrnoError(code);FS.genericErrors[code].stack="<generic error, no stack>";});},staticInit:()=>{FS.ensureErrnoError();FS.nameTable=new Array(4096);FS.mount(MEMFS,{},"/");FS.createDefaultDirectories();FS.createDefaultDevices();FS.createSpecialDirectories();FS.filesystems={"MEMFS":MEMFS};},init:(input,output,error)=>{FS.init.initialized=true;FS.ensureErrnoError();Module["stdin"]=input||Module["stdin"];Module["stdout"]=output||Module["stdout"];Module["stderr"]=error||Module["stderr"];FS.createStandardStreams();},quit:()=>{FS.init.initialized=false;for(var i=0;i<FS.streams.length;i++){var stream=FS.streams[i];if(!stream){continue}FS.close(stream);}},getMode:(canRead,canWrite)=>{var mode=0;if(canRead)mode|=292|73;if(canWrite)mode|=146;return mode},findObject:(path,dontResolveLastLink)=>{var ret=FS.analyzePath(path,dontResolveLastLink);if(ret.exists){return ret.object}else {return null}},analyzePath:(path,dontResolveLastLink)=>{try{var lookup=FS.lookupPath(path,{follow:!dontResolveLastLink});path=lookup.path;}catch(e){}var ret={isRoot:false,exists:false,error:0,name:null,path:null,object:null,parentExists:false,parentPath:null,parentObject:null};try{var lookup=FS.lookupPath(path,{parent:true});ret.parentExists=true;ret.parentPath=lookup.path;ret.parentObject=lookup.node;ret.name=PATH.basename(path);lookup=FS.lookupPath(path,{follow:!dontResolveLastLink});ret.exists=true;ret.path=lookup.path;ret.object=lookup.node;ret.name=lookup.node.name;ret.isRoot=lookup.path==="/";}catch(e){ret.error=e.errno;}return ret},createPath:(parent,path,canRead,canWrite)=>{parent=typeof parent=="string"?parent:FS.getPath(parent);var parts=path.split("/").reverse();while(parts.length){var part=parts.pop();if(!part)continue;var current=PATH.join2(parent,part);try{FS.mkdir(current);}catch(e){}parent=current;}return current},createFile:(parent,name,properties,canRead,canWrite)=>{var path=PATH.join2(typeof parent=="string"?parent:FS.getPath(parent),name);var mode=FS.getMode(canRead,canWrite);return FS.create(path,mode)},createDataFile:(parent,name,data,canRead,canWrite,canOwn)=>{var path=name;if(parent){parent=typeof parent=="string"?parent:FS.getPath(parent);path=name?PATH.join2(parent,name):parent;}var mode=FS.getMode(canRead,canWrite);var node=FS.create(path,mode);if(data){if(typeof data=="string"){var arr=new Array(data.length);for(var i=0,len=data.length;i<len;++i)arr[i]=data.charCodeAt(i);data=arr;}FS.chmod(node,mode|146);var stream=FS.open(node,577);FS.write(stream,data,0,data.length,0,canOwn);FS.close(stream);FS.chmod(node,mode);}return node},createDevice:(parent,name,input,output)=>{var path=PATH.join2(typeof parent=="string"?parent:FS.getPath(parent),name);var mode=FS.getMode(!!input,!!output);if(!FS.createDevice.major)FS.createDevice.major=64;var dev=FS.makedev(FS.createDevice.major++,0);FS.registerDevice(dev,{open:stream=>{stream.seekable=false;},close:stream=>{if(output&&output.buffer&&output.buffer.length){output(10);}},read:(stream,buffer,offset,length,pos)=>{var bytesRead=0;for(var i=0;i<length;i++){var result;try{result=input();}catch(e){throw new FS.ErrnoError(29)}if(result===undefined&&bytesRead===0){throw new FS.ErrnoError(6)}if(result===null||result===undefined)break;bytesRead++;buffer[offset+i]=result;}if(bytesRead){stream.node.timestamp=Date.now();}return bytesRead},write:(stream,buffer,offset,length,pos)=>{for(var i=0;i<length;i++){try{output(buffer[offset+i]);}catch(e){throw new FS.ErrnoError(29)}}if(length){stream.node.timestamp=Date.now();}return i}});return FS.mkdev(path,mode,dev)},forceLoadFile:obj=>{if(obj.isDevice||obj.isFolder||obj.link||obj.contents)return true;if(typeof XMLHttpRequest!="undefined"){throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.")}else if(read_){try{obj.contents=intArrayFromString(read_(obj.url),true);obj.usedBytes=obj.contents.length;}catch(e){throw new FS.ErrnoError(29)}}else {throw new Error("Cannot load without read() or XMLHttpRequest.")}},createLazyFile:(parent,name,url,canRead,canWrite)=>{function LazyUint8Array(){this.lengthKnown=false;this.chunks=[];}LazyUint8Array.prototype.get=function LazyUint8Array_get(idx){if(idx>this.length-1||idx<0){return undefined}var chunkOffset=idx%this.chunkSize;var chunkNum=idx/this.chunkSize|0;return this.getter(chunkNum)[chunkOffset]};LazyUint8Array.prototype.setDataGetter=function LazyUint8Array_setDataGetter(getter){this.getter=getter;};LazyUint8Array.prototype.cacheLength=function LazyUint8Array_cacheLength(){var xhr=new XMLHttpRequest;xhr.open("HEAD",url,false);xhr.send(null);if(!(xhr.status>=200&&xhr.status<300||xhr.status===304))throw new Error("Couldn't load "+url+". Status: "+xhr.status);var datalength=Number(xhr.getResponseHeader("Content-length"));var header;var hasByteServing=(header=xhr.getResponseHeader("Accept-Ranges"))&&header==="bytes";var usesGzip=(header=xhr.getResponseHeader("Content-Encoding"))&&header==="gzip";var chunkSize=1024*1024;if(!hasByteServing)chunkSize=datalength;var doXHR=(from,to)=>{if(from>to)throw new Error("invalid range ("+from+", "+to+") or no bytes requested!");if(to>datalength-1)throw new Error("only "+datalength+" bytes available! programmer error!");var xhr=new XMLHttpRequest;xhr.open("GET",url,false);if(datalength!==chunkSize)xhr.setRequestHeader("Range","bytes="+from+"-"+to);xhr.responseType="arraybuffer";if(xhr.overrideMimeType){xhr.overrideMimeType("text/plain; charset=x-user-defined");}xhr.send(null);if(!(xhr.status>=200&&xhr.status<300||xhr.status===304))throw new Error("Couldn't load "+url+". Status: "+xhr.status);if(xhr.response!==undefined){return new Uint8Array(xhr.response||[])}else {return intArrayFromString(xhr.responseText||"",true)}};var lazyArray=this;lazyArray.setDataGetter(chunkNum=>{var start=chunkNum*chunkSize;var end=(chunkNum+1)*chunkSize-1;end=Math.min(end,datalength-1);if(typeof lazyArray.chunks[chunkNum]=="undefined"){lazyArray.chunks[chunkNum]=doXHR(start,end);}if(typeof lazyArray.chunks[chunkNum]=="undefined")throw new Error("doXHR failed!");return lazyArray.chunks[chunkNum]});if(usesGzip||!datalength){chunkSize=datalength=1;datalength=this.getter(0).length;chunkSize=datalength;out("LazyFiles on gzip forces download of the whole file when length is accessed");}this._length=datalength;this._chunkSize=chunkSize;this.lengthKnown=true;};if(typeof XMLHttpRequest!="undefined"){if(!ENVIRONMENT_IS_WORKER)throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";var lazyArray=new LazyUint8Array;Object.defineProperties(lazyArray,{length:{get:function(){if(!this.lengthKnown){this.cacheLength();}return this._length}},chunkSize:{get:function(){if(!this.lengthKnown){this.cacheLength();}return this._chunkSize}}});var properties={isDevice:false,contents:lazyArray};}else {var properties={isDevice:false,url:url};}var node=FS.createFile(parent,name,properties,canRead,canWrite);if(properties.contents){node.contents=properties.contents;}else if(properties.url){node.contents=null;node.url=properties.url;}Object.defineProperties(node,{usedBytes:{get:function(){return this.contents.length}}});var stream_ops={};var keys=Object.keys(node.stream_ops);keys.forEach(key=>{var fn=node.stream_ops[key];stream_ops[key]=function forceLoadLazyFile(){FS.forceLoadFile(node);return fn.apply(null,arguments)};});stream_ops.read=((stream,buffer,offset,length,position)=>{FS.forceLoadFile(node);var contents=stream.node.contents;if(position>=contents.length)return 0;var size=Math.min(contents.length-position,length);if(contents.slice){for(var i=0;i<size;i++){buffer[offset+i]=contents[position+i];}}else {for(var i=0;i<size;i++){buffer[offset+i]=contents.get(position+i);}}return size});node.stream_ops=stream_ops;return node},createPreloadedFile:(parent,name,url,canRead,canWrite,onload,onerror,dontCreateFile,canOwn,preFinish)=>{var fullname=name?PATH_FS.resolve(PATH.join2(parent,name)):parent;function processData(byteArray){function finish(byteArray){if(preFinish)preFinish();if(!dontCreateFile){FS.createDataFile(parent,name,byteArray,canRead,canWrite,canOwn);}if(onload)onload();removeRunDependency();}if(Browser.handledByPreloadPlugin(byteArray,fullname,finish,()=>{if(onerror)onerror();removeRunDependency();})){return}finish(byteArray);}addRunDependency();if(typeof url=="string"){asyncLoad(url,byteArray=>processData(byteArray),onerror);}else {processData(url);}},indexedDB:()=>{return window.indexedDB||window.mozIndexedDB||window.webkitIndexedDB||window.msIndexedDB},DB_NAME:()=>{return "EM_FS_"+window.location.pathname},DB_VERSION:20,DB_STORE_NAME:"FILE_DATA",saveFilesToDB:(paths,onload,onerror)=>{onload=onload||(()=>{});onerror=onerror||(()=>{});var indexedDB=FS.indexedDB();try{var openRequest=indexedDB.open(FS.DB_NAME(),FS.DB_VERSION);}catch(e){return onerror(e)}openRequest.onupgradeneeded=(()=>{out("creating db");var db=openRequest.result;db.createObjectStore(FS.DB_STORE_NAME);});openRequest.onsuccess=(()=>{var db=openRequest.result;var transaction=db.transaction([FS.DB_STORE_NAME],"readwrite");var files=transaction.objectStore(FS.DB_STORE_NAME);var ok=0,fail=0,total=paths.length;function finish(){if(fail==0)onload();else onerror();}paths.forEach(path=>{var putRequest=files.put(FS.analyzePath(path).object.contents,path);putRequest.onsuccess=(()=>{ok++;if(ok+fail==total)finish();});putRequest.onerror=(()=>{fail++;if(ok+fail==total)finish();});});transaction.onerror=onerror;});openRequest.onerror=onerror;},loadFilesFromDB:(paths,onload,onerror)=>{onload=onload||(()=>{});onerror=onerror||(()=>{});var indexedDB=FS.indexedDB();try{var openRequest=indexedDB.open(FS.DB_NAME(),FS.DB_VERSION);}catch(e){return onerror(e)}openRequest.onupgradeneeded=onerror;openRequest.onsuccess=(()=>{var db=openRequest.result;try{var transaction=db.transaction([FS.DB_STORE_NAME],"readonly");}catch(e){onerror(e);return}var files=transaction.objectStore(FS.DB_STORE_NAME);var ok=0,fail=0,total=paths.length;function finish(){if(fail==0)onload();else onerror();}paths.forEach(path=>{var getRequest=files.get(path);getRequest.onsuccess=(()=>{if(FS.analyzePath(path).exists){FS.unlink(path);}FS.createDataFile(PATH.dirname(path),PATH.basename(path),getRequest.result,true,true,true);ok++;if(ok+fail==total)finish();});getRequest.onerror=(()=>{fail++;if(ok+fail==total)finish();});});transaction.onerror=onerror;});openRequest.onerror=onerror;}};var SYSCALLS={DEFAULT_POLLMASK:5,calculateAt:function(dirfd,path,allowEmpty){if(PATH.isAbs(path)){return path}var dir;if(dirfd===-100){dir=FS.cwd();}else {var dirstream=FS.getStream(dirfd);if(!dirstream)throw new FS.ErrnoError(8);dir=dirstream.path;}if(path.length==0){if(!allowEmpty){throw new FS.ErrnoError(44)}return dir}return PATH.join2(dir,path)},doStat:function(func,path,buf){try{var stat=func(path);}catch(e){if(e&&e.node&&PATH.normalize(path)!==PATH.normalize(FS.getPath(e.node))){return -54}throw e}HEAP32[buf>>2]=stat.dev;HEAP32[buf+4>>2]=0;HEAP32[buf+8>>2]=stat.ino;HEAP32[buf+12>>2]=stat.mode;HEAP32[buf+16>>2]=stat.nlink;HEAP32[buf+20>>2]=stat.uid;HEAP32[buf+24>>2]=stat.gid;HEAP32[buf+28>>2]=stat.rdev;HEAP32[buf+32>>2]=0;tempI64=[stat.size>>>0,(tempDouble=stat.size,+Math.abs(tempDouble)>=1?tempDouble>0?(Math.min(+Math.floor(tempDouble/4294967296),4294967295)|0)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[buf+40>>2]=tempI64[0],HEAP32[buf+44>>2]=tempI64[1];HEAP32[buf+48>>2]=4096;HEAP32[buf+52>>2]=stat.blocks;HEAP32[buf+56>>2]=stat.atime.getTime()/1e3|0;HEAP32[buf+60>>2]=0;HEAP32[buf+64>>2]=stat.mtime.getTime()/1e3|0;HEAP32[buf+68>>2]=0;HEAP32[buf+72>>2]=stat.ctime.getTime()/1e3|0;HEAP32[buf+76>>2]=0;tempI64=[stat.ino>>>0,(tempDouble=stat.ino,+Math.abs(tempDouble)>=1?tempDouble>0?(Math.min(+Math.floor(tempDouble/4294967296),4294967295)|0)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[buf+80>>2]=tempI64[0],HEAP32[buf+84>>2]=tempI64[1];return 0},doMsync:function(addr,stream,len,flags,offset){var buffer=HEAPU8.slice(addr,addr+len);FS.msync(stream,buffer,offset,len,flags);},varargs:undefined,get:function(){SYSCALLS.varargs+=4;var ret=HEAP32[SYSCALLS.varargs-4>>2];return ret},getStr:function(ptr){var ret=UTF8ToString(ptr);return ret},getStreamFromFD:function(fd){var stream=FS.getStream(fd);if(!stream)throw new FS.ErrnoError(8);return stream}};function ___syscall_fcntl64(fd,cmd,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(fd);switch(cmd){case 0:{var arg=SYSCALLS.get();if(arg<0){return -28}var newStream;newStream=FS.createStream(stream,arg);return newStream.fd}case 1:case 2:return 0;case 3:return stream.flags;case 4:{var arg=SYSCALLS.get();stream.flags|=arg;return 0}case 5:{var arg=SYSCALLS.get();var offset=0;HEAP16[arg+offset>>1]=2;return 0}case 6:case 7:return 0;case 16:case 8:return -28;case 9:setErrNo(28);return -1;default:{return -28}}}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return -e.errno}}function ___syscall_fdatasync(fd){try{var stream=SYSCALLS.getStreamFromFD(fd);return 0}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return -e.errno}}function ___syscall_ftruncate64(fd,length_low,length_high){try{var length=length_high*4294967296+(length_low>>>0);FS.ftruncate(fd,length);return 0}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return -e.errno}}function ___syscall_ioctl(fd,op,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(fd);switch(op){case 21509:case 21505:{if(!stream.tty)return -59;return 0}case 21510:case 21511:case 21512:case 21506:case 21507:case 21508:{if(!stream.tty)return -59;return 0}case 21519:{if(!stream.tty)return -59;var argp=SYSCALLS.get();HEAP32[argp>>2]=0;return 0}case 21520:{if(!stream.tty)return -59;return -28}case 21531:{var argp=SYSCALLS.get();return FS.ioctl(stream,op,argp)}case 21523:{if(!stream.tty)return -59;return 0}case 21524:{if(!stream.tty)return -59;return 0}default:abort("bad ioctl syscall "+op);}}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return -e.errno}}function ___syscall_mkdirat(dirfd,path,mode){try{path=SYSCALLS.getStr(path);path=SYSCALLS.calculateAt(dirfd,path);path=PATH.normalize(path);if(path[path.length-1]==="/")path=path.substr(0,path.length-1);FS.mkdir(path,mode,0);return 0}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return -e.errno}}function ___syscall_openat(dirfd,path,flags,varargs){SYSCALLS.varargs=varargs;try{path=SYSCALLS.getStr(path);path=SYSCALLS.calculateAt(dirfd,path);var mode=varargs?SYSCALLS.get():0;return FS.open(path,flags,mode).fd}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return -e.errno}}function ___syscall_renameat(olddirfd,oldpath,newdirfd,newpath){try{oldpath=SYSCALLS.getStr(oldpath);newpath=SYSCALLS.getStr(newpath);oldpath=SYSCALLS.calculateAt(olddirfd,oldpath);newpath=SYSCALLS.calculateAt(newdirfd,newpath);FS.rename(oldpath,newpath);return 0}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return -e.errno}}function ___syscall_stat64(path,buf){try{path=SYSCALLS.getStr(path);return SYSCALLS.doStat(FS.stat,path,buf)}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return -e.errno}}function __embind_register_bigint(primitiveType,name,size,minRange,maxRange){}function getShiftFromSize(size){switch(size){case 1:return 0;case 2:return 1;case 4:return 2;case 8:return 3;default:throw new TypeError("Unknown type size: "+size)}}function embind_init_charCodes(){var codes=new Array(256);for(var i=0;i<256;++i){codes[i]=String.fromCharCode(i);}embind_charCodes=codes;}var embind_charCodes=undefined;function readLatin1String(ptr){var ret="";var c=ptr;while(HEAPU8[c]){ret+=embind_charCodes[HEAPU8[c++]];}return ret}var awaitingDependencies={};var registeredTypes={};var typeDependencies={};var char_0=48;var char_9=57;function makeLegalFunctionName(name){if(undefined===name){return "_unknown"}name=name.replace(/[^a-zA-Z0-9_]/g,"$");var f=name.charCodeAt(0);if(f>=char_0&&f<=char_9){return "_"+name}return name}function createNamedFunction(name,body){name=makeLegalFunctionName(name);return function(){return body.apply(this,arguments)}}function extendError(baseErrorType,errorName){var errorClass=createNamedFunction(errorName,function(message){this.name=errorName;this.message=message;var stack=new Error(message).stack;if(stack!==undefined){this.stack=this.toString()+"\n"+stack.replace(/^Error(:[^\n]*)?\n/,"");}});errorClass.prototype=Object.create(baseErrorType.prototype);errorClass.prototype.constructor=errorClass;errorClass.prototype.toString=function(){if(this.message===undefined){return this.name}else {return this.name+": "+this.message}};return errorClass}var BindingError=undefined;function throwBindingError(message){throw new BindingError(message)}var InternalError=undefined;function throwInternalError(message){throw new InternalError(message)}function whenDependentTypesAreResolved(myTypes,dependentTypes,getTypeConverters){myTypes.forEach(function(type){typeDependencies[type]=dependentTypes;});function onComplete(typeConverters){var myTypeConverters=getTypeConverters(typeConverters);if(myTypeConverters.length!==myTypes.length){throwInternalError("Mismatched type converter count");}for(var i=0;i<myTypes.length;++i){registerType(myTypes[i],myTypeConverters[i]);}}var typeConverters=new Array(dependentTypes.length);var unregisteredTypes=[];var registered=0;dependentTypes.forEach((dt,i)=>{if(registeredTypes.hasOwnProperty(dt)){typeConverters[i]=registeredTypes[dt];}else {unregisteredTypes.push(dt);if(!awaitingDependencies.hasOwnProperty(dt)){awaitingDependencies[dt]=[];}awaitingDependencies[dt].push(()=>{typeConverters[i]=registeredTypes[dt];++registered;if(registered===unregisteredTypes.length){onComplete(typeConverters);}});}});if(0===unregisteredTypes.length){onComplete(typeConverters);}}function registerType(rawType,registeredInstance,options={}){if(!("argPackAdvance"in registeredInstance)){throw new TypeError("registerType registeredInstance requires argPackAdvance")}var name=registeredInstance.name;if(!rawType){throwBindingError('type "'+name+'" must have a positive integer typeid pointer');}if(registeredTypes.hasOwnProperty(rawType)){if(options.ignoreDuplicateRegistrations){return}else {throwBindingError("Cannot register type '"+name+"' twice");}}registeredTypes[rawType]=registeredInstance;delete typeDependencies[rawType];if(awaitingDependencies.hasOwnProperty(rawType)){var callbacks=awaitingDependencies[rawType];delete awaitingDependencies[rawType];callbacks.forEach(cb=>cb());}}function __embind_register_bool(rawType,name,size,trueValue,falseValue){var shift=getShiftFromSize(size);name=readLatin1String(name);registerType(rawType,{name:name,"fromWireType":function(wt){return !!wt},"toWireType":function(destructors,o){return o?trueValue:falseValue},"argPackAdvance":8,"readValueFromPointer":function(pointer){var heap;if(size===1){heap=HEAP8;}else if(size===2){heap=HEAP16;}else if(size===4){heap=HEAP32;}else {throw new TypeError("Unknown boolean type size: "+name)}return this["fromWireType"](heap[pointer>>shift])},destructorFunction:null});}var emval_free_list=[];var emval_handle_array=[{},{value:undefined},{value:null},{value:true},{value:false}];function __emval_decref(handle){if(handle>4&&0===--emval_handle_array[handle].refcount){emval_handle_array[handle]=undefined;emval_free_list.push(handle);}}function count_emval_handles(){var count=0;for(var i=5;i<emval_handle_array.length;++i){if(emval_handle_array[i]!==undefined){++count;}}return count}function get_first_emval(){for(var i=5;i<emval_handle_array.length;++i){if(emval_handle_array[i]!==undefined){return emval_handle_array[i]}}return null}function init_emval(){Module["count_emval_handles"]=count_emval_handles;Module["get_first_emval"]=get_first_emval;}var Emval={toValue:handle=>{if(!handle){throwBindingError("Cannot use deleted val. handle = "+handle);}return emval_handle_array[handle].value},toHandle:value=>{switch(value){case undefined:return 1;case null:return 2;case true:return 3;case false:return 4;default:{var handle=emval_free_list.length?emval_free_list.pop():emval_handle_array.length;emval_handle_array[handle]={refcount:1,value:value};return handle}}}};function simpleReadValueFromPointer(pointer){return this["fromWireType"](HEAPU32[pointer>>2])}function __embind_register_emval(rawType,name){name=readLatin1String(name);registerType(rawType,{name:name,"fromWireType":function(handle){var rv=Emval.toValue(handle);__emval_decref(handle);return rv},"toWireType":function(destructors,value){return Emval.toHandle(value)},"argPackAdvance":8,"readValueFromPointer":simpleReadValueFromPointer,destructorFunction:null});}function floatReadValueFromPointer(name,shift){switch(shift){case 2:return function(pointer){return this["fromWireType"](HEAPF32[pointer>>2])};case 3:return function(pointer){return this["fromWireType"](HEAPF64[pointer>>3])};default:throw new TypeError("Unknown float type: "+name)}}function __embind_register_float(rawType,name,size){var shift=getShiftFromSize(size);name=readLatin1String(name);registerType(rawType,{name:name,"fromWireType":function(value){return value},"toWireType":function(destructors,value){return value},"argPackAdvance":8,"readValueFromPointer":floatReadValueFromPointer(name,shift),destructorFunction:null});}function runDestructors(destructors){while(destructors.length){var ptr=destructors.pop();var del=destructors.pop();del(ptr);}}function runAndAbortIfError(func){try{return func()}catch(e){abort(e);}}function callUserCallback(func,synchronous){if(ABORT){return}if(synchronous){func();return}try{func();}catch(e){handleException(e);}}var Asyncify={State:{Normal:0,Unwinding:1,Rewinding:2,Disabled:3},state:0,StackSize:4096,currData:null,handleSleepReturnValue:0,exportCallStack:[],callStackNameToId:{},callStackIdToName:{},callStackId:0,asyncPromiseHandlers:null,sleepCallbacks:[],getCallStackId:function(funcName){var id=Asyncify.callStackNameToId[funcName];if(id===undefined){id=Asyncify.callStackId++;Asyncify.callStackNameToId[funcName]=id;Asyncify.callStackIdToName[id]=funcName;}return id},instrumentWasmExports:function(exports){var ret={};for(var x in exports){(function(x){var original=exports[x];if(typeof original=="function"){ret[x]=function(){Asyncify.exportCallStack.push(x);try{return original.apply(null,arguments)}finally{if(!ABORT){var y=Asyncify.exportCallStack.pop();assert(y===x);Asyncify.maybeStopUnwind();}}};}else {ret[x]=original;}})(x);}return ret},maybeStopUnwind:function(){if(Asyncify.currData&&Asyncify.state===Asyncify.State.Unwinding&&Asyncify.exportCallStack.length===0){Asyncify.state=Asyncify.State.Normal;runAndAbortIfError(Module["_asyncify_stop_unwind"]);if(typeof Fibers!="undefined"){Fibers.trampoline();}}},whenDone:function(){return new Promise((resolve,reject)=>{Asyncify.asyncPromiseHandlers={resolve:resolve,reject:reject};})},allocateData:function(){var ptr=_malloc(12+Asyncify.StackSize);Asyncify.setDataHeader(ptr,ptr+12,Asyncify.StackSize);Asyncify.setDataRewindFunc(ptr);return ptr},setDataHeader:function(ptr,stack,stackSize){HEAP32[ptr>>2]=stack;HEAP32[ptr+4>>2]=stack+stackSize;},setDataRewindFunc:function(ptr){var bottomOfCallStack=Asyncify.exportCallStack[0];var rewindId=Asyncify.getCallStackId(bottomOfCallStack);HEAP32[ptr+8>>2]=rewindId;},getDataRewindFunc:function(ptr){var id=HEAP32[ptr+8>>2];var name=Asyncify.callStackIdToName[id];var func=Module["asm"][name];return func},doRewind:function(ptr){var start=Asyncify.getDataRewindFunc(ptr);return start()},handleSleep:function(startAsync){if(ABORT)return;if(Asyncify.state===Asyncify.State.Normal){var reachedCallback=false;var reachedAfterCallback=false;startAsync(handleSleepReturnValue=>{if(ABORT)return;Asyncify.handleSleepReturnValue=handleSleepReturnValue||0;reachedCallback=true;if(!reachedAfterCallback){return}Asyncify.state=Asyncify.State.Rewinding;runAndAbortIfError(()=>Module["_asyncify_start_rewind"](Asyncify.currData));if(typeof Browser!="undefined"&&Browser.mainLoop.func){Browser.mainLoop.resume();}var asyncWasmReturnValue,isError=false;try{asyncWasmReturnValue=Asyncify.doRewind(Asyncify.currData);}catch(err){asyncWasmReturnValue=err;isError=true;}var handled=false;if(!Asyncify.currData){var asyncPromiseHandlers=Asyncify.asyncPromiseHandlers;if(asyncPromiseHandlers){Asyncify.asyncPromiseHandlers=null;(isError?asyncPromiseHandlers.reject:asyncPromiseHandlers.resolve)(asyncWasmReturnValue);handled=true;}}if(isError&&!handled){throw asyncWasmReturnValue}});reachedAfterCallback=true;if(!reachedCallback){Asyncify.state=Asyncify.State.Unwinding;Asyncify.currData=Asyncify.allocateData();runAndAbortIfError(()=>Module["_asyncify_start_unwind"](Asyncify.currData));if(typeof Browser!="undefined"&&Browser.mainLoop.func){Browser.mainLoop.pause();}}}else if(Asyncify.state===Asyncify.State.Rewinding){Asyncify.state=Asyncify.State.Normal;runAndAbortIfError(Module["_asyncify_stop_rewind"]);_free(Asyncify.currData);Asyncify.currData=null;Asyncify.sleepCallbacks.forEach(func=>callUserCallback(func));}else {abort("invalid state: "+Asyncify.state);}return Asyncify.handleSleepReturnValue},handleAsync:function(startAsync){return Asyncify.handleSleep(wakeUp=>{startAsync().then(wakeUp);})}};function craftInvokerFunction(humanName,argTypes,classType,cppInvokerFunc,cppTargetFunc){var argCount=argTypes.length;if(argCount<2){throwBindingError("argTypes array size mismatch! Must at least get return value and 'this' types!");}var isClassMethodFunc=argTypes[1]!==null&&classType!==null;var needsDestructorStack=false;for(var i=1;i<argTypes.length;++i){if(argTypes[i]!==null&&argTypes[i].destructorFunction===undefined){needsDestructorStack=true;break}}var returns=argTypes[0].name!=="void";var expectedArgCount=argCount-2;var argsWired=new Array(expectedArgCount);var invokerFuncArgs=[];var destructors=[];return function(){if(arguments.length!==expectedArgCount){throwBindingError("function "+humanName+" called with "+arguments.length+" arguments, expected "+expectedArgCount+" args!");}destructors.length=0;var thisWired;invokerFuncArgs.length=isClassMethodFunc?2:1;invokerFuncArgs[0]=cppTargetFunc;if(isClassMethodFunc){thisWired=argTypes[1]["toWireType"](destructors,this);invokerFuncArgs[1]=thisWired;}for(var i=0;i<expectedArgCount;++i){argsWired[i]=argTypes[i+2]["toWireType"](destructors,arguments[i]);invokerFuncArgs.push(argsWired[i]);}var rv=cppInvokerFunc.apply(null,invokerFuncArgs);function onDone(rv){if(needsDestructorStack){runDestructors(destructors);}else {for(var i=isClassMethodFunc?1:2;i<argTypes.length;i++){var param=i===1?thisWired:argsWired[i-2];if(argTypes[i].destructorFunction!==null){argTypes[i].destructorFunction(param);}}}if(returns){return argTypes[0]["fromWireType"](rv)}}if(Asyncify.currData){return Asyncify.whenDone().then(onDone)}return onDone(rv)}}function ensureOverloadTable(proto,methodName,humanName){if(undefined===proto[methodName].overloadTable){var prevFunc=proto[methodName];proto[methodName]=function(){if(!proto[methodName].overloadTable.hasOwnProperty(arguments.length)){throwBindingError("Function '"+humanName+"' called with an invalid number of arguments ("+arguments.length+") - expects one of ("+proto[methodName].overloadTable+")!");}return proto[methodName].overloadTable[arguments.length].apply(this,arguments)};proto[methodName].overloadTable=[];proto[methodName].overloadTable[prevFunc.argCount]=prevFunc;}}function exposePublicSymbol(name,value,numArguments){if(Module.hasOwnProperty(name)){if(undefined===numArguments||undefined!==Module[name].overloadTable&&undefined!==Module[name].overloadTable[numArguments]){throwBindingError("Cannot register public name '"+name+"' twice");}ensureOverloadTable(Module,name,name);if(Module.hasOwnProperty(numArguments)){throwBindingError("Cannot register multiple overloads of a function with the same number of arguments ("+numArguments+")!");}Module[name].overloadTable[numArguments]=value;}else {Module[name]=value;if(undefined!==numArguments){Module[name].numArguments=numArguments;}}}function heap32VectorToArray(count,firstElement){var array=[];for(var i=0;i<count;i++){array.push(HEAP32[(firstElement>>2)+i]);}return array}function replacePublicSymbol(name,value,numArguments){if(!Module.hasOwnProperty(name)){throwInternalError("Replacing nonexistant public symbol");}if(undefined!==Module[name].overloadTable&&undefined!==numArguments){Module[name].overloadTable[numArguments]=value;}else {Module[name]=value;Module[name].argCount=numArguments;}}function dynCallLegacy(sig,ptr,args){var f=Module["dynCall_"+sig];return args&&args.length?f.apply(null,[ptr].concat(args)):f.call(null,ptr)}function dynCall(sig,ptr,args){return dynCallLegacy(sig,ptr,args)}function getDynCaller(sig,ptr){var argCache=[];return function(){argCache.length=0;Object.assign(argCache,arguments);return dynCall(sig,ptr,argCache)}}function embind__requireFunction(signature,rawFunction){signature=readLatin1String(signature);function makeDynCaller(){return getDynCaller(signature,rawFunction)}var fp=makeDynCaller();if(typeof fp!="function"){throwBindingError("unknown function pointer with signature "+signature+": "+rawFunction);}return fp}var UnboundTypeError=undefined;function getTypeName(type){var ptr=___getTypeName(type);var rv=readLatin1String(ptr);_free(ptr);return rv}function throwUnboundTypeError(message,types){var unboundTypes=[];var seen={};function visit(type){if(seen[type]){return}if(registeredTypes[type]){return}if(typeDependencies[type]){typeDependencies[type].forEach(visit);return}unboundTypes.push(type);seen[type]=true;}types.forEach(visit);throw new UnboundTypeError(message+": "+unboundTypes.map(getTypeName).join([", "]))}function __embind_register_function(name,argCount,rawArgTypesAddr,signature,rawInvoker,fn){var argTypes=heap32VectorToArray(argCount,rawArgTypesAddr);name=readLatin1String(name);rawInvoker=embind__requireFunction(signature,rawInvoker);exposePublicSymbol(name,function(){throwUnboundTypeError("Cannot call "+name+" due to unbound types",argTypes);},argCount-1);whenDependentTypesAreResolved([],argTypes,function(argTypes){var invokerArgsArray=[argTypes[0],null].concat(argTypes.slice(1));replacePublicSymbol(name,craftInvokerFunction(name,invokerArgsArray,null,rawInvoker,fn),argCount-1);return []});}function integerReadValueFromPointer(name,shift,signed){switch(shift){case 0:return signed?function readS8FromPointer(pointer){return HEAP8[pointer]}:function readU8FromPointer(pointer){return HEAPU8[pointer]};case 1:return signed?function readS16FromPointer(pointer){return HEAP16[pointer>>1]}:function readU16FromPointer(pointer){return HEAPU16[pointer>>1]};case 2:return signed?function readS32FromPointer(pointer){return HEAP32[pointer>>2]}:function readU32FromPointer(pointer){return HEAPU32[pointer>>2]};default:throw new TypeError("Unknown integer type: "+name)}}function __embind_register_integer(primitiveType,name,size,minRange,maxRange){name=readLatin1String(name);var shift=getShiftFromSize(size);var fromWireType=value=>value;if(minRange===0){var bitshift=32-8*size;fromWireType=(value=>value<<bitshift>>>bitshift);}var isUnsignedType=name.includes("unsigned");var checkAssertions=(value,toTypeName)=>{};var toWireType;if(isUnsignedType){toWireType=function(destructors,value){checkAssertions(value,this.name);return value>>>0};}else {toWireType=function(destructors,value){checkAssertions(value,this.name);return value};}registerType(primitiveType,{name:name,"fromWireType":fromWireType,"toWireType":toWireType,"argPackAdvance":8,"readValueFromPointer":integerReadValueFromPointer(name,shift,minRange!==0),destructorFunction:null});}function __embind_register_memory_view(rawType,dataTypeIndex,name){var typeMapping=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array];var TA=typeMapping[dataTypeIndex];function decodeMemoryView(handle){handle=handle>>2;var heap=HEAPU32;var size=heap[handle];var data=heap[handle+1];return new TA(buffer,data,size)}name=readLatin1String(name);registerType(rawType,{name:name,"fromWireType":decodeMemoryView,"argPackAdvance":8,"readValueFromPointer":decodeMemoryView},{ignoreDuplicateRegistrations:true});}function __embind_register_std_string(rawType,name){name=readLatin1String(name);var stdStringIsUTF8=name==="std::string";registerType(rawType,{name:name,"fromWireType":function(value){var length=HEAPU32[value>>2];var str;if(stdStringIsUTF8){var decodeStartPtr=value+4;for(var i=0;i<=length;++i){var currentBytePtr=value+4+i;if(i==length||HEAPU8[currentBytePtr]==0){var maxRead=currentBytePtr-decodeStartPtr;var stringSegment=UTF8ToString(decodeStartPtr,maxRead);if(str===undefined){str=stringSegment;}else {str+=String.fromCharCode(0);str+=stringSegment;}decodeStartPtr=currentBytePtr+1;}}}else {var a=new Array(length);for(var i=0;i<length;++i){a[i]=String.fromCharCode(HEAPU8[value+4+i]);}str=a.join("");}_free(value);return str},"toWireType":function(destructors,value){if(value instanceof ArrayBuffer){value=new Uint8Array(value);}var getLength;var valueIsOfTypeString=typeof value=="string";if(!(valueIsOfTypeString||value instanceof Uint8Array||value instanceof Uint8ClampedArray||value instanceof Int8Array)){throwBindingError("Cannot pass non-string to std::string");}if(stdStringIsUTF8&&valueIsOfTypeString){getLength=(()=>lengthBytesUTF8(value));}else {getLength=(()=>value.length);}var length=getLength();var ptr=_malloc(4+length+1);HEAPU32[ptr>>2]=length;if(stdStringIsUTF8&&valueIsOfTypeString){stringToUTF8(value,ptr+4,length+1);}else {if(valueIsOfTypeString){for(var i=0;i<length;++i){var charCode=value.charCodeAt(i);if(charCode>255){_free(ptr);throwBindingError("String has UTF-16 code units that do not fit in 8 bits");}HEAPU8[ptr+4+i]=charCode;}}else {for(var i=0;i<length;++i){HEAPU8[ptr+4+i]=value[i];}}}if(destructors!==null){destructors.push(_free,ptr);}return ptr},"argPackAdvance":8,"readValueFromPointer":simpleReadValueFromPointer,destructorFunction:function(ptr){_free(ptr);}});}function __embind_register_std_wstring(rawType,charSize,name){name=readLatin1String(name);var decodeString,encodeString,getHeap,lengthBytesUTF,shift;if(charSize===2){decodeString=UTF16ToString;encodeString=stringToUTF16;lengthBytesUTF=lengthBytesUTF16;getHeap=(()=>HEAPU16);shift=1;}else if(charSize===4){decodeString=UTF32ToString;encodeString=stringToUTF32;lengthBytesUTF=lengthBytesUTF32;getHeap=(()=>HEAPU32);shift=2;}registerType(rawType,{name:name,"fromWireType":function(value){var length=HEAPU32[value>>2];var HEAP=getHeap();var str;var decodeStartPtr=value+4;for(var i=0;i<=length;++i){var currentBytePtr=value+4+i*charSize;if(i==length||HEAP[currentBytePtr>>shift]==0){var maxReadBytes=currentBytePtr-decodeStartPtr;var stringSegment=decodeString(decodeStartPtr,maxReadBytes);if(str===undefined){str=stringSegment;}else {str+=String.fromCharCode(0);str+=stringSegment;}decodeStartPtr=currentBytePtr+charSize;}}_free(value);return str},"toWireType":function(destructors,value){if(!(typeof value=="string")){throwBindingError("Cannot pass non-string to C++ string type "+name);}var length=lengthBytesUTF(value);var ptr=_malloc(4+length+charSize);HEAPU32[ptr>>2]=length>>shift;encodeString(value,ptr+4,length+charSize);if(destructors!==null){destructors.push(_free,ptr);}return ptr},"argPackAdvance":8,"readValueFromPointer":simpleReadValueFromPointer,destructorFunction:function(ptr){_free(ptr);}});}function __embind_register_void(rawType,name){name=readLatin1String(name);registerType(rawType,{isVoid:true,name:name,"argPackAdvance":0,"fromWireType":function(){return undefined},"toWireType":function(destructors,o){return undefined}});}function __emscripten_date_now(){return Date.now()}var nowIsMonotonic=true;function __emscripten_get_now_is_monotonic(){return nowIsMonotonic}function __emscripten_get_progname(str,len){stringToUTF8(thisProgram,str,len);}function requireRegisteredType(rawType,humanName){var impl=registeredTypes[rawType];if(undefined===impl){throwBindingError(humanName+" has unknown type "+getTypeName(rawType));}return impl}function __emval_lookupTypes(argCount,argTypes){var a=new Array(argCount);for(var i=0;i<argCount;++i){a[i]=requireRegisteredType(HEAP32[(argTypes>>2)+i],"parameter "+i);}return a}function __emval_call(handle,argCount,argTypes,argv){handle=Emval.toValue(handle);var types=__emval_lookupTypes(argCount,argTypes);var args=new Array(argCount);for(var i=0;i<argCount;++i){var type=types[i];args[i]=type["readValueFromPointer"](argv);argv+=type["argPackAdvance"];}var rv=handle.apply(undefined,args);return Emval.toHandle(rv)}function __emval_equals(first,second){first=Emval.toValue(first);second=Emval.toValue(second);return first==second}function __emval_incref(handle){if(handle>4){emval_handle_array[handle].refcount+=1;}}function __emval_take_value(type,argv){type=requireRegisteredType(type,"_emval_take_value");var v=type["readValueFromPointer"](argv);return Emval.toHandle(v)}function __gmtime_js(time,tmPtr){var date=new Date(HEAP32[time>>2]*1e3);HEAP32[tmPtr>>2]=date.getUTCSeconds();HEAP32[tmPtr+4>>2]=date.getUTCMinutes();HEAP32[tmPtr+8>>2]=date.getUTCHours();HEAP32[tmPtr+12>>2]=date.getUTCDate();HEAP32[tmPtr+16>>2]=date.getUTCMonth();HEAP32[tmPtr+20>>2]=date.getUTCFullYear()-1900;HEAP32[tmPtr+24>>2]=date.getUTCDay();var start=Date.UTC(date.getUTCFullYear(),0,1,0,0,0,0);var yday=(date.getTime()-start)/(1e3*60*60*24)|0;HEAP32[tmPtr+28>>2]=yday;}function __mktime_js(tmPtr){var date=new Date(HEAP32[tmPtr+20>>2]+1900,HEAP32[tmPtr+16>>2],HEAP32[tmPtr+12>>2],HEAP32[tmPtr+8>>2],HEAP32[tmPtr+4>>2],HEAP32[tmPtr>>2],0);var dst=HEAP32[tmPtr+32>>2];var guessedOffset=date.getTimezoneOffset();var start=new Date(date.getFullYear(),0,1);var summerOffset=new Date(date.getFullYear(),6,1).getTimezoneOffset();var winterOffset=start.getTimezoneOffset();var dstOffset=Math.min(winterOffset,summerOffset);if(dst<0){HEAP32[tmPtr+32>>2]=Number(summerOffset!=winterOffset&&dstOffset==guessedOffset);}else if(dst>0!=(dstOffset==guessedOffset)){var nonDstOffset=Math.max(winterOffset,summerOffset);var trueOffset=dst>0?dstOffset:nonDstOffset;date.setTime(date.getTime()+(trueOffset-guessedOffset)*6e4);}HEAP32[tmPtr+24>>2]=date.getDay();var yday=(date.getTime()-start.getTime())/(1e3*60*60*24)|0;HEAP32[tmPtr+28>>2]=yday;HEAP32[tmPtr>>2]=date.getSeconds();HEAP32[tmPtr+4>>2]=date.getMinutes();HEAP32[tmPtr+8>>2]=date.getHours();HEAP32[tmPtr+12>>2]=date.getDate();HEAP32[tmPtr+16>>2]=date.getMonth();return date.getTime()/1e3|0}function __mmap_js(addr,len,prot,flags,fd,off,allocated,builtin){try{var info=FS.getStream(fd);if(!info)return -8;var res=FS.mmap(info,addr,len,off,prot,flags);var ptr=res.ptr;HEAP32[allocated>>2]=res.allocated;return ptr}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return -e.errno}}function __msync_js(addr,len,flags,fd){try{SYSCALLS.doMsync(addr,FS.getStream(fd),len,flags,0);return 0}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return -e.errno}}function __munmap_js(addr,len,prot,flags,fd,offset){try{var stream=FS.getStream(fd);if(stream){if(prot&2){SYSCALLS.doMsync(addr,stream,len,flags,offset);}FS.munmap(stream);}}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return -e.errno}}function _tzset_impl(timezone,daylight,tzname){var currentYear=(new Date).getFullYear();var winter=new Date(currentYear,0,1);var summer=new Date(currentYear,6,1);var winterOffset=winter.getTimezoneOffset();var summerOffset=summer.getTimezoneOffset();var stdTimezoneOffset=Math.max(winterOffset,summerOffset);HEAP32[timezone>>2]=stdTimezoneOffset*60;HEAP32[daylight>>2]=Number(winterOffset!=summerOffset);function extractZone(date){var match=date.toTimeString().match(/\(([A-Za-z ]+)\)$/);return match?match[1]:"GMT"}var winterName=extractZone(winter);var summerName=extractZone(summer);var winterNamePtr=allocateUTF8(winterName);var summerNamePtr=allocateUTF8(summerName);if(summerOffset<winterOffset){HEAP32[tzname>>2]=winterNamePtr;HEAP32[tzname+4>>2]=summerNamePtr;}else {HEAP32[tzname>>2]=summerNamePtr;HEAP32[tzname+4>>2]=winterNamePtr;}}function __tzset_js(timezone,daylight,tzname){if(__tzset_js.called)return;__tzset_js.called=true;_tzset_impl(timezone,daylight,tzname);}function _abort(){abort("");}function _emscripten_get_heap_max(){return 2147483648}var _emscripten_get_now;if(ENVIRONMENT_IS_NODE){_emscripten_get_now=(()=>{var t=process["hrtime"]();return t[0]*1e3+t[1]/1e6});}else _emscripten_get_now=(()=>performance.now());function emscripten_realloc_buffer(size){try{wasmMemory.grow(size-buffer.byteLength+65535>>>16);updateGlobalBufferAndViews(wasmMemory.buffer);return 1}catch(e){}}function _emscripten_resize_heap(requestedSize){var oldSize=HEAPU8.length;requestedSize=requestedSize>>>0;var maxHeapSize=_emscripten_get_heap_max();if(requestedSize>maxHeapSize){return false}let alignUp=(x,multiple)=>x+(multiple-x%multiple)%multiple;for(var cutDown=1;cutDown<=4;cutDown*=2){var overGrownHeapSize=oldSize*(1+.2/cutDown);overGrownHeapSize=Math.min(overGrownHeapSize,requestedSize+100663296);var newSize=Math.min(maxHeapSize,alignUp(Math.max(requestedSize,overGrownHeapSize),65536));var replacement=emscripten_realloc_buffer(newSize);if(replacement){return true}}return false}var ENV={};function getExecutableName(){return thisProgram||"./this.program"}function getEnvStrings(){if(!getEnvStrings.strings){var lang=(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8";var env={"USER":"web_user","LOGNAME":"web_user","PATH":"/","PWD":"/","HOME":"/home/web_user","LANG":lang,"_":getExecutableName()};for(var x in ENV){if(ENV[x]===undefined)delete env[x];else env[x]=ENV[x];}var strings=[];for(var x in env){strings.push(x+"="+env[x]);}getEnvStrings.strings=strings;}return getEnvStrings.strings}function _environ_get(__environ,environ_buf){var bufSize=0;getEnvStrings().forEach(function(string,i){var ptr=environ_buf+bufSize;HEAP32[__environ+i*4>>2]=ptr;writeAsciiToMemory(string,ptr);bufSize+=string.length+1;});return 0}function _environ_sizes_get(penviron_count,penviron_buf_size){var strings=getEnvStrings();HEAP32[penviron_count>>2]=strings.length;var bufSize=0;strings.forEach(function(string){bufSize+=string.length+1;});HEAP32[penviron_buf_size>>2]=bufSize;return 0}function _exit(status){exit(status);}function _fd_close(fd){try{var stream=SYSCALLS.getStreamFromFD(fd);FS.close(stream);return 0}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return e.errno}}function doWritev(stream,iov,iovcnt,offset){var ret=0;for(var i=0;i<iovcnt;i++){var ptr=HEAPU32[iov>>2];var len=HEAPU32[iov+4>>2];iov+=8;var curr=FS.write(stream,HEAP8,ptr,len,offset);if(curr<0)return -1;ret+=curr;}return ret}function _fd_pwrite(fd,iov,iovcnt,offset_low,offset_high,pnum){try{var stream=SYSCALLS.getStreamFromFD(fd);var num=doWritev(stream,iov,iovcnt,offset_low);HEAP32[pnum>>2]=num;return 0}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return e.errno}}function doReadv(stream,iov,iovcnt,offset){var ret=0;for(var i=0;i<iovcnt;i++){var ptr=HEAPU32[iov>>2];var len=HEAPU32[iov+4>>2];iov+=8;var curr=FS.read(stream,HEAP8,ptr,len,offset);if(curr<0)return -1;ret+=curr;if(curr<len)break}return ret}function _fd_read(fd,iov,iovcnt,pnum){try{var stream=SYSCALLS.getStreamFromFD(fd);var num=doReadv(stream,iov,iovcnt);HEAP32[pnum>>2]=num;return 0}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return e.errno}}function _fd_seek(fd,offset_low,offset_high,whence,newOffset){try{var stream=SYSCALLS.getStreamFromFD(fd);var HIGH_OFFSET=4294967296;var offset=offset_high*HIGH_OFFSET+(offset_low>>>0);var DOUBLE_LIMIT=9007199254740992;if(offset<=-DOUBLE_LIMIT||offset>=DOUBLE_LIMIT){return 61}FS.llseek(stream,offset,whence);tempI64=[stream.position>>>0,(tempDouble=stream.position,+Math.abs(tempDouble)>=1?tempDouble>0?(Math.min(+Math.floor(tempDouble/4294967296),4294967295)|0)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[newOffset>>2]=tempI64[0],HEAP32[newOffset+4>>2]=tempI64[1];if(stream.getdents&&offset===0&&whence===0)stream.getdents=null;return 0}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return e.errno}}function _fd_write(fd,iov,iovcnt,pnum){try{var stream=SYSCALLS.getStreamFromFD(fd);var num=doWritev(stream,iov,iovcnt);HEAP32[pnum>>2]=num;return 0}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return e.errno}}function _getTempRet0(){return getTempRet0()}function _llvm_eh_typeid_for(type){return type}function _proc_exit(code){procExit(code);}function _rx_slow_hash(){err("missing function: rx_slow_hash");abort(-1);}function _setTempRet0(val){setTempRet0(val);}function __isLeapYear(year){return year%4===0&&(year%100!==0||year%400===0)}function __arraySum(array,index){var sum=0;for(var i=0;i<=index;sum+=array[i++]){}return sum}var __MONTH_DAYS_LEAP=[31,29,31,30,31,30,31,31,30,31,30,31];var __MONTH_DAYS_REGULAR=[31,28,31,30,31,30,31,31,30,31,30,31];function __addDays(date,days){var newDate=new Date(date.getTime());while(days>0){var leap=__isLeapYear(newDate.getFullYear());var currentMonth=newDate.getMonth();var daysInCurrentMonth=(leap?__MONTH_DAYS_LEAP:__MONTH_DAYS_REGULAR)[currentMonth];if(days>daysInCurrentMonth-newDate.getDate()){days-=daysInCurrentMonth-newDate.getDate()+1;newDate.setDate(1);if(currentMonth<11){newDate.setMonth(currentMonth+1);}else {newDate.setMonth(0);newDate.setFullYear(newDate.getFullYear()+1);}}else {newDate.setDate(newDate.getDate()+days);return newDate}}return newDate}function _strftime(s,maxsize,format,tm){var tm_zone=HEAP32[tm+40>>2];var date={tm_sec:HEAP32[tm>>2],tm_min:HEAP32[tm+4>>2],tm_hour:HEAP32[tm+8>>2],tm_mday:HEAP32[tm+12>>2],tm_mon:HEAP32[tm+16>>2],tm_year:HEAP32[tm+20>>2],tm_wday:HEAP32[tm+24>>2],tm_yday:HEAP32[tm+28>>2],tm_isdst:HEAP32[tm+32>>2],tm_gmtoff:HEAP32[tm+36>>2],tm_zone:tm_zone?UTF8ToString(tm_zone):""};var pattern=UTF8ToString(format);var EXPANSION_RULES_1={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var rule in EXPANSION_RULES_1){pattern=pattern.replace(new RegExp(rule,"g"),EXPANSION_RULES_1[rule]);}var WEEKDAYS=["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"];var MONTHS=["January","February","March","April","May","June","July","August","September","October","November","December"];function leadingSomething(value,digits,character){var str=typeof value=="number"?value.toString():value||"";while(str.length<digits){str=character[0]+str;}return str}function leadingNulls(value,digits){return leadingSomething(value,digits,"0")}function compareByDay(date1,date2){function sgn(value){return value<0?-1:value>0?1:0}var compare;if((compare=sgn(date1.getFullYear()-date2.getFullYear()))===0){if((compare=sgn(date1.getMonth()-date2.getMonth()))===0){compare=sgn(date1.getDate()-date2.getDate());}}return compare}function getFirstWeekStartDate(janFourth){switch(janFourth.getDay()){case 0:return new Date(janFourth.getFullYear()-1,11,29);case 1:return janFourth;case 2:return new Date(janFourth.getFullYear(),0,3);case 3:return new Date(janFourth.getFullYear(),0,2);case 4:return new Date(janFourth.getFullYear(),0,1);case 5:return new Date(janFourth.getFullYear()-1,11,31);case 6:return new Date(janFourth.getFullYear()-1,11,30)}}function getWeekBasedYear(date){var thisDate=__addDays(new Date(date.tm_year+1900,0,1),date.tm_yday);var janFourthThisYear=new Date(thisDate.getFullYear(),0,4);var janFourthNextYear=new Date(thisDate.getFullYear()+1,0,4);var firstWeekStartThisYear=getFirstWeekStartDate(janFourthThisYear);var firstWeekStartNextYear=getFirstWeekStartDate(janFourthNextYear);if(compareByDay(firstWeekStartThisYear,thisDate)<=0){if(compareByDay(firstWeekStartNextYear,thisDate)<=0){return thisDate.getFullYear()+1}else {return thisDate.getFullYear()}}else {return thisDate.getFullYear()-1}}var EXPANSION_RULES_2={"%a":function(date){return WEEKDAYS[date.tm_wday].substring(0,3)},"%A":function(date){return WEEKDAYS[date.tm_wday]},"%b":function(date){return MONTHS[date.tm_mon].substring(0,3)},"%B":function(date){return MONTHS[date.tm_mon]},"%C":function(date){var year=date.tm_year+1900;return leadingNulls(year/100|0,2)},"%d":function(date){return leadingNulls(date.tm_mday,2)},"%e":function(date){return leadingSomething(date.tm_mday,2," ")},"%g":function(date){return getWeekBasedYear(date).toString().substring(2)},"%G":function(date){return getWeekBasedYear(date)},"%H":function(date){return leadingNulls(date.tm_hour,2)},"%I":function(date){var twelveHour=date.tm_hour;if(twelveHour==0)twelveHour=12;else if(twelveHour>12)twelveHour-=12;return leadingNulls(twelveHour,2)},"%j":function(date){return leadingNulls(date.tm_mday+__arraySum(__isLeapYear(date.tm_year+1900)?__MONTH_DAYS_LEAP:__MONTH_DAYS_REGULAR,date.tm_mon-1),3)},"%m":function(date){return leadingNulls(date.tm_mon+1,2)},"%M":function(date){return leadingNulls(date.tm_min,2)},"%n":function(){return "\n"},"%p":function(date){if(date.tm_hour>=0&&date.tm_hour<12){return "AM"}else {return "PM"}},"%S":function(date){return leadingNulls(date.tm_sec,2)},"%t":function(){return "\t"},"%u":function(date){return date.tm_wday||7},"%U":function(date){var days=date.tm_yday+7-date.tm_wday;return leadingNulls(Math.floor(days/7),2)},"%V":function(date){var val=Math.floor((date.tm_yday+7-(date.tm_wday+6)%7)/7);if((date.tm_wday+371-date.tm_yday-2)%7<=2){val++;}if(!val){val=52;var dec31=(date.tm_wday+7-date.tm_yday-1)%7;if(dec31==4||dec31==5&&__isLeapYear(date.tm_year%400-1)){val++;}}else if(val==53){var jan1=(date.tm_wday+371-date.tm_yday)%7;if(jan1!=4&&(jan1!=3||!__isLeapYear(date.tm_year)))val=1;}return leadingNulls(val,2)},"%w":function(date){return date.tm_wday},"%W":function(date){var days=date.tm_yday+7-(date.tm_wday+6)%7;return leadingNulls(Math.floor(days/7),2)},"%y":function(date){return (date.tm_year+1900).toString().substring(2)},"%Y":function(date){return date.tm_year+1900},"%z":function(date){var off=date.tm_gmtoff;var ahead=off>=0;off=Math.abs(off)/60;off=off/60*100+off%60;return (ahead?"+":"-")+String("0000"+off).slice(-4)},"%Z":function(date){return date.tm_zone},"%%":function(){return "%"}};pattern=pattern.replace(/%%/g,"\0\0");for(var rule in EXPANSION_RULES_2){if(pattern.includes(rule)){pattern=pattern.replace(new RegExp(rule,"g"),EXPANSION_RULES_2[rule](date));}}pattern=pattern.replace(/\0\0/g,"%");var bytes=intArrayFromString(pattern,false);if(bytes.length>maxsize){return 0}writeArrayToMemory(bytes,s);return bytes.length-1}function _strftime_l(s,maxsize,format,tm){return _strftime(s,maxsize,format,tm)}function _v4_generate_JIT_code(){err("missing function: v4_generate_JIT_code");abort(-1);}var FSNode=function(parent,name,mode,rdev){if(!parent){parent=this;}this.parent=parent;this.mount=parent.mount;this.mounted=null;this.id=FS.nextInode++;this.name=name;this.mode=mode;this.node_ops={};this.stream_ops={};this.rdev=rdev;};var readMode=292|73;var writeMode=146;Object.defineProperties(FSNode.prototype,{read:{get:function(){return (this.mode&readMode)===readMode},set:function(val){val?this.mode|=readMode:this.mode&=~readMode;}},write:{get:function(){return (this.mode&writeMode)===writeMode},set:function(val){val?this.mode|=writeMode:this.mode&=~writeMode;}},isFolder:{get:function(){return FS.isDir(this.mode)}},isDevice:{get:function(){return FS.isChrdev(this.mode)}}});FS.FSNode=FSNode;FS.staticInit();embind_init_charCodes();BindingError=Module["BindingError"]=extendError(Error,"BindingError");InternalError=Module["InternalError"]=extendError(Error,"InternalError");init_emval();UnboundTypeError=Module["UnboundTypeError"]=extendError(Error,"UnboundTypeError");function intArrayFromString(stringy,dontAddNull,length){var len=length>0?length:lengthBytesUTF8(stringy)+1;var u8array=new Array(len);var numBytesWritten=stringToUTF8Array(stringy,u8array,0,u8array.length);if(dontAddNull)u8array.length=numBytesWritten;return u8array}function intArrayToString(array){var ret=[];for(var i=0;i<array.length;i++){var chr=array[i];if(chr>255){chr&=255;}ret.push(String.fromCharCode(chr));}return ret.join("")}var asmLibraryArg={"Pa":_BIO_free,"Ra":_BIO_new_mem_buf,"Ua":_CONF_modules_unload,"Q":_CRYPTO_free,"Xa":_ERR_reason_error_string,"Qa":_PEM_read_bio,"Ta":_PEM_write,"Ja":__ZN2hw6trezor12register_allEv,"ca":__ZN4epee13file_io_utils19load_file_to_stringERKNSt3__212basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEERS7_m,"ba":__ZN4epee13file_io_utils19save_string_to_fileERKNSt3__212basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEES9_,"La":__ZN5boost10filesystem6detail12current_pathEPNS_6system10error_codeE,"Ka":__ZN5boost10filesystem6detail18create_directoriesERKNS0_4pathEPNS_6system10error_codeE,"Ga":__ZN5boost10filesystem6detail5spaceERKNS0_4pathEPNS_6system10error_codeE,"Sa":__ZN5boost10filesystem6detail6removeERKNS0_4pathEPNS_6system10error_codeE,"aa":__ZN5boost10filesystem6detail6statusERKNS0_4pathEPNS_6system10error_codeE,"Ma":__ZN5boost10filesystem6detail9canonicalERKNS0_4pathES4_PNS_6system10error_codeE,"Oa":__ZN5boost10filesystem6detail9copy_fileERKNS0_4pathES4_jPNS_6system10error_codeE,"Na":__ZNK5boost10filesystem4path11parent_pathEv,"Wa":__ZNK5tools6Notify6notifyEPKcS2_z,"e":___assert_fail,"d":___cxa_allocate_exception,"m":___cxa_begin_catch,"W":___cxa_decrement_exception_refcount,"p":___cxa_end_catch,"b":___cxa_find_matching_catch_2,"g":___cxa_find_matching_catch_3,"x":___cxa_find_matching_catch_6,"Va":___cxa_find_matching_catch_7,"r":___cxa_free_exception,"V":___cxa_increment_exception_refcount,"da":___cxa_rethrow,"ea":___cxa_rethrow_primary_exception,"f":___cxa_throw,"fa":___cxa_uncaught_exceptions,"k":___resumeException,"z":___syscall_fcntl64,"ra":___syscall_fdatasync,"bb":___syscall_ftruncate64,"xa":___syscall_ioctl,"na":___syscall_mkdirat,"X":___syscall_openat,"ia":___syscall_renameat,"qa":___syscall_stat64,"cb":__embind_register_bigint,"za":__embind_register_bool,"ya":__embind_register_emval,"_":__embind_register_float,"t":__embind_register_function,"A":__embind_register_integer,"w":__embind_register_memory_view,"Z":__embind_register_std_string,"N":__embind_register_std_wstring,"Aa":__embind_register_void,"L":__emscripten_date_now,"sa":__emscripten_get_now_is_monotonic,"ja":__emscripten_get_progname,"Ea":__emval_call,"Fa":__emval_decref,"Da":__emval_equals,"$":__emval_incref,"Ca":__emval_take_value,"ta":__gmtime_js,"ua":__mktime_js,"ka":__mmap_js,"la":__msync_js,"ma":__munmap_js,"va":__tzset_js,"D":_abort,"ha":_emscripten_get_heap_max,"K":_emscripten_get_now,"ga":_emscripten_resize_heap,"oa":_environ_get,"pa":_environ_sizes_get,"R":_exit,"H":_fd_close,"$a":_fd_pwrite,"Y":_fd_read,"ab":_fd_seek,"M":_fd_write,"a":_getTempRet0,"S":invoke_diii,"T":invoke_fiii,"u":invoke_i,"i":invoke_ii,"c":invoke_iii,"o":invoke_iiii,"n":invoke_iiiii,"U":invoke_iiiiid,"C":invoke_iiiiii,"y":invoke_iiiiiii,"P":invoke_iiiiiiii,"Ha":invoke_iiiiiiiiii,"J":invoke_iiiiiiiiiiii,"Ya":invoke_iiiiij,"kb":invoke_iiiiiji,"lb":invoke_iiiiji,"sb":invoke_iij,"_a":invoke_j,"ub":invoke_ji,"ob":invoke_jii,"eb":invoke_jiii,"mb":invoke_jiiii,"gb":invoke_jiiiii,"l":invoke_v,"s":invoke_vi,"h":invoke_vii,"j":invoke_viii,"v":invoke_viiii,"E":invoke_viiiii,"O":invoke_viiiiii,"B":invoke_viiiiiii,"Ia":invoke_viiiiiiii,"G":invoke_viiiiiiiiii,"I":invoke_viiiiiiiiiiiiiii,"db":invoke_viiiji,"ib":invoke_viiijjjjii,"rb":invoke_viij,"Za":invoke_viijii,"vb":invoke_viijiii,"jb":invoke_viijjd,"tb":invoke_vij,"nb":invoke_viji,"qb":invoke_vijiii,"pb":invoke_vijiiii,"hb":invoke_vijiijii,"wb":js_send_binary_request,"xb":js_send_json_request,"q":_llvm_eh_typeid_for,"wa":_proc_exit,"fb":_rx_slow_hash,"F":_setTempRet0,"yb":_strftime_l,"Ba":_v4_generate_JIT_code};createWasm();Module["___wasm_call_ctors"]=function(){return (Module["___wasm_call_ctors"]=Module["asm"]["Ab"]).apply(null,arguments)};var _free=Module["_free"]=function(){return (_free=Module["_free"]=Module["asm"]["Bb"]).apply(null,arguments)};Module["__ZN5boost13serialization16singleton_module8get_lockEv"]=function(){return (Module["__ZN5boost13serialization16singleton_module8get_lockEv"]=Module["asm"]["Db"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN5tools7wallet210pending_txEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=function(){return (Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN5tools7wallet210pending_txEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=Module["asm"]["Eb"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN10cryptonote11transactionEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=function(){return (Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN10cryptonote11transactionEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=Module["asm"]["Fb"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveENSt3__26vectorINS_7variantIN10cryptonote8txin_genEJNS7_14txin_to_scriptENS7_18txin_to_scripthashENS7_11txin_to_keyEEEENS4_9allocatorISC_EEEEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=function(){return (Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveENSt3__26vectorINS_7variantIN10cryptonote8txin_genEJNS7_14txin_to_scriptENS7_18txin_to_scripthashENS7_11txin_to_keyEEEENS4_9allocatorISC_EEEEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=Module["asm"]["Gb"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveENS_7variantIN10cryptonote8txin_genEJNS5_14txin_to_scriptENS5_18txin_to_scripthashENS5_11txin_to_keyEEEEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=function(){return (Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveENS_7variantIN10cryptonote8txin_genEJNS5_14txin_to_scriptENS5_18txin_to_scripthashENS5_11txin_to_keyEEEEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=Module["asm"]["Hb"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN10cryptonote8txin_genEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=function(){return (Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN10cryptonote8txin_genEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=Module["asm"]["Ib"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN10cryptonote14txin_to_scriptEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=function(){return (Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN10cryptonote14txin_to_scriptEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=Module["asm"]["Jb"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN6crypto4hashEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=function(){return (Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN6crypto4hashEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=Module["asm"]["Kb"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN10cryptonote18txin_to_scripthashEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=function(){return (Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN10cryptonote18txin_to_scripthashEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=Module["asm"]["Lb"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN10cryptonote15txout_to_scriptEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=function(){return (Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN10cryptonote15txout_to_scriptEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=Module["asm"]["Mb"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveENSt3__26vectorIN6crypto10public_keyENS4_9allocatorIS7_EEEEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=function(){return (Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveENSt3__26vectorIN6crypto10public_keyENS4_9allocatorIS7_EEEEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=Module["asm"]["Nb"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN6crypto10public_keyEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=function(){return (Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN6crypto10public_keyEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=Module["asm"]["Ob"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN10cryptonote11txin_to_keyEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=function(){return (Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN10cryptonote11txin_to_keyEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=Module["asm"]["Pb"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveENSt3__26vectorIyNS4_9allocatorIyEEEEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=function(){return (Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveENSt3__26vectorIyNS4_9allocatorIyEEEEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=Module["asm"]["Qb"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN6crypto9key_imageEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=function(){return (Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN6crypto9key_imageEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=Module["asm"]["Rb"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveENSt3__26vectorIN10cryptonote6tx_outENS4_9allocatorIS7_EEEEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=function(){return (Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveENSt3__26vectorIN10cryptonote6tx_outENS4_9allocatorIS7_EEEEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=Module["asm"]["Sb"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN10cryptonote6tx_outEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=function(){return (Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN10cryptonote6tx_outEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=Module["asm"]["Tb"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveENS_7variantIN10cryptonote15txout_to_scriptEJNS5_19txout_to_scripthashENS5_12txout_to_keyENS5_19txout_to_tagged_keyEEEEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=function(){return (Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveENS_7variantIN10cryptonote15txout_to_scriptEJNS5_19txout_to_scripthashENS5_12txout_to_keyENS5_19txout_to_tagged_keyEEEEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=Module["asm"]["Ub"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN10cryptonote19txout_to_scripthashEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=function(){return (Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN10cryptonote19txout_to_scripthashEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=Module["asm"]["Vb"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN10cryptonote12txout_to_keyEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=function(){return (Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN10cryptonote12txout_to_keyEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=Module["asm"]["Wb"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN10cryptonote19txout_to_tagged_keyEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=function(){return (Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN10cryptonote19txout_to_tagged_keyEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=Module["asm"]["Xb"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN6crypto8view_tagEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=function(){return (Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN6crypto8view_tagEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=Module["asm"]["Yb"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveENSt3__26vectorIhNS4_9allocatorIhEEEEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=function(){return (Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveENSt3__26vectorIhNS4_9allocatorIhEEEEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=Module["asm"]["Zb"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveENSt3__26vectorINS5_IN6crypto9signatureENS4_9allocatorIS7_EEEENS8_ISA_EEEEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=function(){return (Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveENSt3__26vectorINS5_IN6crypto9signatureENS4_9allocatorIS7_EEEENS8_ISA_EEEEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=Module["asm"]["_b"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveENSt3__26vectorIN6crypto9signatureENS4_9allocatorIS7_EEEEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=function(){return (Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveENSt3__26vectorIN6crypto9signatureENS4_9allocatorIS7_EEEEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=Module["asm"]["$b"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN6crypto9signatureEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=function(){return (Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN6crypto9signatureEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=Module["asm"]["ac"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN3rct10rctSigBaseEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=function(){return (Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN3rct10rctSigBaseEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=Module["asm"]["bc"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveENSt3__26vectorIN3rct3keyENS4_9allocatorIS7_EEEEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=function(){return (Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveENSt3__26vectorIN3rct3keyENS4_9allocatorIS7_EEEEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=Module["asm"]["cc"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN3rct3keyEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=function(){return (Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN3rct3keyEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=Module["asm"]["dc"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveENSt3__26vectorIN3rct9ecdhTupleENS4_9allocatorIS7_EEEEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=function(){return (Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveENSt3__26vectorIN3rct9ecdhTupleENS4_9allocatorIS7_EEEEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=Module["asm"]["ec"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN3rct9ecdhTupleEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=function(){return (Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN3rct9ecdhTupleEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=Module["asm"]["fc"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN3rct14rctSigPrunableEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=function(){return (Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN3rct14rctSigPrunableEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=Module["asm"]["gc"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveENSt3__26vectorIN3rct8rangeSigENS4_9allocatorIS7_EEEEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=function(){return (Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveENSt3__26vectorIN3rct8rangeSigENS4_9allocatorIS7_EEEEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=Module["asm"]["hc"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN3rct8rangeSigEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=function(){return (Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN3rct8rangeSigEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=Module["asm"]["ic"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN3rct7boroSigEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=function(){return (Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN3rct7boroSigEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=Module["asm"]["jc"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveENSt3__26vectorIN3rct11BulletproofENS4_9allocatorIS7_EEEEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=function(){return (Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveENSt3__26vectorIN3rct11BulletproofENS4_9allocatorIS7_EEEEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=Module["asm"]["kc"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN3rct11BulletproofEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=function(){return (Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN3rct11BulletproofEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=Module["asm"]["lc"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveENSt3__26vectorIN3rct15BulletproofPlusENS4_9allocatorIS7_EEEEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=function(){return (Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveENSt3__26vectorIN3rct15BulletproofPlusENS4_9allocatorIS7_EEEEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=Module["asm"]["mc"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN3rct15BulletproofPlusEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=function(){return (Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN3rct15BulletproofPlusEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=Module["asm"]["nc"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveENSt3__26vectorIN3rct5mgSigENS4_9allocatorIS7_EEEEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=function(){return (Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveENSt3__26vectorIN3rct5mgSigENS4_9allocatorIS7_EEEEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=Module["asm"]["oc"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN3rct5mgSigEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=function(){return (Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN3rct5mgSigEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=Module["asm"]["pc"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveENSt3__26vectorINS5_IN3rct3keyENS4_9allocatorIS7_EEEENS8_ISA_EEEEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=function(){return (Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveENSt3__26vectorINS5_IN3rct3keyENS4_9allocatorIS7_EEEENS8_ISA_EEEEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=Module["asm"]["qc"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveENSt3__26vectorIN3rct5clsagENS4_9allocatorIS7_EEEEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=function(){return (Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveENSt3__26vectorIN3rct5clsagENS4_9allocatorIS7_EEEEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=Module["asm"]["rc"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN3rct5clsagEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=function(){return (Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN3rct5clsagEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=Module["asm"]["sc"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN10cryptonote20tx_destination_entryEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=function(){return (Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN10cryptonote20tx_destination_entryEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=Module["asm"]["tc"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN10cryptonote22account_public_addressEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=function(){return (Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN10cryptonote22account_public_addressEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=Module["asm"]["uc"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveENSt3__24listImNS4_9allocatorImEEEEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=function(){return (Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveENSt3__24listImNS4_9allocatorImEEEEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=Module["asm"]["vc"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN4epee7mlockedIN5tools8scrubbedIN6crypto9ec_scalarEEEEEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=function(){return (Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN4epee7mlockedIN5tools8scrubbedIN6crypto9ec_scalarEEEEEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=Module["asm"]["wc"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveENSt3__26vectorIN10cryptonote20tx_destination_entryENS4_9allocatorIS7_EEEEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=function(){return (Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveENSt3__26vectorIN10cryptonote20tx_destination_entryENS4_9allocatorIS7_EEEEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=Module["asm"]["xc"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN5tools7wallet220tx_construction_dataEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=function(){return (Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN5tools7wallet220tx_construction_dataEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=Module["asm"]["yc"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveENSt3__26vectorIN10cryptonote15tx_source_entryENS4_9allocatorIS7_EEEEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=function(){return (Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveENSt3__26vectorIN10cryptonote15tx_source_entryENS4_9allocatorIS7_EEEEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=Module["asm"]["zc"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN10cryptonote15tx_source_entryEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=function(){return (Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN10cryptonote15tx_source_entryEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=Module["asm"]["Ac"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveENSt3__26vectorINS4_4pairIyN3rct5ctkeyEEENS4_9allocatorIS9_EEEEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=function(){return (Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveENSt3__26vectorINS4_4pairIyN3rct5ctkeyEEENS4_9allocatorIS9_EEEEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=Module["asm"]["Bc"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveENSt3__24pairIyN3rct5ctkeyEEEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=function(){return (Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveENSt3__24pairIyN3rct5ctkeyEEEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=Module["asm"]["Cc"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN3rct5ctkeyEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=function(){return (Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN3rct5ctkeyEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=Module["asm"]["Dc"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN3rct14multisig_kLRkiEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=function(){return (Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN3rct14multisig_kLRkiEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=Module["asm"]["Ec"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveENSt3__23setIjNS4_4lessIjEENS4_9allocatorIjEEEEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=function(){return (Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveENSt3__23setIjNS4_4lessIjEENS4_9allocatorIjEEEEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=Module["asm"]["Fc"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN3rct9RCTConfigEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=function(){return (Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN3rct9RCTConfigEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=Module["asm"]["Gc"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveENSt3__26vectorIN4epee7mlockedIN5tools8scrubbedIN6crypto9ec_scalarEEEEENS4_9allocatorISD_EEEEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=function(){return (Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveENSt3__26vectorIN4epee7mlockedIN5tools8scrubbedIN6crypto9ec_scalarEEEEENS4_9allocatorISD_EEEEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=Module["asm"]["Hc"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveENSt3__26vectorImNS4_9allocatorImEEEEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=function(){return (Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveENSt3__26vectorImNS4_9allocatorImEEEEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=Module["asm"]["Ic"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveENSt3__26vectorIN5tools7wallet212multisig_sigENS4_9allocatorIS8_EEEEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=function(){return (Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveENSt3__26vectorIN5tools7wallet212multisig_sigENS4_9allocatorIS8_EEEEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=Module["asm"]["Jc"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN5tools7wallet212multisig_sigEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=function(){return (Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN5tools7wallet212multisig_sigEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=Module["asm"]["Kc"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN3rct6rctSigEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=function(){return (Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN3rct6rctSigEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=Module["asm"]["Lc"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveENSt3__213unordered_setIN6crypto10public_keyENS4_4hashIS7_EENS4_8equal_toIS7_EENS4_9allocatorIS7_EEEEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=function(){return (Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveENSt3__213unordered_setIN6crypto10public_keyENS4_4hashIS7_EENS4_8equal_toIS7_EENS4_9allocatorIS7_EEEEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=Module["asm"]["Mc"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveENSt3__213unordered_setIN3rct3keyENS4_4hashIS7_EENS4_8equal_toIS7_EENS4_9allocatorIS7_EEEEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=function(){return (Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveENSt3__213unordered_setIN3rct3keyENS4_4hashIS7_EENS4_8equal_toIS7_EENS4_9allocatorIS7_EEEEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=Module["asm"]["Nc"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN3rct12multisig_outEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=function(){return (Module["__ZNK5boost7archive6detail11oserializerINS0_24portable_binary_oarchiveEN3rct12multisig_outEE16save_object_dataERNS1_14basic_oarchiveEPKv"]=Module["asm"]["Oc"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN5tools7wallet210pending_txEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN5tools7wallet210pending_txEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Pc"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN10cryptonote11transactionEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN10cryptonote11transactionEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Qc"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorINS_7variantIN10cryptonote8txin_genEJNS7_14txin_to_scriptENS7_18txin_to_scripthashENS7_11txin_to_keyEEEENS4_9allocatorISC_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorINS_7variantIN10cryptonote8txin_genEJNS7_14txin_to_scriptENS7_18txin_to_scripthashENS7_11txin_to_keyEEEENS4_9allocatorISC_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Rc"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENS_7variantIN10cryptonote8txin_genEJNS5_14txin_to_scriptENS5_18txin_to_scripthashENS5_11txin_to_keyEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENS_7variantIN10cryptonote8txin_genEJNS5_14txin_to_scriptENS5_18txin_to_scripthashENS5_11txin_to_keyEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Sc"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN10cryptonote8txin_genEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN10cryptonote8txin_genEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Tc"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN10cryptonote14txin_to_scriptEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN10cryptonote14txin_to_scriptEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Uc"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN6crypto4hashEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN6crypto4hashEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Vc"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN10cryptonote18txin_to_scripthashEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN10cryptonote18txin_to_scripthashEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Wc"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN10cryptonote15txout_to_scriptEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN10cryptonote15txout_to_scriptEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Xc"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorIN6crypto10public_keyENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorIN6crypto10public_keyENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Yc"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN6crypto10public_keyEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN6crypto10public_keyEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Zc"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN10cryptonote11txin_to_keyEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN10cryptonote11txin_to_keyEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["_c"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorIyNS4_9allocatorIyEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorIyNS4_9allocatorIyEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["$c"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN6crypto9key_imageEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN6crypto9key_imageEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["ad"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorIN10cryptonote6tx_outENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorIN10cryptonote6tx_outENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["bd"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN10cryptonote6tx_outEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN10cryptonote6tx_outEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["cd"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENS_7variantIN10cryptonote15txout_to_scriptEJNS5_19txout_to_scripthashENS5_12txout_to_keyENS5_19txout_to_tagged_keyEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENS_7variantIN10cryptonote15txout_to_scriptEJNS5_19txout_to_scripthashENS5_12txout_to_keyENS5_19txout_to_tagged_keyEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["dd"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN10cryptonote19txout_to_scripthashEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN10cryptonote19txout_to_scripthashEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["ed"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN10cryptonote12txout_to_keyEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN10cryptonote12txout_to_keyEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["fd"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN10cryptonote19txout_to_tagged_keyEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN10cryptonote19txout_to_tagged_keyEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["gd"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN6crypto8view_tagEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN6crypto8view_tagEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["hd"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorIhNS4_9allocatorIhEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorIhNS4_9allocatorIhEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["id"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorINS5_IN6crypto9signatureENS4_9allocatorIS7_EEEENS8_ISA_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorINS5_IN6crypto9signatureENS4_9allocatorIS7_EEEENS8_ISA_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["jd"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorIN6crypto9signatureENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorIN6crypto9signatureENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["kd"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN6crypto9signatureEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN6crypto9signatureEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["ld"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN3rct10rctSigBaseEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN3rct10rctSigBaseEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["md"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorIN3rct3keyENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorIN3rct3keyENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["nd"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN3rct3keyEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN3rct3keyEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["od"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorIN3rct9ecdhTupleENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorIN3rct9ecdhTupleENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["pd"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN3rct9ecdhTupleEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN3rct9ecdhTupleEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["qd"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN3rct14rctSigPrunableEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN3rct14rctSigPrunableEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["rd"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorIN3rct8rangeSigENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorIN3rct8rangeSigENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["sd"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN3rct8rangeSigEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN3rct8rangeSigEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["td"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN3rct7boroSigEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN3rct7boroSigEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["ud"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorIN3rct11BulletproofENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorIN3rct11BulletproofENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["vd"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN3rct11BulletproofEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN3rct11BulletproofEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["wd"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorIN3rct15BulletproofPlusENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorIN3rct15BulletproofPlusENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["xd"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN3rct15BulletproofPlusEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN3rct15BulletproofPlusEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["yd"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorIN3rct5mgSigENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorIN3rct5mgSigENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["zd"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN3rct5mgSigEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN3rct5mgSigEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Ad"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorINS5_IN3rct3keyENS4_9allocatorIS7_EEEENS8_ISA_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorINS5_IN3rct3keyENS4_9allocatorIS7_EEEENS8_ISA_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Bd"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorIN3rct5clsagENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorIN3rct5clsagENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Cd"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN3rct5clsagEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN3rct5clsagEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Dd"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN10cryptonote20tx_destination_entryEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN10cryptonote20tx_destination_entryEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Ed"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN10cryptonote22account_public_addressEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN10cryptonote22account_public_addressEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Fd"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__24listImNS4_9allocatorImEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__24listImNS4_9allocatorImEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Gd"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN4epee7mlockedIN5tools8scrubbedIN6crypto9ec_scalarEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN4epee7mlockedIN5tools8scrubbedIN6crypto9ec_scalarEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Hd"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorIN10cryptonote20tx_destination_entryENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorIN10cryptonote20tx_destination_entryENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Id"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN5tools7wallet220tx_construction_dataEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN5tools7wallet220tx_construction_dataEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Jd"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorIN10cryptonote15tx_source_entryENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorIN10cryptonote15tx_source_entryENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Kd"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN10cryptonote15tx_source_entryEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN10cryptonote15tx_source_entryEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Ld"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorINS4_4pairIyN3rct5ctkeyEEENS4_9allocatorIS9_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorINS4_4pairIyN3rct5ctkeyEEENS4_9allocatorIS9_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Md"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__24pairIyN3rct5ctkeyEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__24pairIyN3rct5ctkeyEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Nd"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN3rct5ctkeyEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN3rct5ctkeyEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Od"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN3rct14multisig_kLRkiEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN3rct14multisig_kLRkiEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Pd"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__23setIjNS4_4lessIjEENS4_9allocatorIjEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__23setIjNS4_4lessIjEENS4_9allocatorIjEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Qd"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN3rct9RCTConfigEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN3rct9RCTConfigEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Rd"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorIN4epee7mlockedIN5tools8scrubbedIN6crypto9ec_scalarEEEEENS4_9allocatorISD_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorIN4epee7mlockedIN5tools8scrubbedIN6crypto9ec_scalarEEEEENS4_9allocatorISD_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Sd"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorImNS4_9allocatorImEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorImNS4_9allocatorImEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Td"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorIN5tools7wallet212multisig_sigENS4_9allocatorIS8_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorIN5tools7wallet212multisig_sigENS4_9allocatorIS8_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Ud"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN5tools7wallet212multisig_sigEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN5tools7wallet212multisig_sigEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Vd"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN3rct6rctSigEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN3rct6rctSigEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Wd"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__213unordered_setIN6crypto10public_keyENS4_4hashIS7_EENS4_8equal_toIS7_EENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__213unordered_setIN6crypto10public_keyENS4_4hashIS7_EENS4_8equal_toIS7_EENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Xd"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__213unordered_setIN3rct3keyENS4_4hashIS7_EENS4_8equal_toIS7_EENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__213unordered_setIN3rct3keyENS4_4hashIS7_EENS4_8equal_toIS7_EENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Yd"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN3rct12multisig_outEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN3rct12multisig_outEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Zd"]).apply(null,arguments)};var ___errno_location=Module["___errno_location"]=function(){return (___errno_location=Module["___errno_location"]=Module["asm"]["_d"]).apply(null,arguments)};var _malloc=Module["_malloc"]=function(){return (_malloc=Module["_malloc"]=Module["asm"]["$d"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN5tools7wallet2EE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN5tools7wallet2EE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["ae"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorIN6crypto4hashENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorIN6crypto4hashENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["be"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN5tools9hashchainEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN5tools9hashchainEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["ce"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__25dequeIN6crypto4hashENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__25dequeIN6crypto4hashENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["de"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorIN5tools7wallet216transfer_detailsENS4_9allocatorIS8_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorIN5tools7wallet216transfer_detailsENS4_9allocatorIS8_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["ee"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN5tools7wallet216transfer_detailsEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN5tools7wallet216transfer_detailsEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["fe"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN10cryptonote18transaction_prefixEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN10cryptonote18transaction_prefixEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["ge"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN10cryptonote16subaddress_indexEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN10cryptonote16subaddress_indexEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["he"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorINS4_4pairIyN6crypto4hashEEENS4_9allocatorIS9_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorINS4_4pairIyN6crypto4hashEEENS4_9allocatorIS9_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["ie"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__24pairIyN6crypto4hashEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__24pairIyN6crypto4hashEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["je"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__213unordered_mapIN6crypto9key_imageEmNS4_4hashIS7_EENS4_8equal_toIS7_EENS4_9allocatorINS4_4pairIKS7_mEEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__213unordered_mapIN6crypto9key_imageEmNS4_4hashIS7_EENS4_8equal_toIS7_EENS4_9allocatorINS4_4pairIKS7_mEEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["ke"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__213unordered_mapIN6crypto4hashEN5tools7wallet228unconfirmed_transfer_detailsENS4_4hashIS7_EENS4_8equal_toIS7_EENS4_9allocatorINS4_4pairIKS7_SA_EEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__213unordered_mapIN6crypto4hashEN5tools7wallet228unconfirmed_transfer_detailsENS4_4hashIS7_EENS4_8equal_toIS7_EENS4_9allocatorINS4_4pairIKS7_SA_EEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["le"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN5tools7wallet228unconfirmed_transfer_detailsEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN5tools7wallet228unconfirmed_transfer_detailsEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["me"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorINS4_4pairIN6crypto9key_imageENS5_IyNS4_9allocatorIyEEEEEENS9_ISC_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorINS4_4pairIN6crypto9key_imageENS5_IyNS4_9allocatorIyEEEEEENS9_ISC_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["ne"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__24pairIN6crypto9key_imageENS4_6vectorIyNS4_9allocatorIyEEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__24pairIN6crypto9key_imageENS4_6vectorIyNS4_9allocatorIyEEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["oe"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__218unordered_multimapIN6crypto4hashEN5tools7wallet215payment_detailsENS4_4hashIS7_EENS4_8equal_toIS7_EENS4_9allocatorINS4_4pairIKS7_SA_EEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__218unordered_multimapIN6crypto4hashEN5tools7wallet215payment_detailsENS4_4hashIS7_EENS4_8equal_toIS7_EENS4_9allocatorINS4_4pairIKS7_SA_EEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["pe"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN5tools7wallet215payment_detailsEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN5tools7wallet215payment_detailsEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["qe"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__213unordered_mapIN6crypto4hashEN4epee7mlockedIN5tools8scrubbedINS6_9ec_scalarEEEEENS4_4hashIS7_EENS4_8equal_toIS7_EENS4_9allocatorINS4_4pairIKS7_SE_EEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__213unordered_mapIN6crypto4hashEN4epee7mlockedIN5tools8scrubbedINS6_9ec_scalarEEEEENS4_4hashIS7_EENS4_8equal_toIS7_EENS4_9allocatorINS4_4pairIKS7_SE_EEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["re"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__213unordered_mapIN6crypto4hashEN5tools7wallet226confirmed_transfer_detailsENS4_4hashIS7_EENS4_8equal_toIS7_EENS4_9allocatorINS4_4pairIKS7_SA_EEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__213unordered_mapIN6crypto4hashEN5tools7wallet226confirmed_transfer_detailsENS4_4hashIS7_EENS4_8equal_toIS7_EENS4_9allocatorINS4_4pairIKS7_SA_EEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["se"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN5tools7wallet226confirmed_transfer_detailsEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN5tools7wallet226confirmed_transfer_detailsEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["te"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__213unordered_mapIN6crypto4hashENS4_12basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEENS4_4hashIS7_EENS4_8equal_toIS7_EENSB_INS4_4pairIKS7_SD_EEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__213unordered_mapIN6crypto4hashENS4_12basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEENS4_4hashIS7_EENS4_8equal_toIS7_EENSB_INS4_4pairIKS7_SD_EEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["ue"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__213unordered_mapIN6crypto4hashEN5tools7wallet215payment_detailsENS4_4hashIS7_EENS4_8equal_toIS7_EENS4_9allocatorINS4_4pairIKS7_SA_EEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__213unordered_mapIN6crypto4hashEN5tools7wallet215payment_detailsENS4_4hashIS7_EENS4_8equal_toIS7_EENS4_9allocatorINS4_4pairIKS7_SA_EEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["ve"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__213unordered_mapIN6crypto10public_keyEmNS4_4hashIS7_EENS4_8equal_toIS7_EENS4_9allocatorINS4_4pairIKS7_mEEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__213unordered_mapIN6crypto10public_keyEmNS4_4hashIS7_EENS4_8equal_toIS7_EENS4_9allocatorINS4_4pairIKS7_mEEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["we"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorIN5tools7wallet216address_book_rowENS4_9allocatorIS8_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorIN5tools7wallet216address_book_rowENS4_9allocatorIS8_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["xe"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN5tools7wallet216address_book_rowEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN5tools7wallet216address_book_rowEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["ye"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN6crypto5hash8EE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN6crypto5hash8EE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["ze"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__213unordered_setIN6crypto4hashENS4_4hashIS7_EENS4_8equal_toIS7_EENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__213unordered_setIN6crypto4hashENS4_4hashIS7_EENS4_8equal_toIS7_EENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Ae"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__213unordered_mapIN6crypto10public_keyEN10cryptonote16subaddress_indexENS4_4hashIS7_EENS4_8equal_toIS7_EENS4_9allocatorINS4_4pairIKS7_S9_EEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__213unordered_mapIN6crypto10public_keyEN10cryptonote16subaddress_indexENS4_4hashIS7_EENS4_8equal_toIS7_EENS4_9allocatorINS4_4pairIKS7_S9_EEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Be"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__213unordered_mapIN10cryptonote16subaddress_indexEN6crypto10public_keyENS4_4hashIS7_EENS4_8equal_toIS7_EENS4_9allocatorINS4_4pairIKS7_S9_EEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__213unordered_mapIN10cryptonote16subaddress_indexEN6crypto10public_keyENS4_4hashIS7_EENS4_8equal_toIS7_EENS4_9allocatorINS4_4pairIKS7_S9_EEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Ce"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorINS5_INS4_12basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEENS9_ISB_EEEENS9_ISD_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorINS5_INS4_12basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEENS9_ISB_EEEENS9_ISD_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["De"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorINS4_12basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEENS9_ISB_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorINS4_12basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEENS9_ISB_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Ee"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__213unordered_mapIN6crypto4hashENS4_6vectorIN4epee7mlockedIN5tools8scrubbedINS6_9ec_scalarEEEEENS4_9allocatorISF_EEEENS4_4hashIS7_EENS4_8equal_toIS7_EENSG_INS4_4pairIKS7_SI_EEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__213unordered_mapIN6crypto4hashENS4_6vectorIN4epee7mlockedIN5tools8scrubbedINS6_9ec_scalarEEEEENS4_9allocatorISF_EEEENS4_4hashIS7_EENS4_8equal_toIS7_EENSG_INS4_4pairIKS7_SI_EEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Fe"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__213unordered_mapINS4_12basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEESB_NS4_4hashISB_EENS4_8equal_toISB_EENS9_INS4_4pairIKSB_SB_EEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__213unordered_mapINS4_12basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEESB_NS4_4hashISB_EENS4_8equal_toISB_EENS9_INS4_4pairIKSB_SB_EEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Ge"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__218unordered_multimapIN6crypto4hashEN5tools7wallet220pool_payment_detailsENS4_4hashIS7_EENS4_8equal_toIS7_EENS4_9allocatorINS4_4pairIKS7_SA_EEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__218unordered_multimapIN6crypto4hashEN5tools7wallet220pool_payment_detailsENS4_4hashIS7_EENS4_8equal_toIS7_EENS4_9allocatorINS4_4pairIKS7_SA_EEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["He"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN5tools7wallet220pool_payment_detailsEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN5tools7wallet220pool_payment_detailsEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Ie"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__24pairINS4_3mapINS4_12basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEESC_NS4_4lessISC_EENSA_INS5_IKSC_SC_EEEEEENS4_6vectorISC_NSA_ISC_EEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__24pairINS4_3mapINS4_12basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEESC_NS4_4lessISC_EENSA_INS5_IKSC_SC_EEEEEENS4_6vectorISC_NSA_ISC_EEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Je"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__23mapINS4_12basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEESB_NS4_4lessISB_EENS9_INS4_4pairIKSB_SB_EEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__23mapINS4_12basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEESB_NS4_4lessISB_EENS9_INS4_4pairIKSB_SB_EEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Ke"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__24pairIKNS4_12basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEESB_EEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__24pairIKNS4_12basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEESB_EEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Le"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__213unordered_mapIN6crypto10public_keyENS6_9key_imageENS4_4hashIS7_EENS4_8equal_toIS7_EENS4_9allocatorINS4_4pairIKS7_S8_EEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__213unordered_mapIN6crypto10public_keyENS6_9key_imageENS4_4hashIS7_EENS4_8equal_toIS7_EENS4_9allocatorINS4_4pairIKS7_S8_EEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Me"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN5tools7wallet2EE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN5tools7wallet2EE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Ne"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__26vectorIN6crypto4hashENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__26vectorIN6crypto4hashENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Oe"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN6crypto4hashEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN6crypto4hashEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Pe"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN5tools9hashchainEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN5tools9hashchainEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Qe"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__25dequeIN6crypto4hashENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__25dequeIN6crypto4hashENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Re"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__26vectorIN5tools7wallet216transfer_detailsENS4_9allocatorIS8_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__26vectorIN5tools7wallet216transfer_detailsENS4_9allocatorIS8_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Se"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN5tools7wallet216transfer_detailsEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN5tools7wallet216transfer_detailsEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Te"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN10cryptonote11transactionEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN10cryptonote11transactionEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Ue"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__26vectorINS_7variantIN10cryptonote8txin_genEJNS7_14txin_to_scriptENS7_18txin_to_scripthashENS7_11txin_to_keyEEEENS4_9allocatorISC_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__26vectorINS_7variantIN10cryptonote8txin_genEJNS7_14txin_to_scriptENS7_18txin_to_scripthashENS7_11txin_to_keyEEEENS4_9allocatorISC_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Ve"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENS_7variantIN10cryptonote8txin_genEJNS5_14txin_to_scriptENS5_18txin_to_scripthashENS5_11txin_to_keyEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENS_7variantIN10cryptonote8txin_genEJNS5_14txin_to_scriptENS5_18txin_to_scripthashENS5_11txin_to_keyEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["We"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN10cryptonote8txin_genEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN10cryptonote8txin_genEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Xe"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN10cryptonote14txin_to_scriptEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN10cryptonote14txin_to_scriptEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Ye"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN10cryptonote18txin_to_scripthashEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN10cryptonote18txin_to_scripthashEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Ze"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN10cryptonote15txout_to_scriptEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN10cryptonote15txout_to_scriptEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["_e"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__26vectorIN6crypto10public_keyENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__26vectorIN6crypto10public_keyENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["$e"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN6crypto10public_keyEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN6crypto10public_keyEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["af"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN10cryptonote11txin_to_keyEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN10cryptonote11txin_to_keyEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["bf"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__26vectorIyNS4_9allocatorIyEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__26vectorIyNS4_9allocatorIyEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["cf"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__26vectorIN10cryptonote6tx_outENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__26vectorIN10cryptonote6tx_outENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["df"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN10cryptonote6tx_outEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN10cryptonote6tx_outEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["ef"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENS_7variantIN10cryptonote15txout_to_scriptEJNS5_19txout_to_scripthashENS5_12txout_to_keyENS5_19txout_to_tagged_keyEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENS_7variantIN10cryptonote15txout_to_scriptEJNS5_19txout_to_scripthashENS5_12txout_to_keyENS5_19txout_to_tagged_keyEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["ff"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN10cryptonote19txout_to_scripthashEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN10cryptonote19txout_to_scripthashEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["gf"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN10cryptonote12txout_to_keyEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN10cryptonote12txout_to_keyEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["hf"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN10cryptonote19txout_to_tagged_keyEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN10cryptonote19txout_to_tagged_keyEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["jf"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN6crypto8view_tagEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN6crypto8view_tagEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["kf"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__26vectorIhNS4_9allocatorIhEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__26vectorIhNS4_9allocatorIhEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["lf"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__26vectorINS5_IN6crypto9signatureENS4_9allocatorIS7_EEEENS8_ISA_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__26vectorINS5_IN6crypto9signatureENS4_9allocatorIS7_EEEENS8_ISA_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["mf"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__26vectorIN6crypto9signatureENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__26vectorIN6crypto9signatureENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["nf"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN6crypto9signatureEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN6crypto9signatureEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["of"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN3rct10rctSigBaseEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN3rct10rctSigBaseEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["pf"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__26vectorIN3rct9ecdhTupleENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__26vectorIN3rct9ecdhTupleENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["qf"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN3rct9ecdhTupleEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN3rct9ecdhTupleEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["rf"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN3rct14rctSigPrunableEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN3rct14rctSigPrunableEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["sf"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__26vectorIN3rct8rangeSigENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__26vectorIN3rct8rangeSigENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["tf"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN3rct8rangeSigEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN3rct8rangeSigEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["uf"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN3rct7boroSigEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN3rct7boroSigEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["vf"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN3rct3keyEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN3rct3keyEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["wf"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__26vectorIN3rct11BulletproofENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__26vectorIN3rct11BulletproofENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["xf"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN3rct11BulletproofEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN3rct11BulletproofEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["yf"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__26vectorIN3rct15BulletproofPlusENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__26vectorIN3rct15BulletproofPlusENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["zf"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN3rct15BulletproofPlusEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN3rct15BulletproofPlusEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Af"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__26vectorIN3rct5mgSigENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__26vectorIN3rct5mgSigENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Bf"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN3rct5mgSigEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN3rct5mgSigEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Cf"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__26vectorINS5_IN3rct3keyENS4_9allocatorIS7_EEEENS8_ISA_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__26vectorINS5_IN3rct3keyENS4_9allocatorIS7_EEEENS8_ISA_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Df"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__26vectorIN3rct3keyENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__26vectorIN3rct3keyENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Ef"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__26vectorIN3rct5clsagENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__26vectorIN3rct5clsagENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Ff"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN3rct5clsagEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN3rct5clsagEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Gf"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN10cryptonote18transaction_prefixEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN10cryptonote18transaction_prefixEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Hf"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN6crypto9key_imageEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN6crypto9key_imageEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["If"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN10cryptonote16subaddress_indexEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN10cryptonote16subaddress_indexEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Jf"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__26vectorIN5tools7wallet213multisig_infoENS4_9allocatorIS8_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__26vectorIN5tools7wallet213multisig_infoENS4_9allocatorIS8_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Kf"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN5tools7wallet213multisig_infoEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN5tools7wallet213multisig_infoEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Lf"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__26vectorIN5tools7wallet213multisig_info2LRENS4_9allocatorIS9_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__26vectorIN5tools7wallet213multisig_info2LRENS4_9allocatorIS9_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Mf"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN5tools7wallet213multisig_info2LREE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN5tools7wallet213multisig_info2LREE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Nf"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__26vectorIN6crypto9key_imageENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__26vectorIN6crypto9key_imageENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Of"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__26vectorINS4_4pairIyN6crypto4hashEEENS4_9allocatorIS9_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__26vectorINS4_4pairIyN6crypto4hashEEENS4_9allocatorIS9_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Pf"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__24pairIyN6crypto4hashEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__24pairIyN6crypto4hashEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Qf"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN10cryptonote22account_public_addressEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN10cryptonote22account_public_addressEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Rf"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__213unordered_mapIN6crypto9key_imageEmNS4_4hashIS7_EENS4_8equal_toIS7_EENS4_9allocatorINS4_4pairIKS7_mEEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__213unordered_mapIN6crypto9key_imageEmNS4_4hashIS7_EENS4_8equal_toIS7_EENS4_9allocatorINS4_4pairIKS7_mEEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Sf"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__213unordered_mapIN6crypto4hashEN5tools7wallet228unconfirmed_transfer_detailsENS4_4hashIS7_EENS4_8equal_toIS7_EENS4_9allocatorINS4_4pairIKS7_SA_EEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__213unordered_mapIN6crypto4hashEN5tools7wallet228unconfirmed_transfer_detailsENS4_4hashIS7_EENS4_8equal_toIS7_EENS4_9allocatorINS4_4pairIKS7_SA_EEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Tf"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN5tools7wallet228unconfirmed_transfer_detailsEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN5tools7wallet228unconfirmed_transfer_detailsEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Uf"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__26vectorIN10cryptonote20tx_destination_entryENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__26vectorIN10cryptonote20tx_destination_entryENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Vf"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN10cryptonote20tx_destination_entryEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN10cryptonote20tx_destination_entryEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Wf"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__23setIjNS4_4lessIjEENS4_9allocatorIjEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__23setIjNS4_4lessIjEENS4_9allocatorIjEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Xf"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__26vectorINS4_4pairIN6crypto9key_imageENS5_IyNS4_9allocatorIyEEEEEENS9_ISC_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__26vectorINS4_4pairIN6crypto9key_imageENS5_IyNS4_9allocatorIyEEEEEENS9_ISC_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Yf"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__24pairIN6crypto9key_imageENS4_6vectorIyNS4_9allocatorIyEEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__24pairIN6crypto9key_imageENS4_6vectorIyNS4_9allocatorIyEEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Zf"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__218unordered_multimapIN6crypto4hashEN5tools7wallet215payment_detailsENS4_4hashIS7_EENS4_8equal_toIS7_EENS4_9allocatorINS4_4pairIKS7_SA_EEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__218unordered_multimapIN6crypto4hashEN5tools7wallet215payment_detailsENS4_4hashIS7_EENS4_8equal_toIS7_EENS4_9allocatorINS4_4pairIKS7_SA_EEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["_f"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN5tools7wallet215payment_detailsEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN5tools7wallet215payment_detailsEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["$f"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__213unordered_mapIN6crypto4hashEN4epee7mlockedIN5tools8scrubbedINS6_9ec_scalarEEEEENS4_4hashIS7_EENS4_8equal_toIS7_EENS4_9allocatorINS4_4pairIKS7_SE_EEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__213unordered_mapIN6crypto4hashEN4epee7mlockedIN5tools8scrubbedINS6_9ec_scalarEEEEENS4_4hashIS7_EENS4_8equal_toIS7_EENS4_9allocatorINS4_4pairIKS7_SE_EEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["ag"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN4epee7mlockedIN5tools8scrubbedIN6crypto9ec_scalarEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN4epee7mlockedIN5tools8scrubbedIN6crypto9ec_scalarEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["bg"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__213unordered_mapIN6crypto4hashEN5tools7wallet226confirmed_transfer_detailsENS4_4hashIS7_EENS4_8equal_toIS7_EENS4_9allocatorINS4_4pairIKS7_SA_EEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__213unordered_mapIN6crypto4hashEN5tools7wallet226confirmed_transfer_detailsENS4_4hashIS7_EENS4_8equal_toIS7_EENS4_9allocatorINS4_4pairIKS7_SA_EEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["cg"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN5tools7wallet226confirmed_transfer_detailsEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN5tools7wallet226confirmed_transfer_detailsEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["dg"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__213unordered_mapIN6crypto4hashENS4_12basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEENS4_4hashIS7_EENS4_8equal_toIS7_EENSB_INS4_4pairIKS7_SD_EEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__213unordered_mapIN6crypto4hashENS4_12basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEENS4_4hashIS7_EENS4_8equal_toIS7_EENSB_INS4_4pairIKS7_SD_EEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["eg"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__213unordered_mapIN6crypto4hashEN5tools7wallet215payment_detailsENS4_4hashIS7_EENS4_8equal_toIS7_EENS4_9allocatorINS4_4pairIKS7_SA_EEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__213unordered_mapIN6crypto4hashEN5tools7wallet215payment_detailsENS4_4hashIS7_EENS4_8equal_toIS7_EENS4_9allocatorINS4_4pairIKS7_SA_EEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["fg"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__213unordered_mapIN6crypto10public_keyEmNS4_4hashIS7_EENS4_8equal_toIS7_EENS4_9allocatorINS4_4pairIKS7_mEEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__213unordered_mapIN6crypto10public_keyEmNS4_4hashIS7_EENS4_8equal_toIS7_EENS4_9allocatorINS4_4pairIKS7_mEEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["gg"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__26vectorIN5tools7wallet216address_book_rowENS4_9allocatorIS8_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__26vectorIN5tools7wallet216address_book_rowENS4_9allocatorIS8_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["hg"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN5tools7wallet216address_book_rowEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN5tools7wallet216address_book_rowEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["ig"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN6crypto5hash8EE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN6crypto5hash8EE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["jg"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__213unordered_setIN6crypto4hashENS4_4hashIS7_EENS4_8equal_toIS7_EENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__213unordered_setIN6crypto4hashENS4_4hashIS7_EENS4_8equal_toIS7_EENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["kg"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__213unordered_mapIN6crypto10public_keyEN10cryptonote16subaddress_indexENS4_4hashIS7_EENS4_8equal_toIS7_EENS4_9allocatorINS4_4pairIKS7_S9_EEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__213unordered_mapIN6crypto10public_keyEN10cryptonote16subaddress_indexENS4_4hashIS7_EENS4_8equal_toIS7_EENS4_9allocatorINS4_4pairIKS7_S9_EEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["lg"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__213unordered_mapIN10cryptonote16subaddress_indexEN6crypto10public_keyENS4_4hashIS7_EENS4_8equal_toIS7_EENS4_9allocatorINS4_4pairIKS7_S9_EEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__213unordered_mapIN10cryptonote16subaddress_indexEN6crypto10public_keyENS4_4hashIS7_EENS4_8equal_toIS7_EENS4_9allocatorINS4_4pairIKS7_S9_EEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["mg"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__26vectorINS5_INS4_12basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEENS9_ISB_EEEENS9_ISD_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__26vectorINS5_INS4_12basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEENS9_ISB_EEEENS9_ISD_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["ng"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__26vectorINS4_12basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEENS9_ISB_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__26vectorINS4_12basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEENS9_ISB_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["og"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__213unordered_mapIN6crypto4hashENS4_6vectorIN4epee7mlockedIN5tools8scrubbedINS6_9ec_scalarEEEEENS4_9allocatorISF_EEEENS4_4hashIS7_EENS4_8equal_toIS7_EENSG_INS4_4pairIKS7_SI_EEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__213unordered_mapIN6crypto4hashENS4_6vectorIN4epee7mlockedIN5tools8scrubbedINS6_9ec_scalarEEEEENS4_9allocatorISF_EEEENS4_4hashIS7_EENS4_8equal_toIS7_EENSG_INS4_4pairIKS7_SI_EEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["pg"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__26vectorIN4epee7mlockedIN5tools8scrubbedIN6crypto9ec_scalarEEEEENS4_9allocatorISD_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__26vectorIN4epee7mlockedIN5tools8scrubbedIN6crypto9ec_scalarEEEEENS4_9allocatorISD_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["qg"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__213unordered_mapINS4_12basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEESB_NS4_4hashISB_EENS4_8equal_toISB_EENS9_INS4_4pairIKSB_SB_EEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__213unordered_mapINS4_12basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEESB_NS4_4hashISB_EENS4_8equal_toISB_EENS9_INS4_4pairIKSB_SB_EEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["rg"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__218unordered_multimapIN6crypto4hashEN5tools7wallet220pool_payment_detailsENS4_4hashIS7_EENS4_8equal_toIS7_EENS4_9allocatorINS4_4pairIKS7_SA_EEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__218unordered_multimapIN6crypto4hashEN5tools7wallet220pool_payment_detailsENS4_4hashIS7_EENS4_8equal_toIS7_EENS4_9allocatorINS4_4pairIKS7_SA_EEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["sg"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN5tools7wallet220pool_payment_detailsEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveEN5tools7wallet220pool_payment_detailsEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["tg"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__24pairINS4_3mapINS4_12basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEESC_NS4_4lessISC_EENSA_INS5_IKSC_SC_EEEEEENS4_6vectorISC_NSA_ISC_EEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__24pairINS4_3mapINS4_12basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEESC_NS4_4lessISC_EENSA_INS5_IKSC_SC_EEEEEENS4_6vectorISC_NSA_ISC_EEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["ug"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__23mapINS4_12basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEESB_NS4_4lessISB_EENS9_INS4_4pairIKSB_SB_EEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__23mapINS4_12basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEESB_NS4_4lessISB_EENS9_INS4_4pairIKSB_SB_EEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["vg"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__24pairIKNS4_12basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEESB_EEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__24pairIKNS4_12basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEESB_EEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["wg"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__213unordered_mapIN6crypto10public_keyENS6_9key_imageENS4_4hashIS7_EENS4_8equal_toIS7_EENS4_9allocatorINS4_4pairIKS7_S8_EEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_15binary_iarchiveENSt3__213unordered_mapIN6crypto10public_keyENS6_9key_imageENS4_4hashIS7_EENS4_8equal_toIS7_EENS4_9allocatorINS4_4pairIKS7_S8_EEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["xg"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN5tools7wallet215unsigned_tx_setEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN5tools7wallet215unsigned_tx_setEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["yg"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorIN5tools7wallet220tx_construction_dataENS4_9allocatorIS8_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorIN5tools7wallet220tx_construction_dataENS4_9allocatorIS8_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["zg"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__24pairImNS4_6vectorIN5tools7wallet216transfer_detailsENS4_9allocatorIS9_EEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__24pairImNS4_6vectorIN5tools7wallet216transfer_detailsENS4_9allocatorIS9_EEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Ag"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN5tools7wallet213signed_tx_setEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN5tools7wallet213signed_tx_setEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Bg"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorIN5tools7wallet210pending_txENS4_9allocatorIS8_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorIN5tools7wallet210pending_txENS4_9allocatorIS8_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Cg"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorIN6crypto9key_imageENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorIN6crypto9key_imageENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Dg"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN5tools7wallet215multisig_tx_setEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN5tools7wallet215multisig_tx_setEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Eg"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorIN5tools7wallet219reserve_proof_entryENS4_9allocatorIS8_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorIN5tools7wallet219reserve_proof_entryENS4_9allocatorIS8_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Fg"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN5tools7wallet219reserve_proof_entryEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN5tools7wallet219reserve_proof_entryEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Gg"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__213unordered_mapIN6crypto10public_keyENS6_9signatureENS4_4hashIS7_EENS4_8equal_toIS7_EENS4_9allocatorINS4_4pairIKS7_S8_EEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__213unordered_mapIN6crypto10public_keyENS6_9signatureENS4_4hashIS7_EENS4_8equal_toIS7_EENS4_9allocatorINS4_4pairIKS7_S8_EEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Hg"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__24pairIyNS4_6vectorIN5tools7wallet216transfer_detailsENS4_9allocatorIS9_EEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__24pairIyNS4_6vectorIN5tools7wallet216transfer_detailsENS4_9allocatorIS9_EEEEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Ig"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorIN5tools7wallet213multisig_infoENS4_9allocatorIS8_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorIN5tools7wallet213multisig_infoENS4_9allocatorIS8_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Jg"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN5tools7wallet213multisig_infoEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN5tools7wallet213multisig_infoEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Kg"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorIN5tools7wallet213multisig_info2LRENS4_9allocatorIS9_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorIN5tools7wallet213multisig_info2LRENS4_9allocatorIS9_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Lg"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN5tools7wallet213multisig_info2LREE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN5tools7wallet213multisig_info2LREE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Mg"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN3mms9file_dataEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN3mms9file_dataEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Ng"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN6crypto9chacha_ivEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN6crypto9chacha_ivEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Og"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN3mms13message_storeEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN3mms13message_storeEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Pg"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorIN3mms17authorized_signerENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorIN3mms17authorized_signerENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Qg"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN3mms17authorized_signerEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN3mms17authorized_signerEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Rg"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorIN3mms7messageENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveENSt3__26vectorIN3mms7messageENS4_9allocatorIS7_EEEEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Sg"]).apply(null,arguments)};Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN3mms7messageEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=function(){return (Module["__ZNK5boost7archive6detail11iserializerINS0_24portable_binary_iarchiveEN3mms7messageEE16load_object_dataERNS1_14basic_iarchiveEPvj"]=Module["asm"]["Tg"]).apply(null,arguments)};var ___getTypeName=Module["___getTypeName"]=function(){return (___getTypeName=Module["___getTypeName"]=Module["asm"]["Ug"]).apply(null,arguments)};Module["___embind_register_native_and_builtin_types"]=function(){return (Module["___embind_register_native_and_builtin_types"]=Module["asm"]["Vg"]).apply(null,arguments)};var _emscripten_builtin_memalign=Module["_emscripten_builtin_memalign"]=function(){return (_emscripten_builtin_memalign=Module["_emscripten_builtin_memalign"]=Module["asm"]["Wg"]).apply(null,arguments)};var _setThrew=Module["_setThrew"]=function(){return (_setThrew=Module["_setThrew"]=Module["asm"]["Xg"]).apply(null,arguments)};var stackSave=Module["stackSave"]=function(){return (stackSave=Module["stackSave"]=Module["asm"]["Yg"]).apply(null,arguments)};var stackRestore=Module["stackRestore"]=function(){return (stackRestore=Module["stackRestore"]=Module["asm"]["Zg"]).apply(null,arguments)};var ___cxa_can_catch=Module["___cxa_can_catch"]=function(){return (___cxa_can_catch=Module["___cxa_can_catch"]=Module["asm"]["_g"]).apply(null,arguments)};var ___cxa_is_pointer_type=Module["___cxa_is_pointer_type"]=function(){return (___cxa_is_pointer_type=Module["___cxa_is_pointer_type"]=Module["asm"]["$g"]).apply(null,arguments)};var dynCall_ii=Module["dynCall_ii"]=function(){return (dynCall_ii=Module["dynCall_ii"]=Module["asm"]["ah"]).apply(null,arguments)};var dynCall_vi=Module["dynCall_vi"]=function(){return (dynCall_vi=Module["dynCall_vi"]=Module["asm"]["bh"]).apply(null,arguments)};var dynCall_iii=Module["dynCall_iii"]=function(){return (dynCall_iii=Module["dynCall_iii"]=Module["asm"]["ch"]).apply(null,arguments)};var dynCall_vii=Module["dynCall_vii"]=function(){return (dynCall_vii=Module["dynCall_vii"]=Module["asm"]["dh"]).apply(null,arguments)};var dynCall_v=Module["dynCall_v"]=function(){return (dynCall_v=Module["dynCall_v"]=Module["asm"]["eh"]).apply(null,arguments)};var dynCall_viiiii=Module["dynCall_viiiii"]=function(){return (dynCall_viiiii=Module["dynCall_viiiii"]=Module["asm"]["fh"]).apply(null,arguments)};var dynCall_iij=Module["dynCall_iij"]=function(){return (dynCall_iij=Module["dynCall_iij"]=Module["asm"]["gh"]).apply(null,arguments)};Module["dynCall_iiiiijii"]=function(){return (Module["dynCall_iiiiijii"]=Module["asm"]["hh"]).apply(null,arguments)};Module["dynCall_iiijiii"]=function(){return (Module["dynCall_iiijiii"]=Module["asm"]["ih"]).apply(null,arguments)};Module["dynCall_iiiijii"]=function(){return (Module["dynCall_iiiijii"]=Module["asm"]["jh"]).apply(null,arguments)};var dynCall_ji=Module["dynCall_ji"]=function(){return (dynCall_ji=Module["dynCall_ji"]=Module["asm"]["kh"]).apply(null,arguments)};var dynCall_viii=Module["dynCall_viii"]=function(){return (dynCall_viii=Module["dynCall_viii"]=Module["asm"]["lh"]).apply(null,arguments)};var dynCall_iiii=Module["dynCall_iiii"]=function(){return (dynCall_iiii=Module["dynCall_iiii"]=Module["asm"]["mh"]).apply(null,arguments)};var dynCall_iiiii=Module["dynCall_iiiii"]=function(){return (dynCall_iiiii=Module["dynCall_iiiii"]=Module["asm"]["nh"]).apply(null,arguments)};var dynCall_viijiii=Module["dynCall_viijiii"]=function(){return (dynCall_viijiii=Module["dynCall_viijiii"]=Module["asm"]["oh"]).apply(null,arguments)};var dynCall_viiii=Module["dynCall_viiii"]=function(){return (dynCall_viiii=Module["dynCall_viiii"]=Module["asm"]["ph"]).apply(null,arguments)};var dynCall_vij=Module["dynCall_vij"]=function(){return (dynCall_vij=Module["dynCall_vij"]=Module["asm"]["qh"]).apply(null,arguments)};var dynCall_jiiii=Module["dynCall_jiiii"]=function(){return (dynCall_jiiii=Module["dynCall_jiiii"]=Module["asm"]["rh"]).apply(null,arguments)};var dynCall_viij=Module["dynCall_viij"]=function(){return (dynCall_viij=Module["dynCall_viij"]=Module["asm"]["sh"]).apply(null,arguments)};Module["dynCall_viiji"]=function(){return (Module["dynCall_viiji"]=Module["asm"]["th"]).apply(null,arguments)};var dynCall_jii=Module["dynCall_jii"]=function(){return (dynCall_jii=Module["dynCall_jii"]=Module["asm"]["uh"]).apply(null,arguments)};var dynCall_jiii=Module["dynCall_jiii"]=function(){return (dynCall_jiii=Module["dynCall_jiii"]=Module["asm"]["vh"]).apply(null,arguments)};var dynCall_viiiiii=Module["dynCall_viiiiii"]=function(){return (dynCall_viiiiii=Module["dynCall_viiiiii"]=Module["asm"]["wh"]).apply(null,arguments)};var dynCall_viiiji=Module["dynCall_viiiji"]=function(){return (dynCall_viiiji=Module["dynCall_viiiji"]=Module["asm"]["xh"]).apply(null,arguments)};var dynCall_vijiiii=Module["dynCall_vijiiii"]=function(){return (dynCall_vijiiii=Module["dynCall_vijiiii"]=Module["asm"]["yh"]).apply(null,arguments)};Module["dynCall_iiiiiiiii"]=function(){return (Module["dynCall_iiiiiiiii"]=Module["asm"]["zh"]).apply(null,arguments)};var dynCall_iiiiii=Module["dynCall_iiiiii"]=function(){return (dynCall_iiiiii=Module["dynCall_iiiiii"]=Module["asm"]["Ah"]).apply(null,arguments)};Module["dynCall_vijjjdi"]=function(){return (Module["dynCall_vijjjdi"]=Module["asm"]["Bh"]).apply(null,arguments)};Module["dynCall_vijj"]=function(){return (Module["dynCall_vijj"]=Module["asm"]["Ch"]).apply(null,arguments)};var dynCall_viji=Module["dynCall_viji"]=function(){return (dynCall_viji=Module["dynCall_viji"]=Module["asm"]["Dh"]).apply(null,arguments)};Module["dynCall_vijiijjiij"]=function(){return (Module["dynCall_vijiijjiij"]=Module["asm"]["Eh"]).apply(null,arguments)};Module["dynCall_vijiiji"]=function(){return (Module["dynCall_vijiiji"]=Module["asm"]["Fh"]).apply(null,arguments)};var dynCall_vijiijii=Module["dynCall_vijiijii"]=function(){return (dynCall_vijiijii=Module["dynCall_vijiijii"]=Module["asm"]["Gh"]).apply(null,arguments)};Module["dynCall_vijii"]=function(){return (Module["dynCall_vijii"]=Module["asm"]["Hh"]).apply(null,arguments)};Module["dynCall_vijij"]=function(){return (Module["dynCall_vijij"]=Module["asm"]["Ih"]).apply(null,arguments)};var dynCall_i=Module["dynCall_i"]=function(){return (dynCall_i=Module["dynCall_i"]=Module["asm"]["Jh"]).apply(null,arguments)};var dynCall_vijiii=Module["dynCall_vijiii"]=function(){return (dynCall_vijiii=Module["dynCall_vijiii"]=Module["asm"]["Kh"]).apply(null,arguments)};var dynCall_viijii=Module["dynCall_viijii"]=function(){return (dynCall_viijii=Module["dynCall_viijii"]=Module["asm"]["Lh"]).apply(null,arguments)};var dynCall_viiiiiiii=Module["dynCall_viiiiiiii"]=function(){return (dynCall_viiiiiiii=Module["dynCall_viiiiiiii"]=Module["asm"]["Mh"]).apply(null,arguments)};var dynCall_iiiiiiii=Module["dynCall_iiiiiiii"]=function(){return (dynCall_iiiiiiii=Module["dynCall_iiiiiiii"]=Module["asm"]["Nh"]).apply(null,arguments)};var dynCall_iiiiji=Module["dynCall_iiiiji"]=function(){return (dynCall_iiiiji=Module["dynCall_iiiiji"]=Module["asm"]["Oh"]).apply(null,arguments)};var dynCall_iiiiiji=Module["dynCall_iiiiiji"]=function(){return (dynCall_iiiiiji=Module["dynCall_iiiiiji"]=Module["asm"]["Ph"]).apply(null,arguments)};var dynCall_viijjd=Module["dynCall_viijjd"]=function(){return (dynCall_viijjd=Module["dynCall_viijjd"]=Module["asm"]["Qh"]).apply(null,arguments)};var dynCall_viiijjjjii=Module["dynCall_viiijjjjii"]=function(){return (dynCall_viiijjjjii=Module["dynCall_viiijjjjii"]=Module["asm"]["Rh"]).apply(null,arguments)};var dynCall_jiiiii=Module["dynCall_jiiiii"]=function(){return (dynCall_jiiiii=Module["dynCall_jiiiii"]=Module["asm"]["Sh"]).apply(null,arguments)};var dynCall_iiiiiiiiii=Module["dynCall_iiiiiiiiii"]=function(){return (dynCall_iiiiiiiiii=Module["dynCall_iiiiiiiiii"]=Module["asm"]["Th"]).apply(null,arguments)};var dynCall_iiiiiii=Module["dynCall_iiiiiii"]=function(){return (dynCall_iiiiiii=Module["dynCall_iiiiiii"]=Module["asm"]["Uh"]).apply(null,arguments)};Module["dynCall_viiiiiiiii"]=function(){return (Module["dynCall_viiiiiiiii"]=Module["asm"]["Vh"]).apply(null,arguments)};var dynCall_viiiiiiiiii=Module["dynCall_viiiiiiiiii"]=function(){return (dynCall_viiiiiiiiii=Module["dynCall_viiiiiiiiii"]=Module["asm"]["Wh"]).apply(null,arguments)};var dynCall_viiiiiii=Module["dynCall_viiiiiii"]=function(){return (dynCall_viiiiiii=Module["dynCall_viiiiiii"]=Module["asm"]["Xh"]).apply(null,arguments)};Module["dynCall_iiiij"]=function(){return (Module["dynCall_iiiij"]=Module["asm"]["Yh"]).apply(null,arguments)};Module["dynCall_iiiiiiiiiiiiiiii"]=function(){return (Module["dynCall_iiiiiiiiiiiiiiii"]=Module["asm"]["Zh"]).apply(null,arguments)};Module["dynCall_jiji"]=function(){return (Module["dynCall_jiji"]=Module["asm"]["_h"]).apply(null,arguments)};Module["dynCall_iidiiii"]=function(){return (Module["dynCall_iidiiii"]=Module["asm"]["$h"]).apply(null,arguments)};var dynCall_j=Module["dynCall_j"]=function(){return (dynCall_j=Module["dynCall_j"]=Module["asm"]["ai"]).apply(null,arguments)};var dynCall_iiiiij=Module["dynCall_iiiiij"]=function(){return (dynCall_iiiiij=Module["dynCall_iiiiij"]=Module["asm"]["bi"]).apply(null,arguments)};var dynCall_iiiiid=Module["dynCall_iiiiid"]=function(){return (dynCall_iiiiid=Module["dynCall_iiiiid"]=Module["asm"]["ci"]).apply(null,arguments)};Module["dynCall_iiiiiiiiiii"]=function(){return (Module["dynCall_iiiiiiiiiii"]=Module["asm"]["di"]).apply(null,arguments)};Module["dynCall_iiiiiiiiiiiii"]=function(){return (Module["dynCall_iiiiiiiiiiiii"]=Module["asm"]["ei"]).apply(null,arguments)};var dynCall_fiii=Module["dynCall_fiii"]=function(){return (dynCall_fiii=Module["dynCall_fiii"]=Module["asm"]["fi"]).apply(null,arguments)};var dynCall_diii=Module["dynCall_diii"]=function(){return (dynCall_diii=Module["dynCall_diii"]=Module["asm"]["gi"]).apply(null,arguments)};var dynCall_iiiiiiiiiiii=Module["dynCall_iiiiiiiiiiii"]=function(){return (dynCall_iiiiiiiiiiii=Module["dynCall_iiiiiiiiiiii"]=Module["asm"]["hi"]).apply(null,arguments)};var dynCall_viiiiiiiiiiiiiii=Module["dynCall_viiiiiiiiiiiiiii"]=function(){return (dynCall_viiiiiiiiiiiiiii=Module["dynCall_viiiiiiiiiiiiiii"]=Module["asm"]["ii"]).apply(null,arguments)};Module["dynCall_iiiiijj"]=function(){return (Module["dynCall_iiiiijj"]=Module["asm"]["ji"]).apply(null,arguments)};Module["dynCall_iiiiiijj"]=function(){return (Module["dynCall_iiiiiijj"]=Module["asm"]["ki"]).apply(null,arguments)};Module["_asyncify_start_unwind"]=function(){return (Module["_asyncify_start_unwind"]=Module["asm"]["li"]).apply(null,arguments)};Module["_asyncify_stop_unwind"]=function(){return (Module["_asyncify_stop_unwind"]=Module["asm"]["mi"]).apply(null,arguments)};Module["_asyncify_start_rewind"]=function(){return (Module["_asyncify_start_rewind"]=Module["asm"]["ni"]).apply(null,arguments)};Module["_asyncify_stop_rewind"]=function(){return (Module["_asyncify_stop_rewind"]=Module["asm"]["oi"]).apply(null,arguments)};function invoke_iii(index,a1,a2){var sp=stackSave();try{return dynCall_iii(index,a1,a2)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_vii(index,a1,a2){var sp=stackSave();try{dynCall_vii(index,a1,a2);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_viii(index,a1,a2,a3){var sp=stackSave();try{dynCall_viii(index,a1,a2,a3);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_ii(index,a1){var sp=stackSave();try{return dynCall_ii(index,a1)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_v(index){var sp=stackSave();try{dynCall_v(index);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_iiii(index,a1,a2,a3){var sp=stackSave();try{return dynCall_iiii(index,a1,a2,a3)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_vi(index,a1){var sp=stackSave();try{dynCall_vi(index,a1);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_viiii(index,a1,a2,a3,a4){var sp=stackSave();try{dynCall_viiii(index,a1,a2,a3,a4);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_viiiii(index,a1,a2,a3,a4,a5){var sp=stackSave();try{dynCall_viiiii(index,a1,a2,a3,a4,a5);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_iiiii(index,a1,a2,a3,a4){var sp=stackSave();try{return dynCall_iiiii(index,a1,a2,a3,a4)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_i(index){var sp=stackSave();try{return dynCall_i(index)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_viiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8){var sp=stackSave();try{dynCall_viiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_iiiiiiii(index,a1,a2,a3,a4,a5,a6,a7){var sp=stackSave();try{return dynCall_iiiiiiii(index,a1,a2,a3,a4,a5,a6,a7)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_viiiiii(index,a1,a2,a3,a4,a5,a6){var sp=stackSave();try{dynCall_viiiiii(index,a1,a2,a3,a4,a5,a6);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_iiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9){var sp=stackSave();try{return dynCall_iiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_iiiiiii(index,a1,a2,a3,a4,a5,a6){var sp=stackSave();try{return dynCall_iiiiiii(index,a1,a2,a3,a4,a5,a6)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_iiiiii(index,a1,a2,a3,a4,a5){var sp=stackSave();try{return dynCall_iiiiii(index,a1,a2,a3,a4,a5)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_iiiiid(index,a1,a2,a3,a4,a5){var sp=stackSave();try{return dynCall_iiiiid(index,a1,a2,a3,a4,a5)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_fiii(index,a1,a2,a3){var sp=stackSave();try{return dynCall_fiii(index,a1,a2,a3)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_diii(index,a1,a2,a3){var sp=stackSave();try{return dynCall_diii(index,a1,a2,a3)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_viiiiiii(index,a1,a2,a3,a4,a5,a6,a7){var sp=stackSave();try{dynCall_viiiiiii(index,a1,a2,a3,a4,a5,a6,a7);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_iiiiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11){var sp=stackSave();try{return dynCall_iiiiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_viiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10){var sp=stackSave();try{dynCall_viiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_viiiiiiiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15){var sp=stackSave();try{dynCall_viiiiiiiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_viijiii(index,a1,a2,a3,a4,a5,a6,a7){var sp=stackSave();try{dynCall_viijiii(index,a1,a2,a3,a4,a5,a6,a7);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_ji(index,a1){var sp=stackSave();try{return dynCall_ji(index,a1)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_vij(index,a1,a2,a3){var sp=stackSave();try{dynCall_vij(index,a1,a2,a3);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_iij(index,a1,a2,a3){var sp=stackSave();try{return dynCall_iij(index,a1,a2,a3)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_viij(index,a1,a2,a3,a4){var sp=stackSave();try{dynCall_viij(index,a1,a2,a3,a4);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_vijiii(index,a1,a2,a3,a4,a5,a6){var sp=stackSave();try{dynCall_vijiii(index,a1,a2,a3,a4,a5,a6);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_vijiiii(index,a1,a2,a3,a4,a5,a6,a7){var sp=stackSave();try{dynCall_vijiiii(index,a1,a2,a3,a4,a5,a6,a7);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_jii(index,a1,a2){var sp=stackSave();try{return dynCall_jii(index,a1,a2)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_viji(index,a1,a2,a3,a4){var sp=stackSave();try{dynCall_viji(index,a1,a2,a3,a4);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_jiiii(index,a1,a2,a3,a4){var sp=stackSave();try{return dynCall_jiiii(index,a1,a2,a3,a4)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_iiiiji(index,a1,a2,a3,a4,a5,a6){var sp=stackSave();try{return dynCall_iiiiji(index,a1,a2,a3,a4,a5,a6)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_iiiiiji(index,a1,a2,a3,a4,a5,a6,a7){var sp=stackSave();try{return dynCall_iiiiiji(index,a1,a2,a3,a4,a5,a6,a7)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_viijjd(index,a1,a2,a3,a4,a5,a6,a7){var sp=stackSave();try{dynCall_viijjd(index,a1,a2,a3,a4,a5,a6,a7);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_viiijjjjii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13){var sp=stackSave();try{dynCall_viiijjjjii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_vijiijii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9){var sp=stackSave();try{dynCall_vijiijii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_jiiiii(index,a1,a2,a3,a4,a5){var sp=stackSave();try{return dynCall_jiiiii(index,a1,a2,a3,a4,a5)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_jiii(index,a1,a2,a3){var sp=stackSave();try{return dynCall_jiii(index,a1,a2,a3)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_viiiji(index,a1,a2,a3,a4,a5,a6){var sp=stackSave();try{dynCall_viiiji(index,a1,a2,a3,a4,a5,a6);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_j(index){var sp=stackSave();try{return dynCall_j(index)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_viijii(index,a1,a2,a3,a4,a5,a6){var sp=stackSave();try{dynCall_viijii(index,a1,a2,a3,a4,a5,a6);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_iiiiij(index,a1,a2,a3,a4,a5,a6){var sp=stackSave();try{return dynCall_iiiiij(index,a1,a2,a3,a4,a5,a6)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}Module["UTF8ToString"]=UTF8ToString;Module["stringToUTF8"]=stringToUTF8;Module["lengthBytesUTF8"]=lengthBytesUTF8;Module["addFunction"]=addFunction;Module["getTempRet0"]=getTempRet0;Module["intArrayToString"]=intArrayToString;var calledRun;function ExitStatus(status){this.name="ExitStatus";this.message="Program terminated with exit("+status+")";this.status=status;}dependenciesFulfilled=function runCaller(){if(!calledRun)run();if(!calledRun)dependenciesFulfilled=runCaller;};function run(args){if(runDependencies>0){return}preRun();if(runDependencies>0){return}function doRun(){if(calledRun)return;calledRun=true;Module["calledRun"]=true;if(ABORT)return;initRuntime();readyPromiseResolve(Module);if(Module["onRuntimeInitialized"])Module["onRuntimeInitialized"]();postRun();}if(Module["setStatus"]){Module["setStatus"]("Running...");setTimeout(function(){setTimeout(function(){Module["setStatus"]("");},1);doRun();},1);}else {doRun();}}Module["run"]=run;function exit(status,implicit){EXITSTATUS=status;procExit(status);}function procExit(code){EXITSTATUS=code;if(!keepRuntimeAlive()){if(Module["onExit"])Module["onExit"](code);ABORT=true;}quit_(code,new ExitStatus(code));}if(Module["preInit"]){if(typeof Module["preInit"]=="function")Module["preInit"]=[Module["preInit"]];while(Module["preInit"].length>0){Module["preInit"].pop()();}}run();


		  return monero_javascript.ready
		}
		);
		})();
		module.exports = monero_javascript;
} (monero_wallet_full));
	return monero_wallet_full.exports;
}

var LibraryUtils_1;
var hasRequiredLibraryUtils;

function requireLibraryUtils () {
	if (hasRequiredLibraryUtils) return LibraryUtils_1;
	hasRequiredLibraryUtils = 1;
	const assert = require$$0;
	const GenUtils = GenUtils_1;
	const MoneroError = MoneroError_1;
	const ThreadPool = ThreadPool_1;

	/**
	 * Collection of helper utilities for the library.
	 * 
	 * @hideconstructor
	 */
	class LibraryUtils {
	  
	  /**
	   * Log a message.
	   *
	   * @param {int} level - log level of the message
	   * @param {string} msg - message to log
	   */
	  static log(level, msg) {
	    assert(level === parseInt(level, 10) && level >= 0, "Log level must be an integer >= 0");
	    if (LibraryUtils.LOG_LEVEL >= level) console.log(msg);
	  }
	  
	  /**
	   * Set the library's log level with 0 being least verbose.
	   *
	   * @param {int} level - the library's log level
	   */
	  static async setLogLevel(level) {
	    assert(level === parseInt(level, 10) && level >= 0, "Log level must be an integer >= 0");
	    LibraryUtils.LOG_LEVEL = level;
	    if (LibraryUtils.WORKER) await LibraryUtils.invokeWorker(GenUtils.getUUID(), "setLogLevel", [level]);
	  }
	  
	  /**
	   * Get the library's log level.
	   *
	   * @return {int} the library's log level
	   */
	  static getLogLevel() {
	    return LibraryUtils.LOG_LEVEL;
	  }
	  
	  /**
	   * Get the total memory used by WebAssembly.
	   * 
	   * @return {int} the total memory used by WebAssembly
	   */
	  static async getWasmMemoryUsed() {
	    let total = 0;
	    if (LibraryUtils.WORKER) total += await LibraryUtils.invokeWorker(GenUtils.getUUID(), "getWasmMemoryUsed", []);
	    if (LibraryUtils.getWasmModule() && LibraryUtils.getWasmModule().HEAP8) total += LibraryUtils.getWasmModule().HEAP8.length;
	    return total;
	  }
	  
	  /**
	   * Get the WebAssembly module in the current context (nodejs, browser main thread or worker).
	   */
	  static getWasmModule() {
	    return LibraryUtils.WASM_MODULE;
	  }
	  
	  /**
	   * Load the WebAssembly keys module with caching.
	   */
	  static async loadKeysModule() {
	    
	    // use cache if suitable, full module supersedes keys module because it is superset
	    if (LibraryUtils.WASM_MODULE) return LibraryUtils.WASM_MODULE;
	    
	    // load module
	    delete LibraryUtils.WASM_MODULE;
	    LibraryUtils.WASM_MODULE = requireMonero_wallet_keys()();
	    return new Promise(function(resolve, reject) {
	      LibraryUtils.WASM_MODULE.then(module => {
	        LibraryUtils.WASM_MODULE = module;
	        delete LibraryUtils.WASM_MODULE.then;
	        LibraryUtils._initWasmModule(LibraryUtils.WASM_MODULE);
	        resolve(LibraryUtils.WASM_MODULE);
	      });
	    });
	  }
	  
	  /**
	   * Load the WebAssembly full module with caching.
	   * 
	   * The full module is a superset of the keys module and overrides it.
	   * 
	   * TODO: this is separate static function from loadKeysModule() because webpack cannot bundle worker using runtime param for conditional import
	   */
	  static async loadFullModule() {
	    
	    // use cache if suitable, full module supersedes keys module because it is superset
	    if (LibraryUtils.WASM_MODULE && LibraryUtils.FULL_LOADED) return LibraryUtils.WASM_MODULE;
	    
	    // load module
	    delete LibraryUtils.WASM_MODULE;
	    LibraryUtils.WASM_MODULE = requireMonero_wallet_full()();
	    return new Promise(function(resolve, reject) {
	      LibraryUtils.WASM_MODULE.then(module => {
	        LibraryUtils.WASM_MODULE = module;
	        delete LibraryUtils.WASM_MODULE.then;
	        LibraryUtils.FULL_LOADED = true;
	        LibraryUtils._initWasmModule(LibraryUtils.WASM_MODULE);
	        resolve(LibraryUtils.WASM_MODULE);
	      });
	    });
	  }
	  
	  /**
	   * Register a function by id which informs if unauthorized requests (e.g.
	   * self-signed certificates) should be rejected.
	   * 
	   * @param {string} fnId - unique identifier for the function
	   * @param {function} fn - function to inform if unauthorized requests should be rejected
	   */
	  static setRejectUnauthorizedFn(fnId, fn) {
	    if (!LibraryUtils.REJECT_UNAUTHORIZED_FNS) LibraryUtils.REJECT_UNAUTHORIZED_FNS = [];
	    if (fn === undefined) delete LibraryUtils.REJECT_UNAUTHORIZED_FNS[fnId];
	    else LibraryUtils.REJECT_UNAUTHORIZED_FNS[fnId] = fn;
	  }
	  
	  /**
	   * Indicate if unauthorized requests should be rejected.
	   * 
	   * @param {string} fnId - uniquely identifies the function
	   */
	  static isRejectUnauthorized(fnId) {
	    if (!LibraryUtils.REJECT_UNAUTHORIZED_FNS[fnId]) throw new Error("No function registered with id " + fnId + " to inform if unauthorized reqs should be rejected");
	    return LibraryUtils.REJECT_UNAUTHORIZED_FNS[fnId]();
	  }
	  
	  /**
	   * Set the path to load the worker. Defaults to "/monero_web_worker.js" in the browser
	   * and "./MoneroWebWorker.js" in node.
	   * 
	   * @param {string} workerDistPath - path to load the worker
	   */
	  static setWorkerDistPath(workerDistPath) {
	    let path = LibraryUtils._prefixWindowsPath(workerDistPath ? workerDistPath : LibraryUtils.WORKER_DIST_PATH_DEFAULT);
	    if (path !== LibraryUtils.WORKER_DIST_PATH) delete LibraryUtils.WORKER;
	    LibraryUtils.WORKER_DIST_PATH = path;
	  }

	  /**
	   * Get a singleton instance of a worker to share.
	   * 
	   * @return {Worker} a worker to share among wallet instances
	   */
	  static async getWorker() {
	    
	    // one time initialization
	    if (!LibraryUtils.WORKER) {
	      if (GenUtils.isBrowser()) LibraryUtils.WORKER = new Worker(LibraryUtils.WORKER_DIST_PATH);
	      else { 
	       const Worker = require$$6; // import web worker if nodejs
	       LibraryUtils.WORKER = new Worker(LibraryUtils.WORKER_DIST_PATH);
	      }
	      LibraryUtils.WORKER_OBJECTS = {};  // store per object running in the worker
	      
	      // receive worker errors
	      LibraryUtils.WORKER.onerror = function(err) {
	        console.error("Error posting message to MoneroWebWorker.js; is it copied to the app's build directory (e.g. in the root)?");
	        console.log(err);
	      };
	      
	      // receive worker messages
	      LibraryUtils.WORKER.onmessage = function(e) {
	        
	        // lookup object id, callback function, and this arg
	        let thisArg = null;
	        let callbackFn = LibraryUtils.WORKER_OBJECTS[e.data[0]].callbacks[e.data[1]]; // look up by object id then by function name
	        if (callbackFn === undefined) throw new Error("No worker callback function defined for key '" + e.data[1] + "'");
	        if (callbackFn instanceof Array) {  // this arg may be stored with callback function
	          thisArg = callbackFn[1];
	          callbackFn = callbackFn[0];
	        }
	        
	        // invoke callback function with this arg and arguments
	        callbackFn.apply(thisArg, e.data.slice(2));
	      };
	      
	      // set worker log level
	      await LibraryUtils.setLogLevel(LibraryUtils.getLogLevel());
	    }
	    return LibraryUtils.WORKER;
	  }
	  
	  /**
	   * Invoke a worker function and get the result with error handling.
	   * 
	   * @param {objectId} identifies the worker object to invoke
	   * @param {string} fnName is the name of the function to invoke
	   * @param {Object[]} args are function arguments to invoke with
	   * @return {Promise} resolves with response payload from the worker or an error
	   */
	  static async invokeWorker(objectId, fnName, args) {
	    assert(fnName.length >= 2);
	    let worker = await LibraryUtils.getWorker();
	    if (!LibraryUtils.WORKER_OBJECTS[objectId]) LibraryUtils.WORKER_OBJECTS[objectId] = {callbacks: {}};
	    return new Promise(function(resolve, reject) {
	      let callbackId = GenUtils.getUUID();
	      LibraryUtils.WORKER_OBJECTS[objectId].callbacks[callbackId] = function(resp) {  // TODO: this defines function once per callback
	        resp ? (resp.error ? reject(new MoneroError(resp.error)) : resolve(resp.result)) : resolve();
	      };
	      worker.postMessage([objectId, fnName, callbackId].concat(args === undefined ? [] : GenUtils.listify(args)));
	    });
	  }
	  
	  // ------------------------------ PRIVATE HELPERS ---------------------------
	  
	  static _initWasmModule(wasmModule) {
	    wasmModule.taskQueue = new ThreadPool(1);
	    wasmModule.queueTask = async function(asyncFn) { return wasmModule.taskQueue.submit(asyncFn); };
	  }
	  
	  static _prefixWindowsPath(path) {
	    if (path.indexOf("C:") == 0 && path.indexOf("file://") == -1) path = "file://" + path; // prepend C: paths with file://
	    return path;
	  }
	}

	LibraryUtils.LOG_LEVEL = 0;
	LibraryUtils.WORKER_DIST_PATH_DEFAULT = GenUtils.isBrowser() ? "/monero_web_worker.js" : function() {
	    const path = require$$0$1;
	    return LibraryUtils._prefixWindowsPath(path.join(__dirname, "./MoneroWebWorker.js"));
	}();
	LibraryUtils.WORKER_DIST_PATH = LibraryUtils.WORKER_DIST_PATH_DEFAULT;

	LibraryUtils_1 = LibraryUtils;
	return LibraryUtils_1;
}

/**
 * Monero integrated address model.
 */

class MoneroIntegratedAddress {
  
  constructor(state) {
    this.state = Object.assign({}, state);
  }
  
  toJson() {
    return Object.assign({}, this.state);
  }

  getStandardAddress() {
    return this.state.standardAddress;
  }
  
  setStandardAddress(standardAddress) {
    this.state.standardAddress = standardAddress;
    return this;
  }
  
  getPaymentId() {
    return this.state.paymentId;
  }
  
  setPaymentId(paymentId) {
    this.state.paymentId = paymentId;
    return this;
  }
  
  getIntegratedAddress() {
    return this.state.integratedAddress;
  }
  
  setIntegratedAddress(integratedAddress) {
    this.state.integratedAddress = integratedAddress;
    return this;
  }
  
  toString() {
    return this.state.integratedAddress;
  }
}

var MoneroIntegratedAddress_1 = MoneroIntegratedAddress;

const MoneroError$6 = MoneroError_1;

/**
 * Defines the Monero network types (mainnet, testnet, and stagenet).
 * 
 * @hideconstructor
 */
class MoneroNetworkType {
  
  /**
   * Validates the given network type.
   * 
   * @param {int} networkType - the network type to validate as a numeric
   */
  static validate(networkType) {
    if (networkType !== 0 && networkType !== 1 && networkType !== 2) throw new MoneroError$6("Network type is invalid: " + networkType);
  }
  
  /**
   * Indicates if the given network type is valid or not.
   * 
   * @param {int} networkType - the network type to validate as a numeric
   * @return {boolean} true if the network type is valid, false otherwise
   */
  static isValid(networkType) {
    return networkType === 0 || networkType === 1 || networkType === 2;
  }
  
  /**
   * Parse the given string as a network type.
   * 
   * @param {string} networkTypeStr - "mainnet", "testnet", or "stagenet" (case insensitive)
   * @return {int} the network type as a numeric
   */
  static parse(networkTypeStr) {
    let str = ("" + networkTypeStr).toLowerCase();
    switch (str) {
      case "mainnet": return MoneroNetworkType.MAINNET;
      case "testnet": return MoneroNetworkType.TESTNET;
      case "stagenet": return MoneroNetworkType.STAGENET;
      default: throw new MoneroError$6("Invalid network type to parse: '" + networkTypeStr + "'");
    }
  }
  
  /**
   * Get the network type in human-readable form.
   *
   * @return {string} the network type in human-readable form
   */
  static toString(networkType) {
    if (networkType === 0) return "mainnet";
    if (networkType === 1) return "testnet";
    if (networkType === 2) return "stagenet";
    throw new MoneroError$6("Invalid network type: " + networkType);
  }
}

/**
 * Mainnet (value=0).
 */
MoneroNetworkType.MAINNET = 0;

/**
 * Testnet (value=1).
 */
MoneroNetworkType.TESTNET = 1;

/**
 * Stagnet (value=2).
 */
MoneroNetworkType.STAGENET = 2;

var MoneroNetworkType_1 = MoneroNetworkType;

var MoneroUtils_1;
var hasRequiredMoneroUtils;

function requireMoneroUtils () {
	if (hasRequiredMoneroUtils) return MoneroUtils_1;
	hasRequiredMoneroUtils = 1;
	const assert = require$$0;
	const BigInteger = biginteger.BigInteger;
	const GenUtils = GenUtils_1;
	const LibraryUtils = requireLibraryUtils();
	const MoneroError = MoneroError_1;
	const MoneroIntegratedAddress = MoneroIntegratedAddress_1;
	const MoneroNetworkType = MoneroNetworkType_1;

	/**
	 * Collection of Monero utilities. Runs in a worker thread by default.
	 * 
	 * @hideconstructor
	 */
	class MoneroUtils {
	    
	  /**
	   * <p>Get the version of the monero-javascript library.<p>
	   * 
	   * @return {string} the version of this monero-javascript library
	   */
	  static getVersion() {
	    return "0.7.4";
	  }
	  
	  /**
	   * Enable or disable proxying these utilities to a worker thread.
	   * 
	   * @param {boolean} proxyToWorker - specifies if utilities should be proxied to a worker
	   */
	  static setProxyToWorker(proxyToWorker) {
	    MoneroUtils.PROXY_TO_WORKER = proxyToWorker || false;
	  }
	  
	  /**
	   * Validate the given mnemonic, throw an error if invalid.
	   *
	   * TODO: improve validation, use network type
	   * 
	   * @param {string} mnemonic - mnemonic to validate
	   */
	  static async validateMnemonic(mnemonic) {
	    assert(mnemonic, "Mnemonic phrase is not initialized");
	    let words = mnemonic.split(" ");
	    if (words.length !== MoneroUtils.NUM_MNEMONIC_WORDS) throw new MoneroError("Mnemonic phrase is " + words.length + " words but must be " + MoneroUtils.NUM_MNEMONIC_WORDS);
	  }
	  
	  /**
	   * Indicates if a private view key is valid.
	   * 
	   * @param {string} privateViewKey is the private view key to validate
	   * @return {Promise<bool>} true if the private view key is valid, false otherwise
	   */
	  static async isValidPrivateViewKey(privateViewKey) {
	    try {
	      await MoneroUtils.validatePrivateViewKey(privateViewKey);
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }
	  
	  /**
	   * Indicates if a public view key is valid.
	   * 
	   * @param {string} publicViewKey is the public view key to validate
	   * @return {Promise<bool>} true if the public view key is valid, false otherwise
	   */
	  static async isValidPublicViewKey(publicViewKey) {
	    try {
	      await MoneroUtils.validatePublicViewKey(publicViewKey);
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }
	  
	  /**
	   * Indicates if a private spend key is valid.
	   * 
	   * @param {string} privateSpendKey is the private spend key to validate
	   * @return {Promise<bool>} true if the private spend key is valid, false otherwise
	   */
	  static async isValidPrivateSpendKey(privateSpendKey) {
	    try {
	      await MoneroUtils.validatePrivateSpendKey(privateSpendKey);
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }
	  
	  /**
	   * Indicates if a public spend key is valid.
	   * 
	   * @param {string} publicSpendKey is the public spend key to validate
	   * @return {Promise<bool>} true if the public spend key is valid, false otherwise
	   */
	  static async isValidPublicSpendKey(publicSpendKey) {
	    try {
	      await MoneroUtils.validatePublicSpendKey(publicSpendKey);
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }
	  
	  /**
	   * Validate the given private view key, throw an error if invalid.
	   *
	   * @param {string} privateViewKey - private view key to validate
	   */
	  static async validatePrivateViewKey(privateViewKey) {
	    if (!MoneroUtils._isHex64(privateViewKey)) throw new MoneroError("private view key expected to be 64 hex characters");
	  }
	  
	  /**
	   * Validate the given public view key, throw an error if invalid.
	   *
	   * @param {string} publicViewKey - public view key to validate
	   */
	  static async validatePublicViewKey(publicViewKey) {
	    if (!MoneroUtils._isHex64(publicViewKey)) throw new MoneroError("public view key expected to be 64 hex characters");
	  }
	  
	  /**
	   * Validate the given private spend key, throw an error if invalid.
	   *
	   * @param {string} privateSpendKey - private spend key to validate
	   */
	  static async validatePrivateSpendKey(privateSpendKey) {
	    if (!MoneroUtils._isHex64(privateSpendKey)) throw new MoneroError("private spend key expected to be 64 hex characters");
	  }
	  
	  /**
	   * Validate the given public spend key, throw an error if invalid.
	   *
	   * @param {string} publicSpendKey - public spend key to validate
	   */
	  static async validatePublicSpendKey(publicSpendKey) {
	    if (!MoneroUtils._isHex64(publicSpendKey)) throw new MoneroError("public spend key expected to be 64 hex characters");
	  }
	  
	  /**
	   * Get an integrated address.
	   * 
	   * @param {MoneroNetworkType} networkType - network type of the integrated address
	   * @param {string} standardAddress - address to derive the integrated address from
	   * @param {string} paymentId - optionally specifies the integrated address's payment id (defaults to random payment id)
	   * @return {Promise<MoneroIntegratedAddress>} the integrated address
	   */
	  static async getIntegratedAddress(networkType, standardAddress, paymentId) {
	    if (MoneroUtils.PROXY_TO_WORKER) return new MoneroIntegratedAddress(await LibraryUtils.invokeWorker(undefined, "moneroUtilsGetIntegratedAddress", Array.from(arguments)));
	  
	    // validate inputs
	    MoneroNetworkType.validate(networkType);
	    assert(typeof standardAddress === "string", "Address is not string");
	    assert(standardAddress.length > 0, "Address is empty");
	    assert(GenUtils.isBase58(standardAddress), "Address is not base 58");
	    
	    // load keys module by default
	    if (LibraryUtils.getWasmModule() === undefined) await LibraryUtils.loadKeysModule();
	    
	    // get integrated address in queue
	    return LibraryUtils.getWasmModule().queueTask(async function() {
	      let integratedAddressJson = LibraryUtils.getWasmModule().get_integrated_address_util(networkType, standardAddress, paymentId ? paymentId : "");
	      if (integratedAddressJson.charAt(0) !== '{') throw new MoneroError(integratedAddressJson);
	      return new MoneroIntegratedAddress(JSON.parse(integratedAddressJson));
	    });
	  }
	  
	  /**
	   * Determine if the given address is valid.
	   * 
	   * @param {string} address - address
	   * @param {MoneroNetworkType} networkType - network type of the address to validate
	   * @return {Promise<boolean>} true if the address is valid, false otherwise
	   */
	  static async isValidAddress(address, networkType) {
	    try {
	      await MoneroUtils.validateAddress(address, networkType);
	      return true;
	    } catch (err) {
	      return false;
	    }
	  }
	  
	  /**
	   * Validate the given address, throw an error if invalid.
	   *
	   * @param {string} address - address to validate
	   * @param {MoneroNetworkType} networkType - network type of the address to validate
	   */
	  static async validateAddress(address, networkType) {
	    if (MoneroUtils.PROXY_TO_WORKER) return LibraryUtils.invokeWorker(undefined, "moneroUtilsValidateAddress", Array.from(arguments));
	    
	    // validate inputs
	    assert(typeof address === "string", "Address is not string");
	    assert(address.length > 0, "Address is empty");
	    assert(GenUtils.isBase58(address), "Address is not base 58");
	    MoneroNetworkType.validate(networkType);
	    
	    // load keys module by default
	    if (LibraryUtils.getWasmModule() === undefined) await LibraryUtils.loadKeysModule();
	    
	    // validate address in queue
	    return LibraryUtils.getWasmModule().queueTask(async function() {
	      let errMsg = LibraryUtils.getWasmModule().validate_address(address, networkType);
	      if (errMsg) throw new MoneroError(errMsg);
	    });
	  }
	  
	  /**
	   * Determine if the given payment id is valid.
	   * 
	   * @param {string} paymentId - payment id to determine if valid
	   * @return {Promise<bool>} true if the payment id is valid, false otherwise
	   */
	  static async isValidPaymentId(paymentId) {
	    try {
	      await MoneroUtils.validatePaymentId(paymentId);
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }
	  
	  /**
	   * Validate the given payment id, throw an error if invalid.
	   * 
	   * TODO: improve validation
	   * 
	   * @param {string} paymentId - payment id to validate 
	   */
	  static async validatePaymentId(paymentId) {
	    assert.equal(typeof paymentId, "string");
	    assert(paymentId.length === 16 || paymentId.length === 64);
	  }
	    
	  /**
	   * Decode tx extra according to https://cryptonote.org/cns/cns005.txt and
	   * returns the last tx pub key.
	   * 
	   * TODO: use c++ bridge for this
	   * 
	   * @param [byte[]] txExtra - array of tx extra bytes
	   * @return {string} the last pub key as a hexidecimal string
	   */
	  static async getLastTxPubKey(txExtra) {
	    let lastPubKeyIdx;
	    for (let i = 0; i < txExtra.length; i++) {
	      let tag = txExtra[i];
	      if (tag === 0 || tag === 2) {
	        i += 1 + txExtra[i + 1];  // advance to next tag
	      } else if (tag === 1) {
	        lastPubKeyIdx = i + 1;
	        i += 1 + 32;              // advance to next tag
	      } else throw new MoneroError("Invalid sub-field tag: " + tag);
	    }
	    return Buffer.from(new Uint8Array(txExtra.slice(lastPubKeyIdx, lastPubKeyIdx + 32))).toString("hex");
	  }
	  
	  /**
	   * Determines if two payment ids are functionally equal.
	   * 
	   * For example, 03284e41c342f032 and 03284e41c342f032000000000000000000000000000000000000000000000000 are considered equal.
	   * 
	   * @param {string} paymentId1 is a payment id to compare
	   * @param {string} paymentId2 is a payment id to compare
	   * @return {bool} true if the payment ids are equal, false otherwise
	   */
	  static paymentIdsEqual(paymentId1, paymentId2) {
	    let maxLength = Math.max(paymentId1.length, paymentId2.length);
	    for (let i = 0; i < maxLength; i++) {
	      if (i < paymentId1.length && i < paymentId2.length && paymentId1[i] !== paymentId2[i]) return false;
	      if (i >= paymentId1.length && paymentId2[i] !== '0') return false;
	      if (i >= paymentId2.length && paymentId1[i] !== '0') return false;
	    }
	    return true;
	  }
	  
	  /**
	   * Merges a transaction into a list of existing transactions.
	   * 
	   * @param {MoneroTx[]} txs - existing transactions to merge into
	   * @param {MoneroTx} tx - transaction to merge into the list
	   */
	  static mergeTx(txs, tx) {
	    for (let aTx of txs) {
	      if (aTx.getHash() === tx.getHash()) {
	        aTx.merge(tx);
	        return;
	      }
	    }
	    txs.push(tx);
	  }
	  
	  /**
	   * Convert the given JSON to a binary Uint8Array using Monero's portable storage format.
	   * 
	   * @param {object} json - json to convert to binary
	   * @return {Promise<Uint8Array>} the json converted to portable storage binary
	   */
	  static async jsonToBinary(json) {
	    if (MoneroUtils.PROXY_TO_WORKER) return LibraryUtils.invokeWorker(undefined, "moneroUtilsJsonToBinary", Array.from(arguments));
	    
	    // load keys module by default
	    if (LibraryUtils.getWasmModule() === undefined) await LibraryUtils.loadKeysModule();
	    
	    // use wasm in queue
	    return LibraryUtils.getWasmModule().queueTask(async function() {
	      
	      // serialize json to binary which is stored in c++ heap
	      let binMemInfoStr = LibraryUtils.getWasmModule().malloc_binary_from_json(JSON.stringify(json));
	      
	      // sanitize binary memory address info
	      let binMemInfo = JSON.parse(binMemInfoStr);
	      binMemInfo.ptr = parseInt(binMemInfo.ptr);
	      binMemInfo.length = parseInt(binMemInfo.length);
	      
	      // read binary data from heap to Uint8Array
	      let view = new Uint8Array(binMemInfo.length);
	      for (let i = 0; i < binMemInfo.length; i++) {
	        view[i] = LibraryUtils.getWasmModule().HEAPU8[binMemInfo.ptr / Uint8Array.BYTES_PER_ELEMENT + i];
	      }
	      
	      // free binary on heap
	      LibraryUtils.getWasmModule()._free(binMemInfo.ptr);
	      
	      // return json from binary data
	      return view;
	    });
	  }
	  
	  /**
	   * Convert the given portable storage binary to JSON.
	   * 
	   * @param {Uint8Array} uint8arr - binary data in Monero's portable storage format
	   * @return {Promise<object>} JSON object converted from the binary data
	   */
	  static async binaryToJson(uint8arr) {
	    if (MoneroUtils.PROXY_TO_WORKER) return LibraryUtils.invokeWorker(undefined, "moneroUtilsBinaryToJson", Array.from(arguments));
	    
	    // load keys module by default
	    if (LibraryUtils.getWasmModule() === undefined) await LibraryUtils.loadKeysModule();
	    
	    // use wasm in queue
	    return LibraryUtils.getWasmModule().queueTask(async function() {
	      
	      // allocate space in c++ heap for binary
	      let ptr = LibraryUtils.getWasmModule()._malloc(uint8arr.length * uint8arr.BYTES_PER_ELEMENT);
	      let heap = new Uint8Array(LibraryUtils.getWasmModule().HEAPU8.buffer, ptr, uint8arr.length * uint8arr.BYTES_PER_ELEMENT);
	      if (ptr !== heap.byteOffset) throw new MoneroError("Memory ptr !== heap.byteOffset"); // should be equal
	      
	      // write binary to heap
	      heap.set(new Uint8Array(uint8arr.buffer));
	      
	      // create object with binary memory address info
	      let binMemInfo = { ptr: ptr, length: uint8arr.length };
	      
	      // convert binary to json str
	      const ret_string = LibraryUtils.getWasmModule().binary_to_json(JSON.stringify(binMemInfo));
	      
	      // free binary on heap
	      LibraryUtils.getWasmModule()._free(ptr);
	      
	      // parse and return json
	      return JSON.parse(ret_string);
	    });
	  }
	  
	  /**
	   * Convert the binary response from daemon RPC block retrieval to JSON.
	   * 
	   * @param {Uint8Array} uint8arr - binary response from daemon RPC when getting blocks
	   * @return {Promise<object>} JSON object with the blocks data
	   */
	  static async binaryBlocksToJson(uint8arr) {
	    if (MoneroUtils.PROXY_TO_WORKER) return LibraryUtils.invokeWorker(undefined, "moneroUtilsBinaryBlocksToJson", Array.from(arguments));
	    
	    // load keys module by default
	    if (LibraryUtils.getWasmModule() === undefined) await LibraryUtils.loadKeysModule();
	    
	    // use wasm in queue
	    return LibraryUtils.getWasmModule().queueTask(async function() {
	      
	      // allocate space in c++ heap for binary
	      let ptr = LibraryUtils.getWasmModule()._malloc(uint8arr.length * uint8arr.BYTES_PER_ELEMENT);
	      let heap = new Uint8Array(LibraryUtils.getWasmModule().HEAPU8.buffer, ptr, uint8arr.length * uint8arr.BYTES_PER_ELEMENT);
	      if (ptr !== heap.byteOffset) throw new MoneroError("Memory ptr !== heap.byteOffset"); // should be equal
	      
	      // write binary to heap
	      heap.set(new Uint8Array(uint8arr.buffer));
	      
	      // create object with binary memory address info
	      let binMemInfo = { ptr: ptr, length: uint8arr.length  };

	      // convert binary to json str
	      const json_str = LibraryUtils.getWasmModule().binary_blocks_to_json(JSON.stringify(binMemInfo));
	      
	      // free memory
	      LibraryUtils.getWasmModule()._free(ptr);
	      
	      // parse result to json
	      let json = JSON.parse(json_str);                                          // parsing json gives arrays of block and tx strings
	      json.blocks = json.blocks.map(blockStr => JSON.parse(blockStr));          // replace block strings with parsed blocks
	      json.txs = json.txs.map(txs => txs ? txs.map(tx => JSON.parse(tx.replace(",", "{") + "}")) : []); // modify tx string to proper json and parse // TODO: more efficient way than this json manipulation?
	      return json;
	    });
	  }
	  
	  /**
	   * Convert XMR to atomic units.
	   * 
	   * @param {number|string} amountXmr - amount in XMR to convert to atomic units
	   * @return {BigInteger} amount in atomic units
	   */
	  static xmrToAtomicUnits(amountXmr) {
	    if (typeof amountXmr === "number") amountXmr = "" + amountXmr;
	    else if (typeof amountXmr !== "string") throw new MoneroError("Must provide XMR amount as a string or js number to convert to atomic units");
	    let decimalDivisor = 1;
	    let decimalIdx = amountXmr.indexOf('.');
	    if (decimalIdx > -1) {
	      decimalDivisor = Math.pow(10, amountXmr.length - decimalIdx - 1);
	      amountXmr = amountXmr.slice(0, decimalIdx) + amountXmr.slice(decimalIdx + 1);
	    }
	    return new BigInteger(amountXmr).multiply(new BigInteger(MoneroUtils.AU_PER_XMR)).divide(new BigInteger(decimalDivisor));
	  }
	  
	  /**
	   * Convert atomic units to XMR.
	   * 
	   * @param {BigInteger|string} amountAtomicUnits - amount in atomic units to convert to XMR
	   * @return {number} amount in XMR 
	   */
	  static atomicUnitsToXmr(amountAtomicUnits) {
	    if (typeof amountAtomicUnits === "string") amountAtomicUnits = new BigInteger(amountAtomicUnits);
	    else if (!(amountAtomicUnits instanceof BigInteger)) throw new MoneroError("Must provide atomic units as BigInteger or string to convert to XMR");
	    let quotientAndRemainder = amountAtomicUnits.divRem(new BigInteger(MoneroUtils.AU_PER_XMR));
	    return Number(quotientAndRemainder[0].toJSValue() + quotientAndRemainder[1].toJSValue() / MoneroUtils.AU_PER_XMR);
	  }
	  
	  static _isHex64(str) {
	    return typeof str === "string" && str.length === 64 && GenUtils.isHex(str);
	  }
	}

	MoneroUtils.PROXY_TO_WORKER = true;
	MoneroUtils.NUM_MNEMONIC_WORDS = 25;
	MoneroUtils.RING_SIZE = 12;
	MoneroUtils.MAX_REQUESTS_PER_SECOND = 50;
	MoneroUtils.AU_PER_XMR = 1000000000000;

	MoneroUtils_1 = MoneroUtils;
	return MoneroUtils_1;
}

var HttpClient_1;
var hasRequiredHttpClient;

function requireHttpClient () {
	if (hasRequiredHttpClient) return HttpClient_1;
	hasRequiredHttpClient = 1;
	const GenUtils = GenUtils_1;
	const LibraryUtils = requireLibraryUtils();
	const MoneroUtils = requireMoneroUtils();
	const ThreadPool = ThreadPool_1;
	const PromiseThrottle = require$$4;
	const Request = require$$5;

	/**
	 * Handle HTTP requests with a uniform interface.
	 * 
	 * @hideconstructor
	 */
	class HttpClient {
	  
	  /**
	   * <p>Make a HTTP request.<p>
	   * 
	   * @param {object} request - configures the request to make
	   * @param {string} request.method - HTTP method ("GET", "PUT", "POST", "DELETE", etc)
	   * @param {string} request.uri - uri to request
	   * @param {string|object|Uint8Array} request.body - request body
	   * @param {string} request.username - username to authenticate the request (optional)
	   * @param {string} request.password - password to authenticate the request (optional)
	   * @param {object} request.headers - headers to add to the request (optional)
	   * @param {string} request.requestApi - one of "fetch" or "xhr" (default "fetch")
	   * @param {boolean} request.resolveWithFullResponse - return full response if true, else body only (default false)
	   * @param {boolean} request.rejectUnauthorized - whether or not to reject self-signed certificates (default true)
	   * @param {number} request.timeout - maximum time allowed in milliseconds
	   * @param {number} request.proxyToWorker - proxy request to worker thread
	   * @returns {object} response - the response object
	   * @returns {string|object|Uint8Array} response.body - the response body
	   * @returns {number} response.statusCode - the response code
	   * @returns {String} response.statusText - the response message
	   * @returns {object} response.headers - the response headers
	   */
	  static async request(request) {
	    
	    // proxy to worker if configured
	    if (request.proxyToWorker) {
	      try {
	        return await LibraryUtils.invokeWorker(GenUtils.getUUID(), "httpRequest", request);
	      } catch (err) {
	        if (err.message.length > 0 && err.message.charAt(0) === "{") {
	          let parsed = JSON.parse(err.message);
	          err.message = parsed.statusMessage;
	          err.statusCode = parsed.statusCode;
	          throw err;
	        }
	      }
	    }
	    
	    // assign defaults
	    request = Object.assign(HttpClient._DEFAULT_REQUEST, request);
	    
	    // validate request
	    try { request.host = new URL(request.uri).host; } // hostname:port
	    catch (err) { throw new Error("Invalid request URL: " + request.uri); }
	    if (request.body && !(typeof request.body === "string" || typeof request.body === "object")) {
	      throw new Error("Request body type is not string or object");
	    }
	    
	    // initialize one task queue per host
	    if (!HttpClient._TASK_QUEUES[request.host]) HttpClient._TASK_QUEUES[request.host] = new ThreadPool(1);
	    
	    // initialize one promise throttle per host
	    if (!HttpClient._PROMISE_THROTTLES[request.host]) {
	      HttpClient._PROMISE_THROTTLES[request.host] = new PromiseThrottle({
	        requestsPerSecond: MoneroUtils.MAX_REQUESTS_PER_SECOND, // TODO: HttpClient should not depend on MoneroUtils for configuration
	        promiseImplementation: Promise
	      });
	    }
	    
	    // request using fetch or xhr with timeout
	    let timeout = request.timeout ? request.timeout : HttpClient._DEFAULT_TIMEOUT;
	    let requestPromise = request.requestApi === "fetch" ? HttpClient._requestFetch(request) : HttpClient._requestXhr(request);
	    let timeoutPromise = new Promise((resolve, reject) => {
	      let id = setTimeout(() => {
	        clearTimeout(id);
	        reject('Request timed out in '+ timeout + ' milliseconds');
	      }, timeout);
	    });
	    return Promise.race([requestPromise, timeoutPromise]);
	  }
	  
	  // ----------------------------- PRIVATE HELPERS ----------------------------
	  
	  static async _requestFetch(req) {
	    
	    // build request options
	    let opts = {
	      method: req.method,
	      uri: req.uri,
	      body: req.body,
	      agent: req.uri.startsWith("https") ? HttpClient._getHttpsAgent() : HttpClient._getHttpAgent(),
	      rejectUnauthorized: req.rejectUnauthorized,
	      resolveWithFullResponse: req.resolveWithFullResponse,
	      requestCert: true // TODO: part of config?
	    };
	    if (req.username) {
	      opts.forever = true;
	      opts.auth = {
	        user: req.username,
	        pass: req.password,
	        sendImmediately: false
	      };
	    }
	    if (req.body instanceof Uint8Array) opts.encoding = null;
	    
	    // queue and throttle request to execute in serial and rate limited
	    let host = req.host;
	    let resp = await HttpClient._TASK_QUEUES[host].submit(async function() {
	      return HttpClient._PROMISE_THROTTLES[host].add(function(opts) { return Request(opts); }.bind(this, opts));
	    });
	    
	    // normalize response
	    let normalizedResponse = {};
	    if (req.resolveWithFullResponse) {
	      normalizedResponse.statusCode = resp.statusCode;
	      normalizedResponse.statusText = resp.statusMessage;
	      normalizedResponse.headers = resp.headers;
	      normalizedResponse.body = resp.body;
	    } else {
	      normalizedResponse.body = resp;
	    }
	    return normalizedResponse;
	  }
	  
	  static async _requestXhr(req) {
	    if (req.headers) throw new Error("Custom headers not implemented in XHR request");  // TODO
	    
	    // collect params from request which change on await
	    let method = req.method;
	    let uri = req.uri;
	    let host = req.host;
	    let username = req.username;
	    let password = req.password;
	    let body = req.body;
	    let isBinary = body instanceof Uint8Array;
	    
	    // queue and throttle requests to execute in serial and rate limited per host
	    let resp = await HttpClient._TASK_QUEUES[host].submit(async function() {
	      return HttpClient._PROMISE_THROTTLES[host].add(function() {
	        return new Promise(function(resolve, reject) {
	          let digestAuthRequest = new HttpClient.digestAuthRequest(method, uri, username, password);
	          digestAuthRequest.request(function(resp) {
	            resolve(resp);
	          }, function(resp) {
	            if (resp.status) resolve(resp);
	            else reject(new Error("Request failed without response: " + method + " " + uri));
	          }, body);
	        });
	      }.bind(this));
	    });
	    
	    // normalize response
	    let normalizedResponse = {};
	    normalizedResponse.statusCode = resp.status;
	    normalizedResponse.statusText = resp.statusText;
	    normalizedResponse.headers = HttpClient._parseXhrResponseHeaders(resp.getAllResponseHeaders());
	    normalizedResponse.body = isBinary ? new Uint8Array(resp.response) : resp.response;
	    if (normalizedResponse.body instanceof ArrayBuffer) normalizedResponse.body = new Uint8Array(normalizedResponse.body);  // handle empty binary request
	    return normalizedResponse;
	  }
	  
	  /**
	   * Get a singleton instance of an HTTP client to share.
	   * 
	   * @return {http.Agent} a shared agent for network requests among library instances
	   */
	  static _getHttpAgent() {
	    if (!HttpClient.HTTP_AGENT) {
	      let http = require$$6$1;
	      HttpClient.HTTP_AGENT = new http.Agent({keepAlive: true});
	    }
	    return HttpClient.HTTP_AGENT;
	  }
	  
	  /**
	   * Get a singleton instance of an HTTPS client to share.
	   * 
	   * @return {https.Agent} a shared agent for network requests among library instances
	   */
	  static _getHttpsAgent() {
	    if (!HttpClient.HTTPS_AGENT) {
	      let https = require$$7;
	      HttpClient.HTTPS_AGENT = new https.Agent({keepAlive: true});
	    }
	    return HttpClient.HTTPS_AGENT;
	  }
	  
	  
	  static _parseXhrResponseHeaders(headersStr) {
	    let headerMap = {};
	    let headers = headersStr.trim().split(/[\r\n]+/);
	    for (let header of headers) {
	      let headerVals = header.split(": ");
	      headerMap[headerVals[0]] = headerVals[1];
	    }
	    return headerMap;
	  }
	}

	/**
	 * Modification of digest auth request by @inorganik.
	 * 
	 * Dependent on CryptoJS MD5 hashing: http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/md5.js
	 * 
	 * MIT licensed.
	 */
	HttpClient.digestAuthRequest = function(method, url, username, password) {
	  var self = this;

	  if (typeof CryptoJS === 'undefined' && typeof commonjsRequire === 'function') {
	    var CryptoJS = require$$8;
	  }

	  this.scheme = null; // we just echo the scheme, to allow for 'Digest', 'X-Digest', 'JDigest' etc
	  this.nonce = null; // server issued nonce
	  this.realm = null; // server issued realm
	  this.qop = null; // "quality of protection" - '' or 'auth' or 'auth-int'
	  this.response = null; // hashed response to server challenge
	  this.opaque = null; // hashed response to server challenge
	  this.nc = 1; // nonce count - increments with each request used with the same nonce
	  this.cnonce = null; // client nonce

	  // settings
	  this.timeout = 60000; // timeout
	  this.loggingOn = false; // toggle console logging

	  // determine if a post, so that request will send data
	  this.post = false;
	  if (method.toLowerCase() === 'post' || method.toLowerCase() === 'put') {
	    this.post = true;
	  }

	  // start here
	  // successFn - will be passed JSON data
	  // errorFn - will be passed the failed authenticatedRequest
	  // data - optional, for POSTS
	  this.request = function(successFn, errorFn, data) {
	    
	    // stringify json
	    if (data) {
	      try {
	        self.data = data instanceof Uint8Array || typeof data === "string" ? data : JSON.stringify(data);
	      } catch (err) {
	        console.error(err);
	        throw err;
	      }
	    }
	    self.successFn = successFn;
	    self.errorFn = errorFn;

	    if (!self.nonce) {
	      self.makeUnauthenticatedRequest(self.data);
	    } else {
	      self.makeAuthenticatedRequest();
	    }
	  };
	  this.makeUnauthenticatedRequest = function(data) {
	    self.firstRequest = new XMLHttpRequest();
	    self.firstRequest.open(method, url, true);
	    self.firstRequest.timeout = self.timeout;
	    // if we are posting, add appropriate headers
	    if (self.post && data) {
	      if (typeof data === "string") {
	        self.firstRequest.setRequestHeader('Content-type', 'text/plain');
	      } else {
	        self.firstRequest.responseType = "arraybuffer";
	      }
	    }

	    self.firstRequest.onreadystatechange = function() {

	      // 2: received headers,  3: loading, 4: done
	      if (self.firstRequest.readyState === 2) {

	        var responseHeaders = self.firstRequest.getAllResponseHeaders();
	        responseHeaders = responseHeaders.split('\n');
	        // get authenticate header
	        var digestHeaders;
	        for(var i = 0; i < responseHeaders.length; i++) {
	          if (responseHeaders[i].match(/www-authenticate/i) != null) {
	            digestHeaders = responseHeaders[i];
	          }
	        }

	        if (digestHeaders != null) {
	          // parse auth header and get digest auth keys
	          digestHeaders = digestHeaders.slice(digestHeaders.indexOf(':') + 1, -1);
	          digestHeaders = digestHeaders.split(',');
	          self.scheme = digestHeaders[0].split(/\s/)[1];
	          for (var i = 0; i < digestHeaders.length; i++) {
	            var equalIndex = digestHeaders[i].indexOf('='),
	              key = digestHeaders[i].substring(0, equalIndex),
	              val = digestHeaders[i].substring(equalIndex + 1);
	            val = val.replace(/['"]+/g, '');
	            // find realm
	            if (key.match(/realm/i) != null) {
	              self.realm = val;
	            }
	            // find nonce
	            if (key.match(/nonce/i) != null) {
	              self.nonce = val;
	            }
	            // find opaque
	            if (key.match(/opaque/i) != null) {
	              self.opaque = val;
	            }
	            // find QOP
	            if (key.match(/qop/i) != null) {
	              self.qop = val;
	            }
	          }
	          // client generated keys
	          self.cnonce = self.generateCnonce();
	          self.nc++;
	          // if logging, show headers received:
	          self.log('received headers:');
	          self.log('  realm: '+self.realm);
	          self.log('  nonce: '+self.nonce);
	          self.log('  opaque: '+self.opaque);
	          self.log('  qop: '+self.qop);
	          // now we can make an authenticated request
	          self.makeAuthenticatedRequest();
	        }
	      }
	      if (self.firstRequest.readyState === 4) {
	        if (self.firstRequest.status === 200) {
	          self.log('Authentication not required for '+url);
	          if (data instanceof Uint8Array) {
	            self.successFn(self.firstRequest);
	          } else {
	            if (self.firstRequest.responseText !== 'undefined') {
	              if (self.firstRequest.responseText.length > 0) {
	                // If JSON, parse and return object
	                if (self.isJson(self.firstRequest.responseText)) {  // TODO: redundant
	                  self.successFn(self.firstRequest);
	                } else {
	                  self.successFn(self.firstRequest);
	                }
	              }
	            } else {
	              self.successFn();
	            }
	          }
	        }
	      }
	    };
	    // send
	    if (self.post) {
	      // in case digest auth not required
	      self.firstRequest.send(self.data);
	    } else {
	      self.firstRequest.send();
	    }
	    self.log('Unauthenticated request to '+url);

	    // handle error
	    self.firstRequest.onerror = function() {
	      if (self.firstRequest.status !== 401) {
	        self.log('Error ('+self.firstRequest.status+') on unauthenticated request to '+url);
	        self.errorFn(self.firstRequest);
	      }
	    };
	  };
	  this.makeAuthenticatedRequest= function() {

	    self.response = self.formulateResponse();
	    self.authenticatedRequest = new XMLHttpRequest();
	    self.authenticatedRequest.open(method, url, true);
	    self.authenticatedRequest.timeout = self.timeout;
	    var digestAuthHeader = self.scheme+' '+
	      'username="'+username+'", '+
	      'realm="'+self.realm+'", '+
	      'nonce="'+self.nonce+'", '+
	      'uri="'+url+'", '+
	      'response="'+self.response+'", '+
	      'opaque="'+self.opaque+'", '+
	      'qop='+self.qop+', '+
	      'nc='+('00000000' + self.nc).slice(-8)+', '+
	      'cnonce="'+self.cnonce+'"';
	    self.authenticatedRequest.setRequestHeader('Authorization', digestAuthHeader);
	    self.log('digest auth header response to be sent:');
	    self.log(digestAuthHeader);
	    // if we are posting, add appropriate headers
	    if (self.post && self.data) {
	      if (typeof self.data === "string") {
	        self.authenticatedRequest.setRequestHeader('Content-type', 'text/plain');
	      } else {
	        self.authenticatedRequest.responseType = "arraybuffer";        
	      }
	    }
	    self.authenticatedRequest.onload = function() {
	      // success
	      if (self.authenticatedRequest.status >= 200 && self.authenticatedRequest.status < 400) {
	        // increment nonce count
	        self.nc++;
	        // return data
	        if (self.data instanceof Uint8Array) {
	          self.successFn(self.authenticatedRequest);
	        } else {
	          if (self.authenticatedRequest.responseText !== 'undefined' && self.authenticatedRequest.responseText.length > 0 ) {
	            // If JSON, parse and return object
	            if (self.isJson(self.authenticatedRequest.responseText)) {  // TODO: redundant from not parsing
	              self.successFn(self.authenticatedRequest);
	            } else {
	              self.successFn(self.authenticatedRequest);
	            }
	          } else {
	           self.successFn();
	          }
	        }
	      }
	      // failure
	      else {
	        self.nonce = null;
	        self.errorFn(self.authenticatedRequest);
	      }
	    };
	    // handle errors
	    self.authenticatedRequest.onerror = function() {
	      self.log('Error ('+self.authenticatedRequest.status+') on authenticated request to '+url);
	      self.nonce = null;
	      self.errorFn(self.authenticatedRequest);
	    };
	    // send
	    if (self.post) {
	      self.authenticatedRequest.send(self.data);
	    } else {
	      self.authenticatedRequest.send();
	    }
	    self.log('Authenticated request to '+url);
	  };
	  // hash response based on server challenge
	  this.formulateResponse = function() {
	    var HA1 = CryptoJS.MD5(username+':'+self.realm+':'+password).toString();
	    var HA2 = CryptoJS.MD5(method+':'+url).toString();
	    var response = CryptoJS.MD5(HA1+':'+
	      self.nonce+':'+
	      ('00000000' + self.nc).slice(-8)+':'+
	      self.cnonce+':'+
	      self.qop+':'+
	      HA2).toString();
	    return response;
	  };
	  // generate 16 char client nonce
	  this.generateCnonce = function() {
	    var characters = 'abcdef0123456789';
	    var token = '';
	    for (var i = 0; i < 16; i++) {
	      var randNum = Math.round(Math.random() * characters.length);
	      token += characters.substr(randNum, 1);
	    }
	    return token;
	  };
	  this.abort = function() {
	    self.log('[digestAuthRequest] Aborted request to '+url);
	    if (self.firstRequest != null) {
	      if (self.firstRequest.readyState != 4) self.firstRequest.abort();
	    }
	    if (self.authenticatedRequest != null) {
	      if (self.authenticatedRequest.readyState != 4) self.authenticatedRequest.abort();
	    }
	  };
	  this.isJson = function(str) {
	    try {
	      JSON.parse(str);
	    } catch (err) {
	      return false;
	    }
	    return true;
	  };
	  this.log = function(str) {
	    if (self.loggingOn) {
	      console.log('[digestAuthRequest] '+str);
	    }
	  };
	  this.version = function() { return '0.8.0' };
	};

	// default request config
	HttpClient._DEFAULT_REQUEST = {
	  method: "GET",
	  requestApi: "fetch",
	  resolveWithFullResponse: false,
	  rejectUnauthorized: true
	};

	// rate limit requests per host
	HttpClient._PROMISE_THROTTLES = [];
	HttpClient._TASK_QUEUES = [];
	HttpClient._DEFAULT_TIMEOUT = 30000;

	HttpClient_1 = HttpClient;
	return HttpClient_1;
}

const MoneroError$5 = MoneroError_1;

/**
 * Error when interacting with Monero RPC.
 */
class MoneroRpcError extends MoneroError$5 {
  
  /**
   * Constructs the error.
   * 
   * @param {string} rpcDescription is a description of the error from rpc
   * @param {int} rpcCode is the error code from rpc
   * @param {string} rpcMethod is the rpc method invoked
   * @param {object} rpcParams are parameters sent with the rpc request
   */
  constructor(rpcDescription, rpcCode, rpcMethod, rpcParams) {
    super(rpcDescription, rpcCode);
    this.rpcMethod = rpcMethod;
    this.rpcParams = rpcParams;
  }
  
  getRpcMethod() {
    return this.rpcMethod;
  }
  
  getRpcParams() {
    return this.rpcParams;
  }
  
  toString() {
    let str = super.toString();
    if (this.rpcMethod || this.rpcParams) str += "\nRequest: '" + this.rpcMethod + "' with params: " + (typeof this.rpcParams === "object" ? JSON.stringify(this.rpcParams) : this.rpcParams);
    return str;
  }
}

var MoneroRpcError_1 = MoneroRpcError;

var MoneroRpcConnection_1;
var hasRequiredMoneroRpcConnection;

function requireMoneroRpcConnection () {
	if (hasRequiredMoneroRpcConnection) return MoneroRpcConnection_1;
	hasRequiredMoneroRpcConnection = 1;
	const GenUtils = GenUtils_1;
	const HttpClient = requireHttpClient();
	const LibraryUtils = requireLibraryUtils();
	const MoneroError = MoneroError_1;
	const MoneroRpcError = MoneroRpcError_1;
	const MoneroUtils = requireMoneroUtils();

	/**
	 * Maintains a connection and sends requests to a Monero RPC API.
	 */
	class MoneroRpcConnection {
	  
	  /**
	   * <p>Construct a RPC connection.</p>
	   * 
	   * <p>Examples:</p>
	   * 
	   * <code>
	   * let connection1 = new MoneroRpcConnection("http://localhost:38081", "daemon_user", "daemon_password_123")<br><br>
	   * 
	   * let connection2 = new MoneroRpcConnection({<br>
	   * &nbsp;&nbsp; uri: http://localhost:38081,<br>
	   * &nbsp;&nbsp; username: "daemon_user",<br>
	   * &nbsp;&nbsp; password: "daemon_password_123",<br>
	   * &nbsp;&nbsp; rejectUnauthorized: false, // accept self-signed certificates e.g. for local development<br>
	   * &nbsp;&nbsp; proxyToWorker: true // proxy request to worker (default false)<br>
	   * });
	   * </code>
	   * 
	   * @param {string|object|MoneroRpcConnection} uriOrConfigOrConnection - RPC endpoint URI, MoneroRpcConnection, or equivalent JS object
	   * @param {string} uriOrConfigOrConnection.uri - URI of the RPC endpoint
	   * @param {string} uriOrConfigOrConnection.username - username to authenticate with the RPC endpoint (optional)
	   * @param {string} uriOrConfigOrConnection.password - password to authenticate with the RPC endpoint (optional)
	   * @param {boolean} uriOrConfigOrConnection.rejectUnauthorized - rejects self-signed certificates if true (default true)
	   * @param {boolean} uriOrConfigOrConnection.proxyToWorker - proxy requests to worker
	   * @param {string} username - username to authenticate with the RPC endpoint (optional)
	   * @param {string} password - password to authenticate with the RPC endpoint (optional)
	   * @param {boolean} rejectUnauthorized - reject self-signed certificates if true (default true)
	   */
	  constructor(uriOrConfigOrConnection, username, password, rejectUnauthorized, proxyToWorker) {
	    
	    // validate and normalize config
	    if (typeof uriOrConfigOrConnection === "string") {
	      this._config = {uri: uriOrConfigOrConnection};
	      this.setCredentials(username, password);
	      if (rejectUnauthorized !== undefined) this._config.rejectUnauthorized = rejectUnauthorized;
	      if (proxyToWorker !== undefined) this._config.proxyToWorker = proxyToWorker;
	    } else if (typeof uriOrConfigOrConnection === "object") {
	      if (username !== undefined || password !== undefined || rejectUnauthorized !== undefined || proxyToWorker !== undefined) throw new MoneroError("Can provide config object or params but not both");
	      if (uriOrConfigOrConnection instanceof MoneroRpcConnection) this._config = Object.assign({}, uriOrConfigOrConnection.getConfig());
	      else this._config = Object.assign({}, uriOrConfigOrConnection);
	      this.setCredentials(this._config.username, this._config.password);
	    } else if (uriOrConfigOrConnection !== undefined) {
	      throw new MoneroError("Invalid configuration to MoneroRpcConnection; must be string or MoneroRpcConnection or equivalent JS object");
	    }
	    
	    // merge default config
	    this._config = Object.assign({}, MoneroRpcConnection.DEFAULT_CONFIG, this._config);
	    
	    // normalize uri
	    if (this._config.uri) {
	      this._config.uri = this._config.uri.replace(/\/$/, ""); // strip trailing slash
	      if (!new RegExp("^\\w+://.+").test(this._config.uri)) this._config.uri = "http://" + this._config.uri; // assume http if protocol not given
	    }
	    
	    // fail with friendly message if using old api
	    if (this._config.user || this._config.pass) throw new MoneroError("Authentication fields 'user' and 'pass' have been renamed to 'username' and 'password'.  Please update to the new api");
	    
	    // check for unsupported fields
	    for (let key of Object.keys(this._config)) {
	      if (!GenUtils.arrayContains(MoneroRpcConnection.SUPPORTED_FIELDS, key)) {
	        throw new MoneroError("RPC connection includes unsupported field: '" + key + "'");
	      }
	    }
	  }
	  
	  setCredentials(username, password) {
	    if (username === "") username = undefined;
	    if (password === "") password = undefined;
	    if (username || password) {
	      if (!username) throw new MoneroError("username must be defined because password is defined");
	      if (!password) throw new MoneroError("password must be defined because username is defined");
	    }
	    if (this._config.username === "") this._config.username = undefined;
	    if (this._config.password === "") this._config.password = undefined;
	    if (this._config.username !== username || this._config.password !== password) {
	      this._isOnline = undefined;
	      this._isAuthenticated = undefined;
	    }
	    this._config.username = username;
	    this._config.password = password;
	    return this;
	  }
	  
	  getUri() {
	    return this._config.uri;
	  }
	  
	  getUsername() {
	    return this._config.username ? this._config.username : "";
	  }
	  
	  getPassword() {
	    return this._config.password ? this._config.password : "";
	  }
	  
	  getRejectUnauthorized() {
	    return this._config.rejectUnauthorized;
	  }
	  
	  setProxyToWorker(proxyToWorker) {
	    this._config.proxyToWorker = proxyToWorker;
	    return this;
	  }
	  
	  getProxyToWorker() {
	    return this._config.proxyToWorker;
	  }
	  
	  getConfig() {
	    return this._config;
	  }
	  
	  getPriority() {
	    return this._config.priority; 
	  }
	  
	  /**
	   * Set the connection's priority relative to other connections. Priority 1 is highest,
	   * then priority 2, etc. The default priority of 0 is lowest priority.
	   * 
	   * @param {int} priority - the connection priority (default 0)
	   * @return {MoneroRpcConnection} this connection
	   */
	  setPriority(priority) {
	    if (!(priority >= 0)) throw new MoneroError("Priority must be >= 0");
	    this._config.priority = priority;
	    return this;
	  }
	  
	  setAttribute(key, value) {
	    if (!this.attributes) this.attributes = new Map();
	    this.attributes.put(key, value);
	    return this;
	  }
	  
	  getAttribute(key) {
	    return this.attributes.get(key);
	  }
	  
	  /**
	   * Check the connection status to update isOnline, isAuthenticated, and response time.
	   * 
	   * @param {int} timeoutInMs - maximum response time before considered offline
	   * @return {Promise<boolean>} true if there is a change in status, false otherwise
	   */
	  async checkConnection(timeoutInMs) {
	    let isOnlineBefore = this._isOnline;
	    let isAuthenticatedBefore = this._isAuthenticated;
	    let startTime = Date.now();
	    try {
	      if (this._fakeDisconnected) throw new Error("Connection is fake disconnected");
	      await this.sendJsonRequest("get_version", undefined, timeoutInMs);
	      this._isOnline = true;
	      this._isAuthenticated = true;
	    } catch (err) {
	      if (err instanceof MoneroRpcError && err.getCode() === 401) {
	        this._isOnline = true;
	        this._isAuthenticated = false;
	      } else {
	        this._isOnline = false;
	        this._isAuthenticated = undefined;
	        this._responseTime = undefined;
	      }
	    }
	    if (this._isOnline) this._responseTime = Date.now() - startTime;
	    return isOnlineBefore !== this._isOnline || isAuthenticatedBefore !== this._isAuthenticated;
	  }
	  
	  /**
	   * Indicates if the connection is connected according to the last call to checkConnection().<br><br>
	   * 
	   * Note: must call checkConnection() manually unless using MoneroConnectionManager.
	   * 
	   * @return {boolean|undefined} true or false to indicate if connected, or undefined if checkConnection() has not been called
	   */
	  isConnected() {
	    return this._isOnline === undefined ? undefined : this._isOnline && this._isAuthenticated !== false;
	  }

	  /**
	   * Indicates if the connection is online according to the last call to checkConnection().<br><br>
	   * 
	   * Note: must call checkConnection() manually unless using MoneroConnectionManager.
	   * 
	   * @return {boolean|undefined} true or false to indicate if online, or undefined if checkConnection() has not been called
	   */
	  isOnline() {
	    return this._isOnline;
	  }

	  /**
	   * Indicates if the connection is authenticated according to the last call to checkConnection().<br><br>
	   * 
	   * Note: must call checkConnection() manually unless using MoneroConnectionManager.
	   * 
	   * @return {boolean|undefined} true if authenticated or no authentication, false if not authenticated, or undefined if checkConnection() has not been called
	   */
	  isAuthenticated() {
	    return this._isAuthenticated;
	  }

	  getResponseTime() {
	    return this._responseTime;
	  }
	  
	  /**
	   * Send a JSON RPC request.
	   * 
	   * @param {string} method - JSON RPC method to invoke
	   * @param {object} params - request parameters
	   * @param {int} timeoutInMs - request timeout in milliseconds
	   * @return {object} is the response map
	   */
	  async sendJsonRequest(method, params, timeoutInMs) {
	    try {
	      
	      // build request body
	      let body = JSON.stringify({  // body is stringified so text/plain is returned so BigIntegers are preserved
	        id: "0",
	        jsonrpc: "2.0",
	        method: method,
	        params: params
	      });
	      
	      // send http request
	      if (LibraryUtils.getLogLevel() >= 2) LibraryUtils.log(2, "Sending json request with method '" + method + "' and body: " + body);
	      let resp = await HttpClient.request({
	        method: "POST",
	        uri: this.getUri() + '/json_rpc',
	        username: this.getUsername(),
	        password: this.getPassword(),
	        body: body,
	        timeout: timeoutInMs,
	        rejectUnauthorized: this._config.rejectUnauthorized,
	        requestApi: GenUtils.isFirefox() ? "xhr" : "fetch",  // firefox issue: https://bugzilla.mozilla.org/show_bug.cgi?id=1491010
	        proxyToWorker: this._config.proxyToWorker
	      });
	      
	      // validate response
	      MoneroRpcConnection._validateHttpResponse(resp);
	      
	      // deserialize response
	      if (resp.body[0] != '{') throw resp.body;
	      resp = JSON.parse(resp.body.replace(/("[^"]*"\s*:\s*)(\d{16,})/g, '$1"$2"'));  // replace 16 or more digits with strings and parse
	      if (LibraryUtils.getLogLevel() >= 3) {
	        let respStr = JSON.stringify(resp);
	        LibraryUtils.log(3, "Received response: " + respStr.substring(0, Math.min(1000, respStr.length)));
	      }
	      
	      // check rpc response for errors
	      MoneroRpcConnection._validateRpcResponse(resp, method, params);
	      return resp;
	    } catch (err) {
	      if (err instanceof MoneroRpcError) throw err;
	      else throw new MoneroRpcError(err, err.statusCode, method, params);
	    }
	  }
	  
	  /**
	   * Send a RPC request to the given path and with the given paramters.
	   * 
	   * E.g. "/get_transactions" with params
	   * 
	   * @param {string} path - JSON RPC path to invoke
	   * @param {object} params - request parameters
	   * @param {int} timeoutInMs - request timeout in milliseconds
	   * @return {object} is the response map
	   */
	  async sendPathRequest(path, params, timeoutInMs) {
	    try {
	      
	      // send http request
	      if (LibraryUtils.getLogLevel() >= 2) LibraryUtils.log(2, "Sending path request with path '" + path + "' and params: " + JSON.stringify(params));
	      let resp = await HttpClient.request({
	        method: "POST",
	        uri: this.getUri() + '/' + path,
	        username: this.getUsername(),
	        password: this.getPassword(),
	        body: JSON.stringify(params),  // body is stringified so text/plain is returned so BigIntegers are preserved
	        timeout: timeoutInMs,
	        rejectUnauthorized: this._config.rejectUnauthorized,
	        requestApi: GenUtils.isFirefox() ? "xhr" : "fetch",
	        proxyToWorker: this._config.proxyToWorker
	      });
	      
	      // validate response
	      MoneroRpcConnection._validateHttpResponse(resp);
	      
	      // deserialize response
	      if (resp.body[0] != '{') throw resp.body;
	      resp = JSON.parse(resp.body.replace(/("[^"]*"\s*:\s*)(\d{16,})/g, '$1"$2"'));  // replace 16 or more digits with strings and parse
	      if (typeof resp === "string") resp = JSON.parse(resp);  // TODO: some responses returned as strings?
	      if (LibraryUtils.getLogLevel() >= 3) {
	        let respStr = JSON.stringify(resp);
	        LibraryUtils.log(3, "Received response: " + respStr.substring(0, Math.min(1000, respStr.length)));
	      }
	      
	      // check rpc response for errors
	      MoneroRpcConnection._validateRpcResponse(resp, path, params);
	      return resp;
	    } catch (err) {
	      if (err instanceof MoneroRpcError) throw err;
	      else throw new MoneroRpcError(err, err.statusCode, path, params);
	    }
	  }
	  
	  /**
	   * Send a binary RPC request.
	   * 
	   * @param {string} path - path of the binary RPC method to invoke
	   * @param {object} params - request parameters
	   * @param {int} timeoutInMs - request timeout in milliseconds
	   * @return {Uint8Array} the binary response
	   */
	  async sendBinaryRequest(path, params, timeoutInMs) {
	    
	    // serialize params
	    let paramsBin = await MoneroUtils.jsonToBinary(params);
	    
	    try {
	      
	      // send http request
	      if (LibraryUtils.getLogLevel() >= 2) LibraryUtils.log(2, "Sending binary request with path '" + path + "' and params: " + JSON.stringify(params));
	      let resp = await HttpClient.request({
	        method: "POST",
	        uri: this.getUri() + '/' + path,
	        username: this.getUsername(),
	        password: this.getPassword(),
	        body: paramsBin,
	        timeout: timeoutInMs,
	        rejectUnauthorized: this._config.rejectUnauthorized,
	        requestApi: GenUtils.isFirefox() ? "xhr" : "fetch",
	        proxyToWorker: this._config.proxyToWorker
	      });
	      
	      // validate response
	      MoneroRpcConnection._validateHttpResponse(resp);
	      
	      // process response
	      resp = resp.body;
	      if (!(resp instanceof Uint8Array)) {
	        console.error("resp is not uint8array");
	        console.error(resp);
	      }
	      if (resp.error) throw new MoneroRpcError(resp.error.message, resp.error.code, path, params);
	      return resp;
	    } catch (err) {
	      if (err instanceof MoneroRpcError) throw err;
	      else throw new MoneroRpcError(err, err.statusCode, path, params);
	    }
	  }
	  
	  toString() {
	    return this.getUri() + " (username=" + this.getUsername() + ", password=" + (this.getPassword() ? "***" : this.getPassword()) + ", priority=" + this.getPriority() + ", isOnline=" + this.isOnline() + ", isAuthenticated=" + this.isAuthenticated() + ")";
	  }
	  
	  // ------------------------------ PRIVATE HELPERS --------------------------
	  
	  static _validateHttpResponse(resp) {
	    let code = resp.statusCode;
	    if (code < 200 || code > 299) {
	      let content = resp.body;
	      throw new MoneroRpcError(code + " " + resp.statusText + (!content ? "" : (": " + content)), code, undefined, undefined);
	    }
	  }
	  
	  static _validateRpcResponse(resp, method, params) {
	    if (!resp.error) return;
	    throw new MoneroRpcError(resp.error.message, resp.error.code, method, params);
	  }
	  
	  _setFakeDisconnected(fakeDisconnected) { // used to test connection manager
	    this._fakeDisconnected = fakeDisconnected; 
	  }
	}

	/**
	 * Default RPC configuration.
	 */
	MoneroRpcConnection.DEFAULT_CONFIG = {
	    uri: undefined,
	    username: undefined,
	    password: undefined,
	    rejectUnauthorized: true, // reject self-signed certificates if true
	    proxyToWorker: false,
	    priority: 0
	};

	MoneroRpcConnection.SUPPORTED_FIELDS = ["uri", "username", "password", "rejectUnauthorized", "priority", "proxyToWorker"];

	MoneroRpcConnection_1 = MoneroRpcConnection;
	return MoneroRpcConnection_1;
}

/**
 * SSL options for remote endpoints.
 */

class SslOptions {
  
  constructor(state) {
    this.state = Object.assign({}, state);
  }
  
  getPrivateKeyPath() {
    return this.state.privateKeyPath;
  }
  
  setPrivateKeyPath(privateKeyPath) {
    this.state.privateKeyPath = privateKeyPath;
    return this;
  }
  
  getCertificatePath() {
    return this.state.certificatePath;
  }
  
  setCertificatePath(certificatePath) {
    this.state.certificatePath = certificatePath;
    return this;
  }
  
  getCertificateAuthorityFile() {
    return this.state.certificateAuthorityFile;
  }
  
  setCertificateAuthorityFile(certificateAuthorityFile) {
    this.state.certificateAuthorityFile = certificateAuthorityFile;
    return this;
  }
  
  getAllowedFingerprints() {
    return this.state.allowedFingerprints;
  }
  
  setAllowedFingerprints(allowedFingerprints) {
    this.state.allowedFingerprints = allowedFingerprints;
    return this;
  }
  
  getAllowAnyCert() {
    return this.state.allowAnyCert;
  }
  
  setAllowAnyCert(allowAnyCert) {
    this.state.allowAnyCert = allowAnyCert;
    return this;
  }
}

var SslOptions_1 = SslOptions;

/**
 * Run a task in a fixed period loop.
 */

class TaskLooper {
  
  /**
   * Build the looper with a function to invoke on a fixed period loop.
   * 
   * @param {function} fn - the function to invoke
   */
  constructor(fn) {
    this.fn = fn;
  }
  
  /**
   * Start the task loop.
   * 
   * @param {int} periodInMs the loop period in milliseconds
   */
  start(periodInMs) {
    this.periodInMs = periodInMs;
    if (this.isStarted) return;
    this.isStarted = true;
    
    // start looping
    this._runLoop();
  }
  
  /**
   * Stop the task loop.
   */
  stop() {
    this.isStarted = false;
  }
  
  /**
   * Set the loop period in milliseconds.
   * 
   * @param {int} periodInMs the loop period in milliseconds
   */
  setPeriodInMs(periodInMs) {
    this.periodInMs = periodInMs;
  }
  
  async _runLoop() {
    if (this.isLooping) return;
    this.isLooping = true;
    let that = this;
    while (this.isStarted) {
      let startTime = Date.now();
      await this.fn();
      if (this.isStarted) await new Promise(function(resolve) { setTimeout(resolve, that.periodInMs - (Date.now() - startTime)); });
    }
    this.isLooping = false;
  }
}

var TaskLooper_1 = TaskLooper;

const assert$e = require$$0;

/**
 * Enumerates connection types.
 * 
 * Based on enums.h in monero-project.
 * 
 * @hideconstructor
 */
class ConnectionType {
    
  /**
   * Asserts that the given connection type is valid.
   */
  static validate(type) {
    assert$e(type === 0 || type === 1 || type === 2 || type === 3, "Connection type is invalid: " + type);
  }
  
  /**
   * Indicates if the given connection type is valid or not.
   */
  static isValid(type) {
    return type === 0 || type === 1 || type === 2 || 3;
  }
}

/**
 * Invalid connection type (value=0).
 */
ConnectionType.INVALID = 0;

/**
 * IPV4 connection type (value=1).
 */
ConnectionType.IPV4 = 1;

/**
 * IPV6 connection type (value=2).
 */
ConnectionType.IPV6 = 2;

/**
 * TOR connection type (value=3).
 */
ConnectionType.TOR = 3;

/**
 * I2P connection type (value=4).
 */
ConnectionType.I2P = 4;

var ConnectionType_1 = ConnectionType;

const BigInteger$l = biginteger.BigInteger;

/**
 * Models an alternative chain seen by the node.
 */
class MoneroAltChain {
  
  constructor(state) {
    state = Object.assign({}, state);
    if (state.difficulty !== undefined && !(state.difficulty instanceof BigInteger$l)) state.difficulty = BigInteger$l.parse(state.difficulty);
    this.state = state;
  }
  
  toJson() {
    let json = Object.assign({}, this.state);
    if (this.getDifficulty()) json.difficulty = this.getDifficulty().toString();
    return json;
  }
  
  getBlockHashes(blockHashes) {
    return this.state.blockHashes;
  }
  
  setBlockHashes(blockHashes) {
    this.state.blockHashes = blockHashes;
    return this;
  }
  
  getDifficulty() {
    return this.state.difficulty;
  }
  
  setDifficulty(difficulty) {
    this.state.difficulty = difficulty;
    return this;
  }
  
  getHeight() {
    return this.state.height;
  }
  
  setHeight(height) {
    this.state.height = height;
    return this;
  }
  
  getLength() {
    return this.state.length;
  }
  
  setLength(length) {
    this.state.length = length;
    return this;
  }
  
  getMainChainParentBlockHash() {
    return this.state.mainChainParentBlockHash;
  }
  
  setMainChainParentBlockHash(mainChainParentBlockHash) {
    this.state.mainChainParentBlockHash = mainChainParentBlockHash;
    return this;
  }
}

var MoneroAltChain_1 = MoneroAltChain;

/**
 * Monero banhammer.
 */

class MoneroBan {
  
  constructor(state) {
    this.state = Object.assign({}, state);
  }
  
  toJson() {
    return Object.assign({}, this.state);
  }
  
  getHost() {
    return this.state.host;
  }
  
  setHost(host) {
    this.state.host = host;
    return this;
  }
  
  getIp() {
    return this.state.ip;
  }
  
  setIp(ip) {
    this.state.ip = ip;
    return this;
  }
  
  isBanned() {
    return this.state.isBanned;
  }
  
  setIsBanned(isBanned) {
    this.state.isBanned = isBanned;
    return this;
  }
  
  getSeconds() {
    return this.state.seconds;
  }
  
  setSeconds(seconds) {
    this.state.seconds = seconds;
    return this;
  }
}

var MoneroBan_1 = MoneroBan;

const assert$d = require$$0;
const BigInteger$k = biginteger.BigInteger;
const GenUtils$b = GenUtils_1;

/**
 * Models a Monero block header which contains information about the block.
 * 
 * @class
 */
class MoneroBlockHeader$1 {
  
  /**
   * Construct the model.
   * 
   * @param {MoneroBlockHeader|object} state is existing state to initialize from (optional)
   */
  constructor(state) {
    
    // initialize internal state
    if (!state) state = {};
    else if (state instanceof MoneroBlockHeader$1) state = state.toJson();
    else if (typeof state === "object") state = Object.assign({}, state);
    else throw new MoneroError("state must be a MoneroBlockHeader or JavaScript object");
    this.state = state;
    
    // deserialize BigIntegers
    if (state.difficulty !== undefined && !(state.difficulty instanceof BigInteger$k)) state.difficulty = BigInteger$k.parse(state.difficulty);
    if (state.cumulativeDifficulty !== undefined && !(state.cumulativeDifficulty instanceof BigInteger$k)) state.cumulativeDifficulty = BigInteger$k.parse(state.cumulativeDifficulty);
    if (state.reward !== undefined && !(state.reward instanceof BigInteger$k)) state.reward = BigInteger$k.parse(state.reward);
  }
  
  copy() {
    return new MoneroBlockHeader$1(this);
  }
  
  toJson() {
    let json = Object.assign({}, this.state);
    if (this.getDifficulty()) json.difficulty = this.getDifficulty().toString();
    if (this.getCumulativeDifficulty()) json.cumulativeDifficulty = this.getCumulativeDifficulty().toString();
    if (this.getReward()) json.reward = this.getReward().toString();
    return json;
  }
  
  getHash() {
    return this.state.hash;
  }
  
  setHash(hash) {
    this.state.hash = hash;
    return this;
  }
  
  /**
   * Return the block's height which is the total number of blocks that have occurred before.
   * 
   * @return {number} the block's height
   */
  getHeight() {
    return this.state.height;
  }
  
  /**
   * Set the block's height which is the total number of blocks that have occurred before.
   * 
   * @param {number} height is the block's height to set
   * @return {MoneroBlockHeader} a reference to this header for chaining
   */
  setHeight(height) {
    this.state.height = height;
    return this;
  }
  
  getTimestamp() {
    return this.state.timestamp;
  }
  
  setTimestamp(timestamp) {
    this.state.timestamp = timestamp;
    return this;
  }
  
  getSize() {
    return this.state.size;
  }
  
  setSize(size) {
    this.state.size = size;
    return this;
  }
  
  getWeight() {
    return this.state.weight;
  }
  
  setWeight(weight) {
    this.state.weight = weight;
    return this;
  }
  
  getLongTermWeight() {
    return this.state.longTermWeight;
  }
  
  setLongTermWeight(longTermWeight) {
    this.state.longTermWeight = longTermWeight;
    return this;
  }
  
  getDepth() {
    return this.state.depth;
  }
  
  setDepth(depth) {
    this.state.depth = depth;
    return this;
  }
  
  getDifficulty() {
    return this.state.difficulty;
  }
  
  setDifficulty(difficulty) {
    this.state.difficulty = difficulty;
    return this;
  }
  
  getCumulativeDifficulty() {
    return this.state.cumulativeDifficulty;
  }
  
  setCumulativeDifficulty(cumulativeDifficulty) {
    this.state.cumulativeDifficulty = cumulativeDifficulty;
    return this;
  }
  
  getMajorVersion() {
    return this.state.majorVersion;
  }
  
  setMajorVersion(majorVersion) {
    this.state.majorVersion = majorVersion;
    return this;
  }
  
  getMinorVersion() {
    return this.state.minorVersion;
  }
  
  setMinorVersion(minorVersion) {
    this.state.minorVersion = minorVersion;
    return this;
  }
  
  getNonce() {
    return this.state.nonce;
  }
  
  setNonce(nonce) {
    this.state.nonce = nonce;
    return this;
  }
  
  getMinerTxHash() {
    return this.state.minerTxHash;
  }
  
  setMinerTxHash(minerTxHash) {
    this.state.minerTxHash = minerTxHash;
    return this;
  }
  
  getNumTxs() {
    return this.state.numTxs;
  }
  
  setNumTxs(numTxs) {
    this.state.numTxs = numTxs;
    return this;
  }
  
  getOrphanStatus() {
    return this.state.orphanStatus;
  }
  
  setOrphanStatus(orphanStatus) {
    this.state.orphanStatus = orphanStatus;
    return this;
  }
  
  getPrevHash() {
    return this.state.prevHash;
  }
  
  setPrevHash(prevHash) {
    this.state.prevHash = prevHash;
    return this;
  }
  
  getReward() {
    return this.state.reward;
  }
  
  setReward(reward) {
    this.state.reward = reward;
    return this;
  }
  
  getPowHash() {
    return this.state.powHash;
  }
  
  setPowHash(powHash) {
    this.state.powHash = powHash;
    return this;
  }
  
  merge(header) {
    assert$d(header instanceof MoneroBlockHeader$1);
    if (this === header) return this;
    this.setHash(GenUtils$b.reconcile(this.getHash(), header.getHash()));
    this.setHeight(GenUtils$b.reconcile(this.getHeight(), header.getHeight(), {resolveMax: true}));  // height can increase
    this.setTimestamp(GenUtils$b.reconcile(this.getTimestamp(), header.getTimestamp(), {resolveMax: true}));  // block timestamp can increase
    this.setSize(GenUtils$b.reconcile(this.getSize(), header.getSize()));
    this.setWeight(GenUtils$b.reconcile(this.getWeight(), header.getWeight()));
    this.setDepth(GenUtils$b.reconcile(this.getDepth(), header.getDepth()));
    this.setDifficulty(GenUtils$b.reconcile(this.getDifficulty(), header.getDifficulty()));
    this.setCumulativeDifficulty(GenUtils$b.reconcile(this.getCumulativeDifficulty(), header.getCumulativeDifficulty()));
    this.setMajorVersion(GenUtils$b.reconcile(this.getMajorVersion(), header.getMajorVersion()));
    this.setMinorVersion(GenUtils$b.reconcile(this.getMinorVersion(), header.getMinorVersion()));
    this.setNonce(GenUtils$b.reconcile(this.getNonce(), header.getNonce()));
    this.setMinerTxHash(GenUtils$b.reconcile(this.getMinerTxHash(), header.getMinerTxHash()));
    this.setNumTxs(GenUtils$b.reconcile(this.getNumTxs(), header.getNumTxs()));
    this.setOrphanStatus(GenUtils$b.reconcile(this.getOrphanStatus(), header.getOrphanStatus()));
    this.setPrevHash(GenUtils$b.reconcile(this.getPrevHash(), header.getPrevHash()));
    this.setReward(GenUtils$b.reconcile(this.getReward(), header.getReward()));
    this.setPowHash(GenUtils$b.reconcile(this.getPowHash(), header.getPowHash()));
    return this;
  }
  
  toString(indent = 0) {
    let str = "";
    str += GenUtils$b.kvLine("Hash", this.getHash(), indent);
    str += GenUtils$b.kvLine("Height", this.getHeight(), indent);
    str += GenUtils$b.kvLine("Timestamp", this.getTimestamp(), indent);
    str += GenUtils$b.kvLine("Size", this.getSize(), indent);
    str += GenUtils$b.kvLine("Weight", this.getWeight(), indent);
    str += GenUtils$b.kvLine("Depth", this.getDepth(), indent);
    str += GenUtils$b.kvLine("Difficulty", this.getDifficulty(), indent);
    str += GenUtils$b.kvLine("Cumulative difficulty", this.getCumulativeDifficulty(), indent);
    str += GenUtils$b.kvLine("Major version", this.getMajorVersion(), indent);
    str += GenUtils$b.kvLine("Minor version", this.getMinorVersion(), indent);
    str += GenUtils$b.kvLine("Nonce", this.getNonce(), indent);
    str += GenUtils$b.kvLine("Miner tx hash", this.getMinerTxHash(), indent);
    str += GenUtils$b.kvLine("Num txs", this.getNumTxs(), indent);
    str += GenUtils$b.kvLine("Orphan status", this.getOrphanStatus(), indent);
    str += GenUtils$b.kvLine("Prev hash", this.getPrevHash(), indent);
    str += GenUtils$b.kvLine("Reward", this.getReward(), indent);
    str += GenUtils$b.kvLine("Pow hash", this.getPowHash(), indent);
    return str[str.length - 1] === "\n" ? str.slice(0, str.length - 1) : str  // strip last newline
  }
}

var MoneroBlockHeader_1 = MoneroBlockHeader$1;

const assert$c = require$$0;
const GenUtils$a = GenUtils_1;

/**
 * Models a Monero key image.
 */
class MoneroKeyImage$2 {
  
  /**
   * Construct the model.
   * 
   * @param {MoneroKeyImage|object|string} stateOrHex is a MoneroKeyImage, JS object, or hex string to initialize from (optional)
   * @param {string} signature is the key image's signature
   */
  constructor(stateOrHex, signature) {
    if (!stateOrHex) this.state = {};
    else if (stateOrHex instanceof MoneroKeyImage$2) this.state = stateOrHex.toJson();
    else if (typeof stateOrHex === "object") this.state = Object.assign({}, stateOrHex);
    else if (typeof stateOrHex === "string") {
      this.state = {};
      this.setHex(stateOrHex);
      this.setSignature(signature);
    } else {
      throw new MoneroError("stateOrHex must be a MoneroKeyImage, JavaScript object, or string");
    }
  }

  getHex() {
    return this.state.hex;
  }

  setHex(hex) {
    this.state.hex = hex;
    return this;
  }

  getSignature() {
    return this.state.signature;
  }

  setSignature(signature) {
    this.state.signature = signature;
    return this;
  }
  
  copy() {
    return new MoneroKeyImage$2(this);
  }
  
  toJson() {
    return Object.assign({}, this.state);
  }
  
  merge(keyImage) {
    assert$c(keyImage instanceof MoneroKeyImage$2);
    if (keyImage === this) return this;
    this.setHex(GenUtils$a.reconcile(this.getHex(), keyImage.getHex()));
    this.setSignature(GenUtils$a.reconcile(this.getSignature(), keyImage.getSignature()));
    return this;
  }
  
  toString(indent = 0) {
    let str = "";
    str += GenUtils$a.kvLine("Hex", this.getHex(), indent);
    str += GenUtils$a.kvLine("Signature", this.getSignature(), indent);
    return str.slice(0, str.length - 1);  // strip last newline
  }
}

var MoneroKeyImage_1 = MoneroKeyImage$2;

const assert$b = require$$0;
const BigInteger$j = biginteger.BigInteger;
const GenUtils$9 = GenUtils_1;
const MoneroKeyImage$1 = MoneroKeyImage_1;

/**
 * Models a Monero transaction output.
 * 
 * @class
 */
class MoneroOutput$2 {
  
  /**
   * Construct the model.
   * 
   * @param {MoneroOutput|object} state is existing state to initialize from (optional)
   */
  constructor(state) {
    
    // initialize internal state
    if (!state) state = {};
    else if (state instanceof MoneroOutput$2) state = state.toJson();
    else if (typeof state === "object") state = Object.assign({}, state);
    else throw new MoneroError("state must be a MoneroOutput or JavaScript object");
    this.state = state;
    
    // deserialize fields if necessary
    if (state.amount !== undefined && !(state.amount instanceof BigInteger$j)) state.amount = BigInteger$j.parse(state.amount);
    if (state.keyImage && !(state.keyImage instanceof MoneroKeyImage$1)) state.keyImage = new MoneroKeyImage$1(state.keyImage);
  }
  
  getTx() {
    return this.state.tx;
  }
  
  setTx(tx) {
    this.state.tx = tx;
    return this;
  }
  
  getKeyImage() {
    return this.state.keyImage;
  }

  setKeyImage(keyImage) {
    assert$b(keyImage === undefined || keyImage instanceof MoneroKeyImage$1);
    this.state.keyImage = keyImage;
    return this;
  }
  
  getAmount() {
    return this.state.amount;
  }

  setAmount(amount) {
    this.state.amount = amount;
    return this;
  }
  
  getIndex() {
    return this.state.index;
  }
  
  setIndex(index) {
    this.state.index = index;
    return this;
  }
  
  getRingOutputIndices() {
    return this.state.ringOutputIndices;
  }
  
  setRingOutputIndices(ringOutputIndices) {
    this.state.ringOutputIndices = ringOutputIndices;
    return this;
  }
  
  getStealthPublicKey() {
    return this.state.stealthPublicKey;
  }
  
  setStealthPublicKey(stealthPublicKey) {
    this.state.stealthPublicKey = stealthPublicKey;
    return this;
  }
  
  copy() {
    return new MoneroOutput$2(this);
  }
  
  toJson() {
    let json = Object.assign({}, this.state);
    if (this.getAmount()) json.amount = this.getAmount() ? this.getAmount().toString() : undefined;
    if (this.getKeyImage()) json.keyImage = this.getKeyImage() ? this.getKeyImage().toJson() : undefined;
    delete json.tx;
    return json;
  }
  
  merge(output) {
    assert$b(output instanceof MoneroOutput$2);
    if (this === output) return this;
    
    // merge txs if they're different which comes back to merging outputs
    if (this.getTx() !== output.getTx()) this.getTx().merge(output.getTx());
    
    // otherwise merge output fields
    else {
      if (this.getKeyImage() === undefined) this.setKeyImage(output.getKeyImage());
      else if (output.getKeyImage() !== undefined) this.getKeyImage().merge(output.getKeyImage());
      this.setAmount(GenUtils$9.reconcile(this.getAmount(), output.getAmount()));
      this.setIndex(GenUtils$9.reconcile(this.getIndex(), output.getIndex()));
    }

    return this;
  }
  
  toString(indent = 0) {
    let str = "";
    if (this.getKeyImage()) {
      str += GenUtils$9.kvLine("Key image", "", indent);
      str += this.getKeyImage().toString(indent + 1) + "\n";
    }
    str += GenUtils$9.kvLine("Amount", this.getAmount(), indent);
    str += GenUtils$9.kvLine("Index", this.getIndex(), indent);
    str += GenUtils$9.kvLine("Ring output indices", this.getRingOutputIndices(), indent);
    str += GenUtils$9.kvLine("Stealth public key", this.getStealthPublicKey(), indent);
    return str === "" ? str : str.slice(0, str.length - 1);  // strip last newline
  }
}

var MoneroOutput_1 = MoneroOutput$2;

const assert$a = require$$0;
const BigInteger$i = biginteger.BigInteger;
const GenUtils$8 = GenUtils_1;
const MoneroOutput$1 = MoneroOutput_1;

/**
 * Represents a transaction on the Monero network.
 * 
 * @class
 */
class MoneroTx$1 {
  
  /**
   * Construct the model.
   * 
   * @param {MoneroTx|object} state is existing state to initialize from (optional)
   */
  constructor(state) {
    
    // initialize internal state
    if (!state) state = {};
    else if (state instanceof MoneroTx$1) state = state.toJson();
    else if (typeof state === "object") state = Object.assign({}, state);
    else throw new MoneroError("state must be a MoneroTx or JavaScript object");
    this.state = state;
    
    // deserialize fee
    if (state.fee !== undefined && !(state.fee instanceof BigInteger$i)) state.fee = BigInteger$i.parse(state.fee);
    
    // deserialize inputs
    if (state.inputs) {
      for (let i = 0; i < state.inputs.length; i++) {
        if (!(state.inputs[i] instanceof MoneroOutput$1)) {
          state.inputs[i] = new MoneroOutput$1(Object.assign(state.inputs[i], {tx: this}));
        }
      }
    }
    
    // deserialize outputs
    if (state.outputs) {
      for (let i = 0; i < state.outputs.length; i++) {
        if (!(state.outputs[i] instanceof MoneroOutput$1)) {
          state.outputs[i] = new MoneroOutput$1(Object.assign(state.outputs[i], {tx: this}));
        }
      }
    }
  }
  
  getBlock() {
    return this.state.block;
  }
  
  setBlock(block) {
    this.state.block = block;
    return this;
  }
  
  getHeight() {
    return this.getBlock() === undefined ? undefined : this.getBlock().getHeight();
  }
  
  getHash() {
    return this.state.hash;
  }
  
  setHash(hash) {
    this.state.hash = hash;
    return this;
  }
  
  getVersion() {
    return this.state.version;
  }
  
  setVersion(version) {
    this.state.version = version;
    return this;
  }
  
  isMinerTx() {
    return this.state.isMinerTx;
  }
  
  setIsMinerTx(miner) {
    this.state.isMinerTx = miner;
    return this;
  }
  
  getPaymentId() {
    return this.state.paymentId;
  }
  
  setPaymentId(paymentId) {
    this.state.paymentId = paymentId;
    return this;
  }
  
  getFee() {
    return this.state.fee;
  }
  
  setFee(fee) {
    this.state.fee = fee;
    return this;
  }
  
  getRingSize() {
    return this.state.ringSize;
  }
  
  setRingSize(ringSize) {
    this.state.ringSize = ringSize;
    return this;
  }
  
  getRelay() {
    return this.state.relay;
  }
  
  setRelay(relay) {
    this.state.relay = relay;
    return this;
  }
  
  isRelayed() {
    return this.state.isRelayed;
  }
  
  setIsRelayed(isRelayed) {
    this.state.isRelayed = isRelayed;
    return this;
  }
  
  isConfirmed() {
    return this.state.isConfirmed;
  }
  
  setIsConfirmed(isConfirmed) {
    this.state.isConfirmed = isConfirmed;
    return this;
  }
  
  inTxPool() {
    return this.state.inTxPool;
  }
  
  setInTxPool(inTxPool) {
    this.state.inTxPool = inTxPool;
    return this;
  }
  
  getNumConfirmations() {
    return this.state.numConfirmations;
  }
  
  setNumConfirmations(numConfirmations) {
    this.state.numConfirmations = numConfirmations;
    return this;
  }
  
  getUnlockHeight() {
    return this.state.unlockHeight;
  }
  
  setUnlockHeight(unlockHeight) {
    this.state.unlockHeight = unlockHeight;
    return this;
  }
  
  getLastRelayedTimestamp() {
    return this.state.lastRelayedTimestamp;
  }
  
  setLastRelayedTimestamp(lastRelayedTimestamp) {
    this.state.lastRelayedTimestamp = lastRelayedTimestamp;
    return this;
  }
  
  getReceivedTimestamp() {
    return this.state.receivedTimestamp;
  }
  
  setReceivedTimestamp(receivedTimestamp) {
    this.state.receivedTimestamp = receivedTimestamp;
    return this;
  }
  
  isDoubleSpendSeen() {
    return this.state.isDoubleSpendSeen;
  }
  
  setIsDoubleSpend(isDoubleSpendSeen) {
    this.state.isDoubleSpendSeen = isDoubleSpendSeen;
    return this;
  }
  
  getKey() {
    return this.state.key;
  }
  
  setKey(key) {
    this.state.key = key;
    return this;
  }
  
  /**
   * Get full transaction hex.  Full hex = pruned hex + prunable hex.
   * 
   * @return {string} is full transaction hex
   */
  getFullHex() {
    return this.state.fullHex;
  }
  
  setFullHex(fullHex) {
    this.state.fullHex = fullHex;
    return this;
  }
  
  /**
   * Get pruned transaction hex.  Full hex = pruned hex + prunable hex.
   * 
   * @return {string} is pruned transaction hex
   */
  getPrunedHex() {
    return this.state.prunedHex;
  }
  
  setPrunedHex(prunedHex) {
    this.state.prunedHex = prunedHex;
    return this;
  }
  
  /**
   * Get prunable transaction hex which is hex that is removed from a pruned
   * transaction. Full hex = pruned hex + prunable hex.
   * 
   * @return {string} is the prunable transaction hex
   */
  getPrunableHex() {
    return this.state.prunableHex;
  }
  
  setPrunableHex(prunableHex) {
    this.state.prunableHex = prunableHex;
    return this;
  }
  
  getPrunableHash() {
    return this.state.prunableHash;
  }
  
  setPrunableHash(prunableHash) {
    this.state.prunableHash = prunableHash;
    return this;
  }
  
  getSize() {
    return this.state.size;
  }
  
  setSize(size) {
    this.state.size = size;
    return this;
  }
  
  getWeight() {
    return this.state.weight;
  }
  
  setWeight(weight) {
    this.state.weight = weight;
    return this;
  }
  
  getInputs() {
    return this.state.inputs;
  }
  
  setInputs(inputs) {
    this.state.inputs = inputs;
    return this;
  }
  
  getOutputs() {
    return this.state.outputs;
  }
  
  setOutputs(outputs) {
    this.state.outputs = outputs;
    return this;
  }
  
  getOutputIndices() {
    return this.state.outputIndices;
  }
  
  setOutputIndices(outputIndices) {
    this.state.outputIndices = outputIndices;
    return this;
  }
  
  getMetadata() {
    return this.state.metadata;
  }
  
  setMetadata(metadata) {
    this.state.metadata = metadata;
    return this;
  }
  
  getExtra() {
    return this.state.extra;
  }
  
  setExtra(extra) {
    this.state.extra = extra;
    return this;
  }

  getRctSignatures() {
    return this.state.rctSignatures;
  }
  
  setRctSignatures(rctSignatures) {
    this.state.rctSignatures = rctSignatures;
    return this;
  }
  
  getRctSigPrunable() {
    return this.state.rctSigPrunable;
  }
  
  setRctSigPrunable(rctSigPrunable) {
    this.state.rctSigPrunable = rctSigPrunable;
    return this;
  }
  
  isKeptByBlock() {
    return  this.state.isKeptByBlock;
  }
  
  setIsKeptByBlock(isKeptByBlock) {
    this.state.isKeptByBlock = isKeptByBlock;
    return this;
  }
  
  isFailed() {
    return this.state.isFailed;
  }
  
  setIsFailed(isFailed) {
    this.state.isFailed = isFailed;
    return this;
  }
  
  getLastFailedHeight() {
    return this.state.lastFailedHeight;
  }
  
  setLastFailedHeight(lastFailedHeight) {
    this.state.lastFailedHeight = lastFailedHeight;
    return this;
  }
  
  getLastFailedHash() {
    return this.state.lastFailedHash;
  }
  
  setLastFailedHash(lastFailedHash) {
    this.state.lastFailedHash = lastFailedHash;
    return this;
  }
  
  getMaxUsedBlockHeight() {
    return this.state.maxUsedBlockHeight;
  }
  
  setMaxUsedBlockHeight(maxUsedBlockHeight) {
    this.state.maxUsedBlockHeight = maxUsedBlockHeight;
    return this;
  }
  
  getMaxUsedBlockHash() {
    return this.state.maxUsedBlockHash;
  }
  
  setMaxUsedBlockHash(maxUsedBlockHash) {
    this.state.maxUsedBlockHash = maxUsedBlockHash;
    return this;
  }
  
  getSignatures() {
    return this.state.signatures;
  }
  
  setSignatures(signatures) {
    this.state.signatures = signatures;
    return this;
  }
  
  copy() {
    return new MoneroTx$1(this);
  }
  
  toJson() {
    let json = Object.assign({}, this.state);
    if (this.getFee()) json.fee = this.getFee().toString();
    if (this.getInputs()) {
      json.inputs = [];
      for (let input of this.getInputs()) json.inputs.push(input.toJson());
    }
    if (this.getOutputs()) {
      json.outputs = [];
      for (let output of this.getOutputs()) json.outputs.push(output.toJson());
    }
    if (this.getExtra()) json.extra = this.getExtra().slice();
    delete json.block;  // do not serialize parent block
    return json;
  }
  
  /**
   * Updates this transaction by merging the latest information from the given
   * transaction.
   * 
   * @param tx is the transaction to update this transaction with
   * @return {MoneroTx} this for method chaining
   */
  merge(tx) {
    assert$a(tx instanceof MoneroTx$1);
    if (this === tx) return this;
    
    // merge blocks if they're different
    if (this.getBlock() !== tx.getBlock()) {
      if (this.getBlock() === undefined) {
        this.setBlock(tx.getBlock());
        this.getBlock().getTxs[this.getBlock().getTxs().indexOf(tx)] = this; // update block to point to this tx
      } else if (tx.getBlock() !== undefined) {
        this.getBlock().merge(tx.getBlock()); // comes back to merging txs
        return this;
      }
    }
    
    // otherwise merge tx fields
    this.setHash(GenUtils$8.reconcile(this.getHash(), tx.getHash()));
    this.setVersion(GenUtils$8.reconcile(this.getVersion(), tx.getVersion()));
    this.setPaymentId(GenUtils$8.reconcile(this.getPaymentId(), tx.getPaymentId()));
    this.setFee(GenUtils$8.reconcile(this.getFee(), tx.getFee()));
    this.setRingSize(GenUtils$8.reconcile(this.getRingSize(), tx.getRingSize()));
    this.setIsConfirmed(GenUtils$8.reconcile(this.isConfirmed(), tx.isConfirmed(), {resolveTrue: true})); // tx can become confirmed
    this.setIsMinerTx(GenUtils$8.reconcile(this.isMinerTx(), tx.isMinerTx(), null, null, null));
    this.setRelay(GenUtils$8.reconcile(this.getRelay(), tx.getRelay(), {resolveTrue: true}));       // tx can become relayed
    this.setIsRelayed(GenUtils$8.reconcile(this.isRelayed(), tx.isRelayed(), {resolveTrue: true})); // tx can become relayed
    this.setIsDoubleSpend(GenUtils$8.reconcile(this.isDoubleSpendSeen(), tx.isDoubleSpendSeen(), {resolveTrue: true})); // double spend can become seen
    this.setKey(GenUtils$8.reconcile(this.getKey(), tx.getKey()));
    this.setFullHex(GenUtils$8.reconcile(this.getFullHex(), tx.getFullHex()));
    this.setPrunedHex(GenUtils$8.reconcile(this.getPrunedHex(), tx.getPrunedHex()));
    this.setPrunableHex(GenUtils$8.reconcile(this.getPrunableHex(), tx.getPrunableHex()));
    this.setPrunableHash(GenUtils$8.reconcile(this.getPrunableHash(), tx.getPrunableHash()));
    this.setSize(GenUtils$8.reconcile(this.getSize(), tx.getSize()));
    this.setWeight(GenUtils$8.reconcile(this.getWeight(), tx.getWeight()));
    this.setOutputIndices(GenUtils$8.reconcile(this.getOutputIndices(), tx.getOutputIndices()));
    this.setMetadata(GenUtils$8.reconcile(this.getMetadata(), tx.getMetadata()));
    this.setExtra(GenUtils$8.reconcile(this.getExtra(), tx.getExtra()));
    this.setRctSignatures(GenUtils$8.reconcile(this.getRctSignatures(), tx.getRctSignatures()));
    this.setRctSigPrunable(GenUtils$8.reconcile(this.getRctSigPrunable(), tx.getRctSigPrunable()));
    this.setIsKeptByBlock(GenUtils$8.reconcile(this.isKeptByBlock(), tx.isKeptByBlock()));
    this.setIsFailed(GenUtils$8.reconcile(this.isFailed(), tx.isFailed()));
    this.setLastFailedHeight(GenUtils$8.reconcile(this.getLastFailedHeight(), tx.getLastFailedHeight()));
    this.setLastFailedHash(GenUtils$8.reconcile(this.getLastFailedHash(), tx.getLastFailedHash()));
    this.setMaxUsedBlockHeight(GenUtils$8.reconcile(this.getMaxUsedBlockHeight(), tx.getMaxUsedBlockHeight()));
    this.setMaxUsedBlockHash(GenUtils$8.reconcile(this.getMaxUsedBlockHash(), tx.getMaxUsedBlockHash()));
    this.setSignatures(GenUtils$8.reconcile(this.getSignatures(), tx.getSignatures()));
    this.setUnlockHeight(GenUtils$8.reconcile(this.getUnlockHeight(), tx.getUnlockHeight()));
    this.setNumConfirmations(GenUtils$8.reconcile(this.getNumConfirmations(), tx.getNumConfirmations(), {resolveMax: true})); // num confirmations can increase
    
    // merge inputs
    if (tx.getInputs()) {
      for (let merger of tx.getInputs()) {
        let merged = false;
        merger.setTx(this);
        if (!this.getInputs()) this.setInputs([]);
        for (let mergee of this.getInputs()) {
          if (mergee.getKeyImage().getHex() === merger.getKeyImage().getHex()) {
            mergee.merge(merger);
            merged = true;
            break;
          }
        }
        if (!merged) this.getInputs().push(merger);
      }
    }
    
    // merge outputs
    if (tx.getOutputs()) {
      for (let output of tx.getOutputs()) output.setTx(this);
      if (!this.getOutputs()) this.setOutputs(tx.getOutputs());
      else {
        
        // merge outputs if key image or stealth public key present, otherwise append
        for (let merger of tx.getOutputs()) {
          let merged = false;
          merger.setTx(this);
          for (let mergee of this.getOutputs()) {
            if ((merger.getKeyImage() && mergee.getKeyImage().getHex() === merger.getKeyImage().getHex()) ||
                (merger.getStealthPublicKey() && mergee.getStealthPublicKey() === merger.getStealthPublicKey())) {
             mergee.merge(merger);
             merged = true;
             break;
            }
          }
          if (!merged) this.getOutputs().push(merger); // append output
        }
      }
    }
    
    // handle unrelayed -> relayed -> confirmed
    if (this.isConfirmed()) {
      this.setInTxPool(false);
      this.setReceivedTimestamp(undefined);
      this.setLastRelayedTimestamp(undefined);
    } else {
      this.setInTxPool(GenUtils$8.reconcile(this.inTxPool(), tx.inTxPool(), {resolveTrue: true})); // unrelayed -> tx pool
      this.setReceivedTimestamp(GenUtils$8.reconcile(this.getReceivedTimestamp(), tx.getReceivedTimestamp(), {resolveMax: false})); // take earliest receive time
      this.setLastRelayedTimestamp(GenUtils$8.reconcile(this.getLastRelayedTimestamp(), tx.getLastRelayedTimestamp(), {resolveMax: true}));  // take latest relay time
    }
    
    return this;  // for chaining
  }
  
  toString(indent = 0) {
    let str = "";
    str += GenUtils$8.getIndent(indent) + "=== TX ===\n";
    str += GenUtils$8.kvLine("Tx hash", this.getHash(), indent);
    str += GenUtils$8.kvLine("Height", this.getHeight(), indent);
    str += GenUtils$8.kvLine("Version", this.getVersion(), indent);
    str += GenUtils$8.kvLine("Is miner tx", this.isMinerTx(), indent);
    str += GenUtils$8.kvLine("Payment ID", this.getPaymentId(), indent);
    str += GenUtils$8.kvLine("Fee", this.getFee(), indent);
    str += GenUtils$8.kvLine("Ring size", this.getRingSize(), indent);
    str += GenUtils$8.kvLine("Relay", this.getRelay(), indent);
    str += GenUtils$8.kvLine("Is relayed", this.isRelayed(), indent);
    str += GenUtils$8.kvLine("Is confirmed", this.isConfirmed(), indent);
    str += GenUtils$8.kvLine("In tx pool", this.inTxPool(), indent);
    str += GenUtils$8.kvLine("Num confirmations", this.getNumConfirmations(), indent);
    str += GenUtils$8.kvLine("Unlock height", this.getUnlockHeight(), indent);
    str += GenUtils$8.kvLine("Last relayed time", this.getLastRelayedTimestamp(), indent);
    str += GenUtils$8.kvLine("Received time", this.getReceivedTimestamp(), indent);
    str += GenUtils$8.kvLine("Is double spend", this.isDoubleSpendSeen(), indent);
    str += GenUtils$8.kvLine("Key", this.getKey(), indent);
    str += GenUtils$8.kvLine("Full hex", this.getFullHex(), indent);
    str += GenUtils$8.kvLine("Pruned hex", this.getPrunedHex(), indent);
    str += GenUtils$8.kvLine("Prunable hex", this.getPrunableHex(), indent);
    str += GenUtils$8.kvLine("Prunable hash", this.getPrunableHash(), indent);
    str += GenUtils$8.kvLine("Size", this.getSize(), indent);
    str += GenUtils$8.kvLine("Weight", this.getWeight(), indent);
    str += GenUtils$8.kvLine("Output indices", this.getOutputIndices(), indent);
    str += GenUtils$8.kvLine("Metadata", this.getMetadata(), indent);
    str += GenUtils$8.kvLine("Extra", this.getExtra(), indent);
    str += GenUtils$8.kvLine("RCT signatures", this.getRctSignatures(), indent);
    str += GenUtils$8.kvLine("RCT sig prunable", this.getRctSigPrunable(), indent);
    str += GenUtils$8.kvLine("Kept by block", this.isKeptByBlock(), indent);
    str += GenUtils$8.kvLine("Is failed", this.isFailed(), indent);
    str += GenUtils$8.kvLine("Last failed height", this.getLastFailedHeight(), indent);
    str += GenUtils$8.kvLine("Last failed hash", this.getLastFailedHash(), indent);
    str += GenUtils$8.kvLine("Max used block height", this.getMaxUsedBlockHeight(), indent);
    str += GenUtils$8.kvLine("Max used block hash", this.getMaxUsedBlockHash(), indent);
    str += GenUtils$8.kvLine("Signatures", this.getSignatures(), indent);
    if (this.getInputs()) {
      str += GenUtils$8.kvLine("Inputs", "", indent);
      for (let i = 0; i < this.getInputs().length; i++) {
        str += GenUtils$8.kvLine(i + 1, "", indent + 1);
        str += this.getInputs()[i].toString(indent + 2);
        str += '\n';
      }
    }
    if (this.getOutputs()) {
      str += GenUtils$8.kvLine("Outputs", "", indent);
      for (let i = 0; i < this.getOutputs().length; i++) {
        str += GenUtils$8.kvLine(i + 1, "", indent + 1);
        str += this.getOutputs()[i].toString(indent + 2);
        str += '\n';
      }
    }
    return str.slice(0, str.length - 1);  // strip last newline
  }
}

// default payment id
MoneroTx$1.DEFAULT_PAYMENT_ID = "0000000000000000";

var MoneroTx_1 = MoneroTx$1;

const assert$9 = require$$0;
const GenUtils$7 = GenUtils_1;
const MoneroOutput = MoneroOutput_1;

/**
 * Models a Monero output with wallet extensions.
 * 
 * @class
 * @extends {MoneroOutput}
 */
class MoneroOutputWallet extends MoneroOutput {
  
  /**
   * Construct the model.
   * 
   * @param {MoneroOutputWallet|object} state is existing state to initialize from (optional)
   */
  constructor(state) {
    super(state);
  }
  
  getAccountIndex() {
    return this.state.accountIndex;
  }

  setAccountIndex(accountIndex) {
    this.state.accountIndex = accountIndex;
    return this;
  }

  getSubaddressIndex() {
    return this.state.subaddressIndex;
  }

  setSubaddressIndex(subaddressIndex) {
    this.state.subaddressIndex = subaddressIndex;
    return this;
  }
  
  isSpent() {
    return this.state.isSpent;
  }

  setIsSpent(isSpent) {
    this.state.isSpent = isSpent;
    return this;
  }
  
  /**
   * Indicates if this output has been deemed 'malicious' and will therefore
   * not be spent by the wallet.
   * 
   * @return Boolean is whether or not this output is frozen
   */
  isFrozen() {
    return this.state.isFrozen;
  }

  setIsFrozen(isFrozen) {
    this.state.isFrozen = isFrozen;
    return this;
  }
  
  isLocked() {
    if (this.getTx() === undefined) return undefined;
    return this.getTx().isLocked();
  }
  
  copy() {
    return new MoneroOutputWallet(this.toJson());
  }
  
  toJson() {
    let json = Object.assign({}, this.state, super.toJson());
    delete json.tx;
    return json;
  }
  
  /**
   * Updates this output by merging the latest information from the given
   * output.
   * 
   * Merging can modify or build references to the output given so it
   * should not be re-used or it should be copied before calling this method.
   * 
   * @param output is the output to merge into this one
   */
  merge(output) {
    assert$9(output instanceof MoneroOutputWallet);
    if (this === output) return;
    super.merge(output);
    this.setAccountIndex(GenUtils$7.reconcile(this.getAccountIndex(), output.getAccountIndex()));
    this.setSubaddressIndex(GenUtils$7.reconcile(this.getSubaddressIndex(), output.getSubaddressIndex()));
    this.setIsSpent(GenUtils$7.reconcile(this.isSpent(), output.isSpent(), {resolveTrue: true})); // output can become spent
    this.setIsFrozen(GenUtils$7.reconcile(this.isFrozen(), output.isFrozen()));
    return this;
  }
  
  toString(indent) {
    let str = super.toString(indent) + "\n";
    str += GenUtils$7.kvLine("Account index", this.getAccountIndex(), indent);
    str += GenUtils$7.kvLine("Subaddress index", this.getSubaddressIndex(), indent);
    str += GenUtils$7.kvLine("Is spent", this.isSpent(), indent);
    str += GenUtils$7.kvLine("Is frozen", this.isFrozen(), indent);
    return str.slice(0, str.length - 1);  // strip last newline
  }
}

var MoneroOutputWallet_1 = MoneroOutputWallet;

var MoneroOutputQuery_1;
var hasRequiredMoneroOutputQuery;

function requireMoneroOutputQuery () {
	if (hasRequiredMoneroOutputQuery) return MoneroOutputQuery_1;
	hasRequiredMoneroOutputQuery = 1;
	const BigInteger = biginteger.BigInteger;
	const MoneroError = MoneroError_1;
	const MoneroOutputWallet = MoneroOutputWallet_1;

	/**
	 * Configuration to query wallet outputs.
	 * 
	 * @extends {MoneroOutputWallet}
	 */
	class MoneroOutputQuery extends MoneroOutputWallet {
	  
	  /**
	   * <p>Construct the output query.</p>
	   * 
	   * <p>Example:</p>
	   * 
	   * <code>
	   * &sol;&sol; get available outputs in account 0 with a minimum amount<br>
	   * let outputs = await wallet.getOutputs({<br>
	   * &nbsp;&nbsp; isSpent: false,<br>
	   * &nbsp;&nbsp; isLocked: false,<br>
	   * &nbsp;&nbsp; accountIndex: 0,<br>
	   * &nbsp;&nbsp; minAmount: new BigInteger("750000")<br>
	   * });
	   * </code>
	   * 
	   * <p>All configuration is optional.  All outputs are returned except those that don't meet criteria defined in this query.</p>
	   * 
	   * @param {object} config - output query configuration (optional)
	   * @param {int} config.accountIndex - get outputs in this account index
	   * @param {int} config.subaddressIndex - get outputs in this subaddress index
	   * @param {int[]} config.subaddressIndices - get outputs in these subaddress indices
	   * @param {BigInteger} config.amount - get outputs with this amount
	   * @param {BigInteger} config.minAmount - get outputs with amount greater than or equal to this amount
	   * @param {BigInteger} config.maxAmount - get outputs with amount less than or equal to this amount
	   * @param {boolean} config.isSpent - get spent xor unspent outputs
	   * @param {boolean} config.isFrozen - get frozen xor thawed outputs
	   * @param {object|MoneroKeyImage} config.keyImage - get outputs with a key image matching fields defined in this key image
	   * @param {string} config.keyImage.hex - get outputs with this key image hex
	   * @param {string} config.keyImage.signature - get outputs with this key image signature
	   * @param {object|MoneroTxQuery} config.txQuery - get outputs whose tx match this tx query
	   */
	  constructor(config) {
	    super(config);
	    
	    // deserialize if necessary
	    const MoneroTxQuery = requireMoneroTxQuery();
	    if (this.state.minAmount !== undefined && !(this.state.minAmount instanceof BigInteger)) this.state.minAmount = BigInteger.parse(this.state.minAmount);
	    if (this.state.maxAmount !== undefined && !(this.state.maxAmount instanceof BigInteger)) this.state.maxAmount = BigInteger.parse(this.state.maxAmount);
	    if (this.state.txQuery && !(this.state.txQuery instanceof MoneroTxQuery)) this.state.txQuery = new MoneroTxQuery(this.state.txQuery);
	    if (this.state.txQuery) this.state.txQuery.setOutputQuery(this);
	    if (this.state.isLocked !== undefined) throw new MoneroError("isLocked must be part of tx query, not output query");
	  }
	  
	  copy() {
	    return new MoneroOutputQuery(this);
	  }
	  
	  toJson() {
	    let json = Object.assign({}, this.state, super.toJson());
	    if (this.getMinAmount()) json.minAmount = this.getMinAmount().toString();
	    if (this.getMaxAmount()) json.maxAmount = this.getMaxAmount().toString();
	    delete json.txQuery;
	    return json;
	  }
	  
	  getMinAmount() {
	    return this.state.minAmount;
	  }

	  setMinAmount(minAmount) {
	    this.state.minAmount = minAmount;
	    return this;
	  }

	  getMaxAmount() {
	    return this.state.maxAmount;
	  }

	  setMaxAmount(maxAmount) {
	    this.state.maxAmount = maxAmount;
	    return this;
	  }
	  
	  getTxQuery() {
	    return this.state.txQuery;
	  }
	  
	  setTxQuery(txQuery) {
	    this.state.txQuery = txQuery;
	    if (txQuery) txQuery.state.outputQuery = this;
	    return this;
	  }
	  
	  getSubaddressIndices() {
	    return this.state.subaddressIndices;
	  }
	  
	  setSubaddressIndices(subaddressIndices) {
	    this.state.subaddressIndices = subaddressIndices;
	    return this;
	  }
	  
	  meetsCriteria(output, queryParent) {
	    if (!(output instanceof MoneroOutputWallet)) throw new Error("Output not given to MoneroOutputQuery.meetsCriteria(output)");
	    
	    // filter on output
	    if (this.getAccountIndex() !== undefined && this.getAccountIndex() !== output.getAccountIndex()) return false;
	    if (this.getSubaddressIndex() !== undefined && this.getSubaddressIndex() !== output.getSubaddressIndex()) return false;
	    if (this.getAmount() !== undefined && this.getAmount().compare(output.getAmount()) !== 0) return false;
	    if (this.isSpent() !== undefined && this.isSpent() !== output.isSpent()) return false;
	    if (this.isFrozen() !== undefined && this.isFrozen() !== output.isFrozen()) return false;
	    
	    // filter on output's key image
	    if (this.getKeyImage() !== undefined) {
	      if (output.getKeyImage() === undefined) return false;
	      if (this.getKeyImage().getHex() !== undefined && this.getKeyImage().getHex() !== output.getKeyImage().getHex()) return false;
	      if (this.getKeyImage().getSignature() !== undefined && this.getKeyImage().getSignature() !== output.getKeyImage().getSignature()) return false;
	    }
	    
	    // filter on extensions
	    if (this.getSubaddressIndices() !== undefined && !this.getSubaddressIndices().includes(output.getSubaddressIndex())) return false;
	    
	    // filter with tx query
	    if (this.getTxQuery() && !this.getTxQuery().meetsCriteria(output.getTx(), false)) return false;
	    
	    // filter on remaining fields
	    if (this.getMinAmount() !== undefined && (output.getAmount() === undefined || output.getAmount().compare(this.getMinAmount()) < 0)) return false;
	    if (this.getMaxAmount() !== undefined && (output.getAmount() === undefined || output.getAmount().compare(this.getMaxAmount()) > 0)) return false;
	    
	    // output meets query
	    return true;
	  }
	}

	MoneroOutputQuery._EMPTY_OUTPUT = new MoneroOutputWallet();

	MoneroOutputQuery_1 = MoneroOutputQuery;
	return MoneroOutputQuery_1;
}

const assert$8 = require$$0;
const BigInteger$h = biginteger.BigInteger;
const GenUtils$6 = GenUtils_1;

/**
 * Models a base transfer of funds to or from the wallet.
 * 
 * @class
 */
class MoneroTransfer$2 {
  
  /**
   * Construct the model.
   * 
   * @param {MoneroTransfer|object} state is existing state to initialize from (optional)
   */
  constructor(state) {
    
    // initialize internal state
    if (!state) state = {};
    else if (state instanceof MoneroTransfer$2) state = state.toJson();
    else if (typeof state === "object") state = Object.assign({}, state);
    else throw new MoneroError("state must be a MoneroTransfer or JavaScript object");
    this.state = state;
    
    // deserialize fields if necessary
    if (state.amount !== undefined && !(state.amount instanceof BigInteger$h)) state.amount = BigInteger$h.parse(state.amount);
    
    // validate state
    this._validate();
  }
  
  copy() {
    return new MoneroTransfer$2(this);
  }
  
  toJson() {
    let json = Object.assign({}, this.state);
    if (this.getAmount()) json.amount = this.getAmount().toString();
    delete json.tx; // parent tx is not serialized
    return json;
  }
  
  getTx() {
    return this.state.tx;
  }
  
  setTx(tx) {
    this.state.tx = tx;
    return this;
  }
  
  isOutgoing() {
    let isIncoming = this.isIncoming();
    assert$8(typeof isIncoming === "boolean");
    return !isIncoming;
  }
  
  isIncoming() {
    throw new Error("Subclass must implement");
  }

  getAccountIndex() {
    return this.state.accountIndex;
  }

  setAccountIndex(accountIndex) {
    this.state.accountIndex = accountIndex;
    this._validate();
    return this;
  }

  getAmount() {
    return this.state.amount;
  }

  setAmount(amount) {
    this.state.amount = amount;
    return this;
  }
  
  /**
   * Updates this transaction by merging the latest information from the given
   * transaction.
   * 
   * Merging can modify or build references to the transfer given so it
   * should not be re-used or it should be copied before calling this method.
   * 
   * @param transfer is the transfer to merge into this one
   * @return {MoneroTransfer} the merged transfer
   */
  merge(transfer) {
    assert$8(transfer instanceof MoneroTransfer$2);
    if (this === transfer) return this;
    
    // merge transactions if they're different which comes back to merging transfers
    if (this.getTx() !== transfer.getTx()) {
      this.getTx().merge(transfer.getTx());
      return this;
    }
    
    // otherwise merge transfer fields
    this.setAccountIndex(GenUtils$6.reconcile(this.getAccountIndex(), transfer.getAccountIndex()));
    
    // TODO monero-project: failed tx in pool (after testUpdateLockedDifferentAccounts()) causes non-originating saved wallets to return duplicate incoming transfers but one has amount of 0
    if (this.getAmount() !== undefined && transfer.getAmount() !== undefined && this.getAmount().compare(transfer.getAmount()) !== 0 && (this.getAmount().compare(BigInteger$h.parse("0")) === 0 || transfer.getAmount().compare(BigInteger$h.parse("0")) === 0)) {
      console.warn("monero-project returning transfers with 0 amount/numSuggestedConfirmations");
    } else {
      this.setAmount(GenUtils$6.reconcile(this.getAmount(), transfer.getAmount()));
    }
    
    return this;
  }
  
  toString(indent = 0) {
    let str = "";
    str += GenUtils$6.kvLine("Is incoming", this.isIncoming(), indent);
    str += GenUtils$6.kvLine("Account index", this.getAccountIndex(), indent);
    str += GenUtils$6.kvLine("Amount", this.getAmount() ? this.getAmount().toString() : undefined, indent);
    return str === "" ? str :  str.slice(0, str.length - 1);  // strip last newline
  }
  
  _validate() {
    if (this.getAccountIndex() !== undefined && this.getAccountIndex() < 0) throw new MoneroError("Account index must be >= 0");
  }
}

var MoneroTransfer_1 = MoneroTransfer$2;

const assert$7 = require$$0;
const GenUtils$5 = GenUtils_1;
const MoneroTransfer$1 = MoneroTransfer_1;

/**
 * Models an incoming transfer of funds to the wallet.
 * 
 * @extends {MoneroTransfer}
 */
class MoneroIncomingTransfer extends MoneroTransfer$1 {
  
  /**
   * Construct the model.
   * 
   * @param {MoneroTransfer|object} state is existing state to initialize from (optional)
   */
  constructor(state) {
    super(state);
  }
  
  isIncoming() {
    return true;
  }
  
  getSubaddressIndex() {
    return this.state.subaddressIndex;
  }
  
  setSubaddressIndex(subaddressIndex) {
    this.state.subaddressIndex = subaddressIndex;
    return this;
  }
  
  getAddress() {
    return this.state.address;
  }

  setAddress(address) {
    this.state.address = address;
    return this;
  }
  
  /**
   * Return how many confirmations till it's not economically worth re-writing the chain.
   * That is, the number of confirmations before the transaction is highly unlikely to be
   * double spent or overwritten and may be considered settled, e.g. for a merchant to trust
   * as finalized.
   * 
   * @return {number} is the number of confirmations before it's not worth rewriting the chain
   */
  getNumSuggestedConfirmations() {
    return this.state.numSuggestedConfirmations;
  }
  
  setNumSuggestedConfirmations(numSuggestedConfirmations) {
    this.state.numSuggestedConfirmations = numSuggestedConfirmations;
    return this;
  }

  copy() {
    return new MoneroIncomingTransfer(this.toJson());
  }
  
  /**
   * Updates this transaction by merging the latest information from the given
   * transaction.
   * 
   * Merging can modify or build references to the transfer given so it
   * should not be re-used or it should be copied before calling this method.
   * 
   * @param {MoneroIncomingTransfer} transfer is the transfer to merge into this one
   */
  merge(transfer) {
    super.merge(transfer);
    assert$7(transfer instanceof MoneroIncomingTransfer);
    if (this === transfer) return this;
    this.setSubaddressIndex(GenUtils$5.reconcile(this.getSubaddressIndex(), transfer.getSubaddressIndex()));
    this.setAddress(GenUtils$5.reconcile(this.getAddress(), transfer.getAddress()));
    this.setNumSuggestedConfirmations(GenUtils$5.reconcile(this.getNumSuggestedConfirmations(), transfer.getNumSuggestedConfirmations(), {resolveMax: false}));
    return this;
  }
  
  toString() {
    return this.toString(0);
  }
  
  toString(indent) {
    let str = super.toString(indent) + "\n";
    str += GenUtils$5.kvLine("Subaddress index", this.getSubaddressIndex(), indent);
    str += GenUtils$5.kvLine("Address", this.getAddress(), indent);
    str += GenUtils$5.kvLine("Num suggested confirmations", this.getNumSuggestedConfirmations(), indent);
    return str.slice(0, str.length - 1);  // strip last newline
  }
}

var MoneroIncomingTransfer_1 = MoneroIncomingTransfer;

const BigInteger$g = biginteger.BigInteger;
const GenUtils$4 = GenUtils_1;
const MoneroError$4 = MoneroError_1;

/**
 * Models an outgoing transfer destination.
 */
class MoneroDestination$2 {
  
  /**
   * Construct the model.
   * 
   * @param {MoneroDestination|object|string} stateOrAddress is a MoneroDestination, JS object, or hex string to initialize from (optional)
   * @param {BigInteger|string} amount - the destination amount
   */
  constructor(stateOrAddress, amount) {
    if (!stateOrAddress) this.state = {};
    else if (stateOrAddress instanceof MoneroDestination$2) this.state = stateOrAddress.toJson();
    else if (typeof stateOrAddress === "object") {
      this.state = Object.assign({}, stateOrAddress);
      if (typeof this.state.amount === "number") this.state.amount = BigInteger$g.parse(this.state.amount);
    } else if (typeof stateOrAddress === "string")  {
      this.state = {};
      this.setAddress(stateOrAddress);
    }
    else throw new MoneroError$4("stateOrAddress must be a MoneroDestination, JavaScript object, or hex string");
    if (amount) this.state.amount = amount;
    this.setAmount(this.state.amount);
  }
  
  getAddress() {
    return this.state.address;
  }

  setAddress(address) {
    this.state.address = address;
    return this;
  }
  
  getAmount() {
    return this.state.amount;
  }

  setAmount(amount) {
    if (amount !== undefined && !(this.state.amount instanceof BigInteger$g)) {
      if (typeof amount === "number") throw new MoneroError$4("Destination amount must be BigInteger or string");
      try { amount = BigInteger$g.parse(amount); }
      catch (err) { throw new MoneroError$4("Invalid destination amount: " + amount); }
    }
    this.state.amount = amount;
    return this;
  }

  copy() {
    return new MoneroDestination$2(this);
  }
  
  toJson() {
    let json = Object.assign({}, this.state);
    if (this.getAmount()) json.amount = this.getAmount().toString();
    return json;
  }
  
  toString(indent = 0) {
    let str = GenUtils$4.kvLine("Address", this.getAddress(), indent);
    str += GenUtils$4.kvLine("Amount", this.getAmount() ? this.getAmount().toString() : undefined, indent);
    return str.slice(0, str.length - 1);  // strip last newline
  }
}

var MoneroDestination_1 = MoneroDestination$2;

const assert$6 = require$$0;
const GenUtils$3 = GenUtils_1;
const MoneroDestination$1 = MoneroDestination_1;
const MoneroTransfer = MoneroTransfer_1;

/**
 * Models an outgoing transfer of funds from the wallet.
 * 
 * @extends {MoneroTransfer}
 */
class MoneroOutgoingTransfer extends MoneroTransfer {

  /**
   * Construct the model.
   * 
   * @param {MoneroOutgoingTranser|object} state is existing state to initialize from (optional)
   */
  constructor(state) {
    super(state);
    state = this.state;
    
    // deserialize destinations
    if (state.destinations) {
      for (let i = 0; i < state.destinations.length; i++) {
        if (!(state.destinations[i] instanceof MoneroDestination$1)) state.destinations[i] = new MoneroDestination$1(state.destinations[i]);
      }
    }
  }
  
  isIncoming() {
    return false;
  }
  
  getSubaddressIndices() {
    return this.state.subaddressIndices;
  }

  setSubaddressIndices(subaddressIndices) {
    this.state.subaddressIndices = subaddressIndices;
    return this;
  }
  
  getAddresses() {
    return this.state.addresses;
  }

  setAddresses(addresses) {
    this.state.addresses = addresses;
    return this;
  }

  getDestinations() {
    return this.state.destinations;
  }
  
  setDestinations(destinations) {
    this.state.destinations = destinations;
    return this;
  }
  
  copy() {
    return new MoneroOutgoingTransfer(this);
  }
  
  toJson() {
    let json = Object.assign({}, this.state, super.toJson()); // merge json onto inherited state
    if (this.getDestinations()) {
      json.destinations = [];
      for (let destination of this.getDestinations()) json.destinations.push(destination.toJson());
    }
    delete json.tx; // parent tx is not serialized
    return json;
  }
  
  /**
   * Updates this transaction by merging the latest information from the given
   * transaction.
   * 
   * Merging can modify or build references to the transfer given so it
   * should not be re-used or it should be copied before calling this method.
   * 
   * @param transfer is the transfer to merge into this one
   */
  merge(transfer) {
    super.merge(transfer);
    assert$6(transfer instanceof MoneroOutgoingTransfer);
    if (this === transfer) return this;
    this.setSubaddressIndices(GenUtils$3.reconcile(this.getSubaddressIndices(), transfer.getSubaddressIndices()));
    this.setAddresses(GenUtils$3.reconcile(this.getAddresses(), transfer.getAddresses()));
    this.setDestinations(GenUtils$3.reconcile(this.getDestinations(), transfer.getDestinations()));
    return this;
  }

  toString(indent = 0) {
    let str = super.toString(indent) + "\n";
    str += GenUtils$3.kvLine("Subaddress indices", this.getSubaddressIndices(), indent);
    str += GenUtils$3.kvLine("Addresses", this.getAddresses(), indent);
    if (this.getDestinations()) {
      str += GenUtils$3.kvLine("Destinations", "", indent);
      for (let i = 0; i < this.getDestinations().length; i++) {
        str += GenUtils$3.kvLine(i + 1, "", indent + 1);
        str += this.getDestinations()[i].toString(indent + 2) + "\n";
      }
    }
    return str.slice(0, str.length - 1);  // strip last newline
  }
}

var MoneroOutgoingTransfer_1 = MoneroOutgoingTransfer;

var MoneroTransferQuery_1;
var hasRequiredMoneroTransferQuery;

function requireMoneroTransferQuery () {
	if (hasRequiredMoneroTransferQuery) return MoneroTransferQuery_1;
	hasRequiredMoneroTransferQuery = 1;
	const MoneroIncomingTransfer = MoneroIncomingTransfer_1;
	const MoneroOutgoingTransfer = MoneroOutgoingTransfer_1;
	const MoneroTransfer = MoneroTransfer_1;
	const MoneroError = MoneroError_1;

	/**
	 * Configuration to query wallet transfers.
	 * 
	 * @extends {MoneroTransfer}
	 */
	class MoneroTransferQuery extends MoneroTransfer {
	  
	  /**
	   * <p>Construct the transfer query.</p>
	   * 
	   * <p>Example:</p>
	   * 
	   * <code>
	   * &sol;&sol; get incoming transfers to account 0, subaddress 1<br>
	   * let transfers = await wallet.getTransfers({<br>
	   * &nbsp;&nbsp; accountIndex: 0,<br>
	   * &nbsp;&nbsp; subaddressIndex: 0<br>
	   * });
	   * </code>
	   * 
	   * <p>All configuration is optional.  All transfers are returned except those that don't meet criteria defined in this query.</p>
	   * 
	   * @param {object} config - transfer query configuration (optional)
	   * @param {BigInteger} config.amount - get transfers with this amount
	   * @param {int} config.accountIndex - get transfers to/from this account index
	   * @param {int} config.subaddressIndex - get transfers to/from this subaddress index
	   * @param {int[]} config.subaddressIndices - get transfers to/from these subaddress indices
	   * @param {string} config.address - get transfers to/from this wallet address
	   * @param {string[]} config.addresses - get transfers to/from these wallet addresses
	   * @param {boolean} config.isIncoming - get transfers which are incoming if true
	   * @param {boolean} config.isOutgoing - get transfers which are outgoing if true
	   * @param {boolean} config.hasDestinations - get transfers with known destinations if true (destinations are only stored locally with the wallet)
	   * @param {object|MoneroTxQuery} config.txQuery - get transfers whose tx match this tx query
	   */
	  constructor(config) {
	    super(config);
	    
	    // deserialize if necessary
	    const MoneroTxQuery = requireMoneroTxQuery();
	    if (this.state.txQuery && !(this.state.txQuery instanceof MoneroTxQuery)) this.state.txQuery = new MoneroTxQuery(this.state.txQuery);
	    if (this.state.txQuery) this.state.txQuery.setTransferQuery(this);
	    
	    // alias isOutgoing to isIncoming
	    if (this.state.isOutgoing !== undefined) this.state.isIncoming = !this.state.isOutgoing;
	    
	    // validate state
	    this._validate();
	  }
	  
	  copy() {
	    return new MoneroTransferQuery(this);
	  }
	  
	  toJson() {
	    let json = Object.assign({}, this.state, super.toJson());
	    delete json.txQuery;
	    return json;
	  }
	  
	  getTxQuery() {
	    return this.state.txQuery;
	  }
	  
	  setTxQuery(txQuery) {
	    this.state.txQuery = txQuery;
	    if (txQuery) txQuery.state.transferQuery = this;
	    return this;
	  }
	  
	  isIncoming() {
	    return this.state.isIncoming;
	  }

	  setIsIncoming(isIncoming) {
	    this.state.isIncoming = isIncoming;
	    return this;
	  }
	  
	  isOutgoing() {
	    return this.state.isIncoming === undefined ? undefined : !this.state.isIncoming;
	  }
	  
	  setIsOutgoing(isOutgoing) {
	    this.state.isIncoming = isOutgoing === undefined ? undefined : !isOutgoing;
	    return this;
	  }
	  
	  getAddress() {
	    return this.state.address;
	  }

	  setAddress(address) {
	    this.state.address = address;
	    return this;
	  }
	  
	  getAddresses() {
	    return this.state.addresses;
	  }

	  setAddresses(addresses) {
	    this.state.addresses = addresses;
	    return this;
	  }
	  
	  getSubaddressIndex() {
	    return this.state.subaddressIndex;
	  }
	  
	  setSubaddressIndex(subaddressIndex) {
	    this.state.subaddressIndex = subaddressIndex;
	    this._validate();
	    return this;
	  }
	  
	  getSubaddressIndices() {
	    return this.state.subaddressIndices;
	  }
	  
	  setSubaddressIndices(subaddressIndices) {
	    this.state.subaddressIndices = subaddressIndices;
	    this._validate();
	    return this;
	  }
	  
	  getDestinations() {
	    return this.state.destinations;
	  }
	  
	  setDestinations(destinations) {
	    this.state.destinations = destinations;
	    return this;
	  }
	  
	  hasDestinations() {
	    return this.state.hasDestinations;
	  }
	  
	  setHasDestinations(hasDestinations) {
	    this.state.hasDestinations = hasDestinations;
	    return this;
	  }
	  
	  /**
	   * Convenience method to query outputs by the locked state of their tx.
	   * 
	   * @param isLocked specifies if the output's tx must be locked or unlocked (optional)
	   * @return {MoneroOutputQuery} this query for chaining
	   */
	  setIsLocked(isLocked) {
	    if (this.state.txQuery === undefined) this.state.txQuery = new MoneroTxQuery();
	    this.state.txQuery.setIsLocked(isLocked);
	    return this;
	  }
	  
	  meetsCriteria(transfer, queryParent) {
	    if (!(transfer instanceof MoneroTransfer)) throw new Error("Transfer not given to MoneroTransferQuery.meetsCriteria(transfer)");
	    if (queryParent === undefined) queryParent = true;
	    
	    // filter on common fields
	    if (this.isIncoming() !== undefined && this.isIncoming() !== transfer.isIncoming()) return false;
	    if (this.isOutgoing() !== undefined && this.isOutgoing() !== transfer.isOutgoing()) return false;
	    if (this.getAmount() !== undefined && this.getAmount().compare(transfer.getAmount()) !== 0) return false;
	    if (this.getAccountIndex() !== undefined && this.getAccountIndex() !== transfer.getAccountIndex()) return false;
	    
	    // filter on incoming fields
	    if (transfer instanceof MoneroIncomingTransfer) {
	      if (this.hasDestinations()) return false;
	      if (this.getAddress() !== undefined && this.getAddress() !== transfer.getAddress()) return false;
	      if (this.getAddresses() !== undefined && !this.getAddresses().includes(transfer.getAddress())) return false;
	      if (this.getSubaddressIndex() !== undefined && this.getSubaddressIndex() !== transfer.getSubaddressIndex()) return false;
	      if (this.getSubaddressIndices() !== undefined && !this.getSubaddressIndices().includes(transfer.getSubaddressIndex())) return false;
	    }

	    // filter on outgoing fields
	    else if (transfer instanceof MoneroOutgoingTransfer) {
	      
	      // filter on addresses which must have overlap
	      if (this.getAddress() !== undefined && (transfer.getAddresses() === undefined || !transfer.getAddresses().includes(this.getAddress()))) return false;   // TODO: will filter all transfers that don't contain addresses (outgoing txs might not have this field initialized)
	      if (this.getAddresses() !== undefined) {
	        if (!transfer.getAddresses()) return false;
	        if (!this.getAddresses().some(address => transfer.getAddresses().includes(address))) return false;
	      }
	      
	      // filter on subaddress indices
	      if (this.getSubaddressIndex() !== undefined && (transfer.getSubaddressIndices() === undefined || !transfer.getSubaddressIndices().includes(this.getSubaddressIndex()))) return false;
	      if (this.getSubaddressIndices() !== undefined) {
	        if (!transfer.getSubaddressIndices()) return false;
	        if (!this.getSubaddressIndices().some(subaddressIdx => transfer.getSubaddressIndices().includes(subaddressIdx))) return false;
	      }
	      
	      // filter on having destinations
	      if (this.hasDestinations() !== undefined) {
	        if (this.hasDestinations() && transfer.getDestinations() === undefined) return false;
	        if (!this.hasDestinations() && transfer.getDestinations() !== undefined) return false;
	      }
	      
	      // filter on destinations TODO: start with test for this
	//    if (this.getDestionations() !== undefined && this.getDestionations() !== transfer.getDestionations()) return false;
	    }
	    
	    // otherwise invalid type
	    else throw new Error("Transfer must be MoneroIncomingTransfer or MoneroOutgoingTransfer");
	    
	    // filter with tx filter
	    if (queryParent && this.getTxQuery() !== undefined && !this.getTxQuery().meetsCriteria(transfer.getTx())) return false;    
	    return true;
	  }
	  
	  _validate() {
	    if (this.getSubaddressIndex() !== undefined && this.getSubaddressIndex() < 0) throw new MoneroError("Subaddress index must be >= 0");
	    if (this.getSubaddressIndices() !== undefined) for (let subaddressIdx of this.getSubaddressIndices()) if (subaddressIdx < 0) throw new MoneroError("Subaddress indices must be >= 0");
	  }
	}

	MoneroTransferQuery_1 = MoneroTransferQuery;
	return MoneroTransferQuery_1;
}

var MoneroTxSet_1;
var hasRequiredMoneroTxSet;

function requireMoneroTxSet () {
	if (hasRequiredMoneroTxSet) return MoneroTxSet_1;
	hasRequiredMoneroTxSet = 1;
	const assert = require$$0;
	const GenUtils = GenUtils_1;
	const MoneroTxWallet = requireMoneroTxWallet();
	const MoneroUtils = requireMoneroUtils();

	/**
	 * Groups transactions who share common hex data which is needed in order to
	 * sign and submit the transactions.
	 * 
	 * For example, multisig transactions created from createTxs() share a common
	 * hex string which is needed in order to sign and submit the multisig
	 * transactions.
	 */
	class MoneroTxSet {
	  
	  constructor(state) {
	    
	    // initialize internal state
	    if (!state) state = {};
	    else if (typeof state === "object") state = Object.assign({}, state);
	    else throw new MoneroError("state must be JavaScript object");
	    this.state = state;
	    
	    // deserialize txs
	    if (state.txs) {
	      for (let i = 0; i < state.txs.length; i++) {
	        if (!(state.txs[i] instanceof MoneroTxWallet)) state.txs[i] = new MoneroTxWallet(state.txs[i]);
	        state.txs[i].setTxSet(this);
	      }
	    }
	  }
	  
	  toJson() {
	    let json = Object.assign({}, this.state); // copy state
	    if (this.getTxs()) {
	      json.txs = [];
	      for (let tx of this.getTxs()) json.txs.push(tx.toJson());
	    }
	    return json;
	  }

	  getTxs() {
	    return this.state.txs;
	  }

	  setTxs(txs) {
	    this.state.txs = txs;
	    return this;
	  }
	  
	  getMultisigTxHex() {
	    return this.state.multisigTxHex;
	  }
	  
	  setMultisigTxHex(multisigTxHex) {
	    this.state.multisigTxHex = multisigTxHex;
	    return this;
	  }
	  
	  getUnsignedTxHex() {
	    return this.state.unsignedTxHex;
	  }
	  
	  setUnsignedTxHex(unsignedTxHex) {
	    this.state.unsignedTxHex = unsignedTxHex;
	    return this;
	  }
	  
	  getSignedTxHex() {
	    return this.state.signedTxHex;
	  }
	  
	  setSignedTxHex(signedTxHex) {
	    this.state.signedTxHex = signedTxHex;
	    return this;
	  }
	  
	  merge(txSet) {
	    assert(txSet instanceof MoneroTxSet);
	    if (this === txSet) return this;
	    
	    // merge sets
	    this.setMultisigTxHex(GenUtils.reconcile(this.getMultisigTxHex(), txSet.getMultisigTxHex()));
	    this.setUnsignedTxHex(GenUtils.reconcile(this.getUnsignedTxHex(), txSet.getUnsignedTxHex()));
	    this.setSignedTxHex(GenUtils.reconcile(this.getSignedTxHex(), txSet.getSignedTxHex()));
	    
	    // merge txs
	    if (txSet.getTxs() !== undefined) {
	      for (let tx of txSet.getTxs()) {
	        tx.setTxSet(this);
	        MoneroUtils.mergeTx(this.getTxs(), tx);
	      }
	    }

	    return this;
	  }
	  
	  toString(indent = 0) {
	    let str = "";
	    str += GenUtils.kvLine("Multisig tx hex: ", this.getMultisigTxHex(), indent);
	    str += GenUtils.kvLine("Unsigned tx hex: ", this.getUnsignedTxHex(), indent);
	    str += GenUtils.kvLine("Signed tx hex: ", this.getSignedTxHex(), indent);
	    if (this.getTxs() !== undefined) {
	      str += GenUtils.kvLine("Txs", "", indent);
	      for (let tx of this.getTxs()) {
	        str += tx.toString(indent + 1) + "\n";
	      }
	    }
	    return str;
	  }
	}

	MoneroTxSet_1 = MoneroTxSet;
	return MoneroTxSet_1;
}

var MoneroTxWallet_1;
var hasRequiredMoneroTxWallet;

function requireMoneroTxWallet () {
	if (hasRequiredMoneroTxWallet) return MoneroTxWallet_1;
	hasRequiredMoneroTxWallet = 1;
	const assert = require$$0;
	const BigInteger = biginteger.BigInteger;
	const GenUtils = GenUtils_1;
	const MoneroIncomingTransfer = MoneroIncomingTransfer_1;
	const MoneroOutgoingTransfer = MoneroOutgoingTransfer_1;
	const MoneroOutputWallet = MoneroOutputWallet_1;
	const MoneroTx = MoneroTx_1;

	/**
	 * Models a Monero transaction with wallet extensions.
	 * 
	 * @class
	 * @extends {MoneroTx}
	 */
	class MoneroTxWallet extends MoneroTx {
	  
	  /**
	   * Construct the model.
	   * 
	   * @param {MoneroTxWallet|object} state is existing state to initialize from (optional)
	   */
	  constructor(state) {
	    super(state);
	    if (state instanceof MoneroTxWallet && state.getTxSet()) this.setTxSet(state.getTxSet()); // preserve reference to tx set
	    state = this.state;
	    
	    // deserialize incoming transfers
	    if (state.incomingTransfers) {
	      for (let i = 0; i < state.incomingTransfers.length; i++) {
	        if (!(state.incomingTransfers[i] instanceof MoneroIncomingTransfer)) {
	          state.incomingTransfers[i] = new MoneroIncomingTransfer(Object.assign(state.incomingTransfers[i], {tx: this}));
	        }
	      }
	    }
	    
	    // deserialize outgoing transfer
	    if (state.outgoingTransfer && !(state.outgoingTransfer instanceof MoneroOutgoingTransfer)) {
	      this.setOutgoingTransfer(new MoneroOutgoingTransfer(Object.assign(state.outgoingTransfer, {tx: this})));
	    }
	    
	    // deserialize inputs
	    if (state.inputs) {
	      for (let i = 0; i < state.inputs.length; i++) {
	        if (!(state.inputs[i] instanceof MoneroOutputWallet)) {
	          state.inputs[i] = new MoneroOutputWallet(Object.assign(state.inputs[i].toJson(), {tx: this}));
	        }
	      }
	    }
	    
	    // deserialize outputs
	    if (state.outputs) {
	      for (let i = 0; i < state.outputs.length; i++) {
	        if (!(state.outputs[i] instanceof MoneroOutputWallet)) {
	          state.outputs[i] = new MoneroOutputWallet(Object.assign(state.outputs[i].toJson(), {tx: this}));
	        }
	      }
	    }
	    
	    // deserialize BigIntegers
	    if (state.inputSum !== undefined && !(state.inputSum instanceof BigInteger)) state.inputSum = BigInteger.parse(state.inputSum);
	    if (state.outputSum !== undefined && !(state.outputSum instanceof BigInteger)) state.outputSum = BigInteger.parse(state.outputSum);
	    if (state.changeAmount !== undefined && !(state.changeAmount instanceof BigInteger)) state.changeAmount = BigInteger.parse(state.changeAmount);
	  }
	  
	  toJson() {
	    let json = Object.assign({}, this.state, super.toJson()); // merge json onto inherited state
	    if (this.getIncomingTransfers()) {
	      json.incomingTransfers = [];
	      for (let incomingTransfer of this.getIncomingTransfers()) json.incomingTransfers.push(incomingTransfer.toJson());
	    }
	    if (this.getOutgoingTransfer()) json.outgoingTransfer = this.getOutgoingTransfer().toJson();
	    if (this.getInputSum()) json.inputSum = this.getInputSum().toString();
	    if (this.getOutputSum()) json.outputSum = this.getOutputSum().toString();
	    if (this.getChangeAmount()) json.changeAmount = this.getChangeAmount().toString();
	    delete json.block;  // do not serialize parent block
	    delete json.txSet;  // do not serialize parent tx set
	    return json;
	  }
	  
	  getTxSet() {
	    return this.state.txSet;
	  }
	  
	  setTxSet(txSet) {
	    this.state.txSet = txSet;
	    return this;
	  }
	  
	  isIncoming() {
	    return this.state.isIncoming;
	  }
	  
	  setIsIncoming(isIncoming) {
	    this.state.isIncoming = isIncoming;
	    return this;
	  }
	  
	  isOutgoing() {
	    return this.state.isOutgoing;
	  }
	  
	  setIsOutgoing(isOutgoing) {
	    this.state.isOutgoing = isOutgoing;
	    return this;
	  }
	  
	  getIncomingAmount() {
	    if (this.getIncomingTransfers() === undefined) return undefined;
	    let incomingAmt = BigInteger.parse("0");
	    for (let transfer of this.getIncomingTransfers()) incomingAmt = incomingAmt.add(transfer.getAmount());
	    return incomingAmt;
	  }
	  
	  getOutgoingAmount() {
	    return this.getOutgoingTransfer() ? this.getOutgoingTransfer().getAmount() : undefined;
	  }
	  
	  getTransfers(transferQuery) {
	    let transfers = [];
	    if (this.getOutgoingTransfer() && (!transferQuery || transferQuery.meetsCriteria(this.getOutgoingTransfer()))) transfers.push(this.getOutgoingTransfer());
	    if (this.getIncomingTransfers()) {
	      for (let transfer of this.getIncomingTransfers()) {
	        if (!transferQuery || transferQuery.meetsCriteria(transfer)) transfers.push(transfer);
	      }
	    }
	    return transfers;
	  }
	  
	  filterTransfers(transferQuery) {
	    let transfers = [];
	    
	    // collect outgoing transfer or erase if filtered
	    if (this.getOutgoingTransfer() && (!transferQuery || transferQuery.meetsCriteria(this.getOutgoingTransfer()))) transfers.push(this.getOutgoingTransfer());
	    else this.setOutgoingTransfer(undefined);
	    
	    // collect incoming transfers or erase if filtered
	    if (this.getIncomingTransfers()) {
	      let toRemoves = [];
	      for (let transfer of this.getIncomingTransfers()) {
	        if (transferQuery.meetsCriteria(transfer)) transfers.push(transfer);
	        else toRemoves.push(transfer);
	      }
	      this.setIncomingTransfers(this.getIncomingTransfers().filter(function(transfer) {
	        return !toRemoves.includes(transfer);
	      }));
	      if (this.getIncomingTransfers().length === 0) this.setIncomingTransfers(undefined);
	    }
	    
	    return transfers;
	  }
	  
	  getIncomingTransfers() {
	    return this.state.incomingTransfers;
	  }
	  
	  setIncomingTransfers(incomingTransfers) {
	    this.state.incomingTransfers = incomingTransfers;
	    return this;
	  }
	  
	  getOutgoingTransfer() {
	    return this.state.outgoingTransfer;
	  }
	  
	  setOutgoingTransfer(outgoingTransfer) {
	    this.state.outgoingTransfer = outgoingTransfer;
	    return this;
	  }
	  
	  getInputs(outputQuery) {
	    if (!outputQuery || !super.getInputs()) return super.getInputs();
	    let inputs = [];
	    for (let output of super.getInputs()) if (!outputQuery || outputQuery.meetsCriteria(output)) inputs.push(output);
	    return inputs;
	  }
	  
	  setInputs(inputs) {
	    
	    // validate that all inputs are wallet inputs
	    if (inputs) {
	      for (let output of inputs) {
	        if (!(output instanceof MoneroOutputWallet)) throw new MoneroError("Wallet transaction inputs must be of type MoneroOutputWallet");
	      }
	    }
	    super.setInputs(inputs);
	    return this;
	  }
	  
	  getOutputs(outputQuery) {
	    if (!outputQuery || !super.getOutputs()) return super.getOutputs();
	    let outputs = [];
	    for (let output of super.getOutputs()) if (!outputQuery || outputQuery.meetsCriteria(output)) outputs.push(output);
	    return outputs;
	  }
	  
	  setOutputs(outputs) {
	    
	    // validate that all outputs are wallet outputs
	    if (outputs) {
	      for (let output of outputs) {
	        if (!(output instanceof MoneroOutputWallet)) throw new MoneroError("Wallet transaction outputs must be of type MoneroOutputWallet");
	      }
	    }
	    super.setOutputs(outputs);
	    return this;
	  }
	  
	  filterOutputs(outputQuery) {
	    let outputs = [];
	    if (super.getOutputs()) {
	      let toRemoves = [];
	      for (let output of super.getOutputs()) {
	        if (!outputQuery || outputQuery.meetsCriteria(output)) outputs.push(output);
	        else toRemoves.push(output);
	      }
	      this.setOutputs(super.getOutputs().filter(function(output) {
	        return !toRemoves.includes(output);
	      }));
	      if (this.getOutputs().length === 0) this.setOutputs(undefined);
	    }
	    return outputs;
	  }
	  
	  getNote() {
	    return this.state.note;
	  }
	  
	  setNote(note) {
	    this.state.note = note;
	    return this;
	  }
	  
	  isLocked() {
	    return this.state.isLocked;
	  }
	  
	  setIsLocked(isLocked) {
	    this.state.isLocked = isLocked;
	    return this;
	  }
	  
	  getInputSum() {
	    return this.state.inputSum;
	  }
	  
	  setInputSum(inputSum) {
	    this.state.inputSum = inputSum;
	    return this;
	  }
	  
	  getOutputSum() {
	    return this.state.outputSum;
	  }
	  
	  setOutputSum(outputSum) {
	    this.state.outputSum = outputSum;
	    return this;
	  }
	  
	  getChangeAddress() {
	    return this.state.changeAddress;
	  }
	  
	  setChangeAddress(changeAddress) {
	    this.state.changeAddress = changeAddress;
	    return this;
	  }
	  
	  getChangeAmount() {
	    return this.state.changeAmount;
	  }
	  
	  setChangeAmount(changeAmount) {
	    this.state.changeAmount = changeAmount;
	    return this;
	  }
	  
	  getNumDummyOutputs() {
	    return this.state.numDummyOutputs;
	  }
	  
	  setNumDummyOutputs(numDummyOutputs) {
	    this.state.numDummyOutputs = numDummyOutputs;
	    return this;
	  }
	  
	  getExtraHex() {
	    return this.state.extraHex;
	  }
	  
	  setExtraHex(extraHex) {
	    this.state.extraHex = extraHex;
	    return this;
	  }
	  
	  copy() {
	    return new MoneroTxWallet(this);
	  }
	  
	  /**
	   * Updates this transaction by merging the latest information from the given
	   * transaction.
	   * 
	   * Merging can modify or build references to the transaction given so it
	   * should not be re-used or it should be copied before calling this method.
	   * 
	   * @param tx is the transaction to merge into this transaction
	   */
	  merge(tx) {
	    assert(tx instanceof MoneroTxWallet);
	    if (this === tx) return this;
	    
	    // merge base classes
	    super.merge(tx);
	    
	    // merge tx set if they're different which comes back to merging txs
	    const MoneroTxSet = requireMoneroTxSet();
	    if (this.getTxSet() !== tx.getTxSet()) {
	      if (this.getTxSet() == undefined) {
	        this.setTxSet(new MoneroTxSet().setTxs([this]));
	      }
	      if (tx.getTxSet() === undefined) {
	        tx.setTxSet(new MoneroTxSet().setTxs([tx]));
	      }
	      this.getTxSet().merge(tx.getTxSet());
	      return this;
	    }
	    
	    // merge incoming transfers
	    if (tx.getIncomingTransfers()) {
	      if (this.getIncomingTransfers() === undefined) this.setIncomingTransfers([]);
	      for (let transfer of tx.getIncomingTransfers()) {
	        transfer.setTx(this);
	        MoneroTxWallet._mergeIncomingTransfer(this.getIncomingTransfers(), transfer);
	      }
	    }
	    
	    // merge outgoing transfer
	    if (tx.getOutgoingTransfer()) {
	      tx.getOutgoingTransfer().setTx(this);
	      if (this.getOutgoingTransfer() === undefined) this.setOutgoingTransfer(tx.getOutgoingTransfer());
	      else this.getOutgoingTransfer().merge(tx.getOutgoingTransfer());
	    }
	    
	    // merge simple extensions
	    this.setIsIncoming(GenUtils.reconcile(this.isIncoming(), tx.isIncoming()));
	    this.setIsOutgoing(GenUtils.reconcile(this.isOutgoing(), tx.isOutgoing()));
	    this.setNote(GenUtils.reconcile(this.getNote(), tx.getNote()));
	    this.setIsLocked(GenUtils.reconcile(this.isLocked(), tx.isLocked(), {resolveTrue: false})); // tx can become unlocked
	    this.setInputSum(GenUtils.reconcile(this.getInputSum(), tx.getInputSum()));
	    this.setOutputSum(GenUtils.reconcile(this.getOutputSum(), tx.getOutputSum()));
	    this.setChangeAddress(GenUtils.reconcile(this.getChangeAddress(), tx.getChangeAddress()));
	    this.setChangeAmount(GenUtils.reconcile(this.getChangeAmount(), tx.getChangeAmount()));
	    this.setNumDummyOutputs(GenUtils.reconcile(this.getNumDummyOutputs(), tx.getNumDummyOutputs()));
	    this.setExtraHex(GenUtils.reconcile(this.getExtraHex(), tx.getExtraHex()));
	    
	    return this;  // for chaining
	  }
	  
	  toString(indent = 0, oneLine) {
	    let str = "";
	    
	    // represent tx with one line string
	    // TODO: proper csv export
	    if (oneLine) {
	      str += this.getHash() + ", ";
	      str += (this.isConfirmed() ? this.getBlock().getTimestamp() : this.getReceivedTimestamp()) + ", ";
	      str += this.isConfirmed() + ", ";
	      str += (this.getOutgoingAmount() ? this.getOutgoingAmount().toString() : "") + ", ";
	      str += this.getIncomingAmount() ? this.getIncomingAmount().toString() : "";
	      return str;
	    }
	    
	    // otherwise stringify all fields
	    str += super.toString(indent) + "\n";
	    str += GenUtils.kvLine("Is incoming", this.isIncoming(), indent);
	    str += GenUtils.kvLine("Incoming amount", this.getIncomingAmount(), indent);
	    if (this.getIncomingTransfers()) {
	      str += GenUtils.kvLine("Incoming transfers", "", indent);
	      for (let i = 0; i < this.getIncomingTransfers().length; i++) {
	        str += GenUtils.kvLine(i + 1, "", indent + 1);
	        str += this.getIncomingTransfers()[i].toString(indent + 2) + "\n";
	      }
	    }
	    str += GenUtils.kvLine("Is outgoing", this.isOutgoing(), indent);
	    str += GenUtils.kvLine("Outgoing amount", this.getOutgoingAmount(), indent);
	    if (this.getOutgoingTransfer()) {
	      str += GenUtils.kvLine("Outgoing transfer", "", indent);
	      str += this.getOutgoingTransfer().toString(indent + 1) + "\n";
	    }
	    str += GenUtils.kvLine("Note", this.getNote(), indent);
	    str += GenUtils.kvLine("Is locked", this.isLocked(), indent);
	    str += GenUtils.kvLine("Input sum", this.getInputSum(), indent);
	    str += GenUtils.kvLine("Output sum", this.getOutputSum(), indent);
	    str += GenUtils.kvLine("Change address", this.getChangeAddress(), indent);
	    str += GenUtils.kvLine("Change amount", this.getChangeAmount(), indent);
	    str += GenUtils.kvLine("Num dummy outputs", this.getNumDummyOutputs(), indent);
	    str += GenUtils.kvLine("Extra hex", this.getExtraHex(), indent);
	    return str.slice(0, str.length - 1);  // strip last newline
	  }
	  
	  // private helper to merge transfers
	  static _mergeIncomingTransfer(transfers, transfer) {
	    for (let aTransfer of transfers) {
	      if (aTransfer.getAccountIndex() === transfer.getAccountIndex() && aTransfer.getSubaddressIndex() === transfer.getSubaddressIndex()) {
	        aTransfer.merge(transfer);
	        return;
	      }
	    }
	    transfers.push(transfer);
	  }
	}

	MoneroTxWallet_1 = MoneroTxWallet;
	return MoneroTxWallet_1;
}

var MoneroTxQuery_1;
var hasRequiredMoneroTxQuery;

function requireMoneroTxQuery () {
	if (hasRequiredMoneroTxQuery) return MoneroTxQuery_1;
	hasRequiredMoneroTxQuery = 1;
	const assert = require$$0;
	const MoneroOutputQuery = requireMoneroOutputQuery();
	const MoneroTransferQuery = requireMoneroTransferQuery();
	const MoneroTxWallet = requireMoneroTxWallet();

	/**
	 * <p>Configuration to query transactions.</p>
	 * 
	 * @class
	 * @extends {MoneroTxWallet}
	 */
	class MoneroTxQuery extends MoneroTxWallet {
	  
	  /**
	   * <p>Construct the transaction query.</p>
	   * 
	   * <p>Example:</p>
	   * 
	   * <code>
	   * &sol;&sol; get transactions with unlocked incoming transfers to account 0<br>
	   * let txs = await wallet.getTxs({<br>
	   * &nbsp;&nbsp; isLocked: false,<br>
	   * &nbsp;&nbsp; transferQuery: {<br>
	   * &nbsp;&nbsp;&nbsp;&nbsp; isIncoming: true,<br>
	   * &nbsp;&nbsp;&nbsp;&nbsp; accountIndex: 0<br>
	   * &nbsp;&nbsp; }<br>
	   * });
	   * </code>
	   * 
	   * <p>All configuration is optional.  All transactions are returned except those that don't meet criteria defined in this query.</p>
	   * 
	   * @param {object} config - tx query configuration
	   * @param {string} config.hash - get a tx with this hash
	   * @param {string[]} config.txHashes - get txs with these hashes
	   * @param {int} config.height - get txs with this height
	   * @param {int} config.minHeight - get txs with height greater than or equal to this height
	   * @param {int} config.maxHeight - get txs with height less than or equal to this height
	   * @param {boolean} config.isConfirmed - get confirmed or unconfirmed txs
	   * @param {boolean} config.inTxPool - get txs in or out of the tx pool
	   * @param {boolean} config.relay - get txs with the same relay status
	   * @param {boolean} config.isRelayed - get relayed or non-relayed txs
	   * @param {boolean} config.isFailed - get failed or non-failed txs
	   * @param {boolean} config.isMinerTx - get miner or non-miner txs
	   * @param {boolean} config.isLocked - get locked or unlocked txs
	   * @param {boolean} config.isIncoming - get txs with or without incoming transfers
	   * @param {boolean} config.isOutgoing - get txs with or without outgoing transfers
	   * @param {string} config.paymentId - get txs with this payment ID
	   * @param {string} config.paymentIds - get txs with a payment ID among these payment IDs
	   * @param {boolean} config.hasPaymentId - get txs with or without payment IDs
	   * @param {object|MoneroTransferQuery} config.transferQuery - get txs with transfers matching this transfer query
	   * @param {object|MoneroOutputQuery} config.inputQuery - get txs with inputs matching this input query
	   * @param {object|MoneroOutputQuery} config.outputQuery - get txs with outputs matching this output query
	   */
	  constructor(config) {
	    super(config);
	    
	    // deserialize if necessary
	    if (this.state.transferQuery && !(this.state.transferQuery instanceof MoneroTransferQuery)) this.state.transferQuery = new MoneroTransferQuery(this.state.transferQuery);
	    if (this.state.inputQuery && !(this.state.inputQuery instanceof MoneroOutputQuery)) this.state.inputQuery = new MoneroOutputQuery(this.state.inputQuery);
	    if (this.state.outputQuery && !(this.state.outputQuery instanceof MoneroOutputQuery)) this.state.outputQuery = new MoneroOutputQuery(this.state.outputQuery);
	    
	    // link cycles
	    if (this.state.transferQuery) this.state.transferQuery.setTxQuery(this);
	    if (this.state.inputQuery) this.state.inputQuery.setTxQuery(this);
	    if (this.state.outputQuery) this.state.outputQuery.setTxQuery(this);
	    
	    // alias 'hash' to hashes
	    if (this.state.hash) {
	      this.setHashes([this.state.hash]);
	      delete this.state.hash;
	    }
	  }
	  
	  copy() {
	    return new MoneroTxQuery(this);
	  }
	  
	  toJson() {
	    let json = Object.assign({}, this.state, super.toJson()); // merge json onto inherited state
	    if (this.getTransferQuery()) json.transferQuery = this.getTransferQuery().toJson();
	    if (this.getInputQuery()) json.inputQuery = this.getInputQuery().toJson();
	    if (this.getOutputQuery()) json.outputQuery = this.getOutputQuery().toJson();
	    delete json.block;  // do not serialize parent block
	    return json;
	  }
	  
	  isIncoming() {
	    return this.state.isIncoming;
	  }
	  
	  setIsIncoming(isIncoming) {
	    this.state.isIncoming = isIncoming;
	    return this;
	  }
	  
	  isOutgoing() {
	    return this.state.isOutgoing;
	  }
	  
	  setIsOutgoing(isOutgoing) {
	    this.state.isOutgoing = isOutgoing;
	    return this;
	  }

	  getHashes() {
	    return this.state.hashes;
	  }

	  setHashes(hashes) {
	    this.state.hashes = hashes;
	    return this;
	  }
	  
	  setHash(hash) {
	    if (hash === undefined) return this.setHashes(undefined);
	    assert(typeof hash === "string");
	    return this.setHashes([hash]);
	  }
	  
	  hasPaymentId() {
	    return this.state.hasPaymentId;
	  }
	  
	  setHasPaymentId() {
	    this.state.hasPaymentId = hasPaymentId;
	    return this;
	  }
	  
	  getPaymentIds() {
	    return this.state.paymentIds;
	  }

	  setPaymentIds(paymentIds) {
	    this.state.paymentIds = paymentIds;
	    return this;
	  }
	  
	  setPaymentId(paymentId) {
	    if (paymentId === undefined) return this.setPaymentIds(undefined);
	    assert(typeof paymentId === "string");
	    return this.setPaymentIds([paymentId]);
	  }
	  
	  getHeight() {
	    return this.state.height;
	  }
	  
	  setHeight(height) {
	    this.state.height = height;
	    return this;
	  }
	  
	  getMinHeight() {
	    return this.state.minHeight;
	  }

	  setMinHeight(minHeight) {
	    this.state.minHeight = minHeight;
	    return this;
	  }

	  getMaxHeight() {
	    return this.state.maxHeight;
	  }

	  setMaxHeight(maxHeight) {
	    this.state.maxHeight = maxHeight;
	    return this;
	  }
	  
	  getIncludeOutputs() {
	    return this.state.includeOutputs;
	  }

	  setIncludeOutputs(includeOutputs) {
	    this.state.includeOutputs = includeOutputs;
	    return this;
	  }
	  
	  getTransferQuery() {
	    return this.state.transferQuery;
	  }
	  
	  setTransferQuery(transferQuery) {
	    this.state.transferQuery = transferQuery;
	    if (transferQuery) transferQuery.state.txQuery = this;
	    return this;
	  }
	  
	  getInputQuery() {
	    return this.state.inputQuery;
	  }
	  
	  setInputQuery(inputQuery) {
	    this.state.inputQuery = inputQuery;
	    if (inputQuery) inputQuery.state.txQuery = this;
	    return this;
	  }
	  
	  getOutputQuery() {
	    return this.state.outputQuery;
	  }
	  
	  setOutputQuery(outputQuery) {
	    this.state.outputQuery = outputQuery;
	    if (outputQuery) outputQuery.state.txQuery = this;
	    return this;
	  }
	  
	  meetsCriteria(tx, queryChildren) {
	    if (!(tx instanceof MoneroTxWallet)) throw new Error("Tx not given to MoneroTxQuery.meetsCriteria(tx)");
	    if (queryChildren === undefined) queryChildren = true;
	    
	    // filter on tx
	    if (this.getHash() !== undefined && this.getHash() !== tx.getHash()) return false;
	    if (this.getPaymentId() !== undefined && this.getPaymentId() !== tx.getPaymentId()) return false;
	    if (this.isConfirmed() !== undefined && this.isConfirmed() !== tx.isConfirmed()) return false;
	    if (this.inTxPool() !== undefined && this.inTxPool() !== tx.inTxPool()) return false;
	    if (this.getRelay() !== undefined && this.getRelay() !== tx.getRelay()) return false;
	    if (this.isRelayed() !== undefined && this.isRelayed() !== tx.isRelayed()) return false;
	    if (this.isFailed() !== undefined && this.isFailed() !== tx.isFailed()) return false;
	    if (this.isMinerTx() !== undefined && this.isMinerTx() !== tx.isMinerTx()) return false;
	    if (this.isLocked() !== undefined && this.isLocked() !== tx.isLocked()) return false;
	    
	    // filter on having a payment id
	    if (this.hasPaymentId() !== undefined) {
	      if (this.hasPaymentId() && tx.getPaymentId() === undefined) return false;
	      if (!this.hasPaymentId() && tx.getPaymentId() !== undefined) return false;
	    }
	    
	    // filter on incoming
	    if (this.isIncoming() !== undefined) {
	      if (this.isIncoming() && !tx.isIncoming()) return false;
	      if (!this.isIncoming() && tx.isIncoming()) return false;
	    }
	    
	    // filter on outgoing
	    if (this.isOutgoing() !== undefined) {
	      if (this.isOutgoing() && !tx.isOutgoing()) return false;
	      if (!this.isOutgoing() && tx.isOutgoing()) return false;
	    }
	    
	    // filter on remaining fields
	    let txHeight = tx.getBlock() === undefined ? undefined : tx.getBlock().getHeight();
	    if (this.getHashes() !== undefined && !this.getHashes().includes(tx.getHash())) return false;
	    if (this.getPaymentIds() !== undefined && !this.getPaymentIds().includes(tx.getPaymentId())) return false;
	    if (this.getHeight() !== undefined && (txHeight === undefined || txHeight !== this.getHeight())) return false;
	    if (this.getMinHeight() !== undefined && txHeight !== undefined && txHeight < this.getMinHeight()) return false; // do not filter unconfirmed
	    if (this.getMaxHeight() !== undefined && (txHeight === undefined || txHeight > this.getMaxHeight())) return false;
	    // TODO: filtering not complete
	    
	    // done if not querying transfers or outputs
	    if (!queryChildren) return true;
	    
	    // at least one transfer must meet transfer filter if defined
	    if (this.getTransferQuery()) {
	      let matchFound = false;
	      if (tx.getOutgoingTransfer() && this.getTransferQuery().meetsCriteria(tx.getOutgoingTransfer(), false)) matchFound = true;
	      else if (tx.getIncomingTransfers()) {
	        for (let incomingTransfer of tx.getIncomingTransfers()) {
	          if (this.getTransferQuery().meetsCriteria(incomingTransfer, false)) {
	            matchFound = true;
	            break;
	          }
	        }
	      }
	      if (!matchFound) return false;
	    }
	    
	    // at least one input must meet input query if defined
	    if (this.getInputQuery() !== undefined) {
	      if (tx.getInputs() === undefined || tx.getInputs().length === 0) return false;
	      let matchFound = false;
	      for (let input of tx.getInputs()) {
	        if (this.getInputQuery().meetsCriteria(input, false)) {
	          matchFound = true;
	          break;
	        }
	      }
	      if (!matchFound) return false;
	    }
	    
	    // at least one output must meet output query if defined
	    if (this.getOutputQuery() !== undefined) {
	      if (tx.getOutputs() === undefined || tx.getOutputs().length === 0) return false;
	      let matchFound = false;
	      for (let output of tx.getOutputs()) {
	        if (this.getOutputQuery().meetsCriteria(output, false)) {
	          matchFound = true;
	          break;
	        }
	      }
	      if (!matchFound) return false;
	    }
	    
	    return true;  // transaction meets filter criteria
	  }
	}

	MoneroTxQuery_1 = MoneroTxQuery;
	return MoneroTxQuery_1;
}

const assert$5 = require$$0;
const GenUtils$2 = GenUtils_1;
const MoneroBlockHeader = MoneroBlockHeader_1;
const MoneroTx = MoneroTx_1;
const MoneroTxQuery$2 = requireMoneroTxQuery();
const MoneroTxWallet = requireMoneroTxWallet();

/**
 * Models a Monero block in the blockchain.
 * 
 * @extends {MoneroBlockHeader}
 */
class MoneroBlock$1 extends MoneroBlockHeader {
  
  /**
   * Construct the model.
   * 
   * @param {MoneroBlock|MoneroBlockHeader|object} state is existing state to initialize from (optional)
   * @param {MoneroBlock.DeserializationType} txType informs the tx deserialization type (MoneroTx, MoneroTxWallet, MoneroTxQuery)
   */
  constructor(state, txType) {
    super(state);
    state = this.state;
    
    // deserialize miner tx
    if (state.minerTx && !(state.minerTx instanceof MoneroTx)) state.minerTx = new MoneroTx(state.minerTx).setBlock(this);
    
    // deserialize non-miner txs
    if (state.txs) {
      for (let i = 0; i < state.txs.length; i++) {
        if (txType === MoneroBlock$1.DeserializationType.TX || txType === undefined) {
          if (!(state.txs[i] instanceof MoneroTx)) state.txs[i] = new MoneroTx(state.txs[i]).setBlock(this);
        } else if (txType === MoneroBlock$1.DeserializationType.TX_WALLET) {
          if (!(state.txs[i] instanceof MoneroTxWallet)) state.txs[i] = new MoneroTxWallet(state.txs[i]).setBlock(this);
        } else if (txType === MoneroBlock$1.DeserializationType.TX_QUERY) {
          if (!(state.txs[i] instanceof MoneroTxQuery$2)) state.txs[i] = new MoneroTxQuery$2(state.txs[i]).setBlock(this);
        } else {
          throw new Error("Unrecognized tx deserialization type: " + txType);
        }
      }
    }
  }
  
  getHex() {
    return this.state.hex;
  }
  
  setHex(hex) {
    this.state.hex = hex;
    return this;
  }
  
  getMinerTx() {
    return this.state.minerTx;
  }
  
  setMinerTx(minerTx) {
    this.state.minerTx = minerTx;
    return this;
  }
  
  getTxs() {
    return this.state.txs;
  }
  
  setTxs(txs) {
    this.state.txs = txs;
    return this;
  }
  
  getTxHashes() {
    return this.state.txHashes;
  }
  
  setTxHashes(txHashes) {
    this.state.txHashes = txHashes;
    return this;
  }
  
  copy() {
    return new MoneroBlock$1(this);
  }
  
  toJson() {
    let json = super.toJson();
    if (this.getMinerTx()) json.minerTx = this.getMinerTx().toJson();
    if (this.getTxs()) {
      json.txs = [];
      for (let tx of this.getTxs()) json.txs.push(tx.toJson());
    }
    return json;
  }
  
  merge(block) {
    assert$5(block instanceof MoneroBlock$1);
    if (this === block) return this;
    
    // merge header fields
    super.merge(block);
    
    // merge reconcilable block extensions
    this.setHex(GenUtils$2.reconcile(this.getHex(), block.getHex()));
    this.setTxHashes(GenUtils$2.reconcile(this.getTxHashes(), block.getTxHashes()));
    
    // merge miner tx
    if (this.getMinerTx() === undefined) this.setMinerTx(block.getMinerTx());
    if (block.getMinerTx() !== undefined) {
      block.getMinerTx().setBlock(this);
      this.getMinerTx().merge(block.getMinerTx());
    }
    
    // merge non-miner txs
    if (block.getTxs() !== undefined) {
      for (let tx of block.getTxs()) {
        tx.setBlock(this);
        MoneroBlock$1._mergeTx(this.getTxs(), tx);
      }
    }

    return this;
  }
  
  toString(indent = 0) {
    let str = super.toString(indent) + "\n";
    str += GenUtils$2.kvLine("Hex", this.getHex(), indent);
    if (this.getTxs()) {
      str += GenUtils$2.kvLine("Txs", "", indent);
      for (let tx of this.getTxs()) {
        str += tx.toString(indent + 1) + "\n";
      }
    }
    if (this.getMinerTx()) {
      str += GenUtils$2.kvLine("Miner tx", "", indent);
      str += this.getMinerTx().toString(indent + 1) + "\n";
    }
    str += GenUtils$2.kvLine("Txs hashes", this.getTxHashes(), indent);
    return str[str.length - 1] === "\n" ? str.slice(0, str.length - 1) : str  // strip last newline
  }
  
  // private helper to merge txs
  static _mergeTx(txs, tx) {
    for (let aTx of txs) {
      if (aTx.getHash() === tx.getHash()) {
        aTx.merge(tx);
        return;
      }
    }
    txs.push(tx);
  }
}

MoneroBlock$1.DeserializationType = {
    TX: 0,
    TX_WALLET: 1,
    TX_QUERY: 2
};

var MoneroBlock_1 = MoneroBlock$1;

const BigInteger$f = biginteger.BigInteger;

/**
 * Monero block template to mine.
 */
class MoneroBlockTemplate {
  
  constructor(state) {
    state = Object.assign({}, state);
    this.state = state;
    
    // deserialize BigIntegers
    if (state.expectedReward !== undefined && !(state.expectedReward instanceof BigInteger$f)) state.expectedReward = BigInteger$f.parse(state.expectedReward);
    if (state.difficulty !== undefined && !(state.difficulty instanceof BigInteger$f)) state.difficulty = BigInteger$f.parse(state.difficulty);
  }
  
  toJson() {
    let json = Object.assign({}, this.state);
    if (this.getExpectedReward()) json.expectedReward = this.getExpectedReward().toString();
    if (this.getDifficulty()) json.difficulty = this.getDifficulty().toString();
    return json;
  }
  
  toJson() {
    let json = Object.assign({}, this.state);
    if (json.expectedReward) json.expectedReward = json.expectedReward.toString();
    if (json.difficulty) json.difficulty = json.difficulty.toString();
    return json;
  }
  
  getBlockTemplateBlob() {
    return this.state.blockTemplateBlob;
  }
  
  setBlockTemplateBlob(blockTemplateBlob) {
    this.state.blockTemplateBlob = blockTemplateBlob;
    return this;
  }
  
  getBlockHashingBlob() {
    return this.state.blockHashingBlob;
  }
  
  setBlockHashingBlob(blockHashingBlob) {
    this.state.blockHashingBlob = blockHashingBlob;
    return this;
  }
  
  getDifficulty() {
    return this.state.difficulty;
  }
  
  setDifficulty(difficulty) {
    this.state.difficulty = difficulty;
    return this;
  }
  
  getExpectedReward() {
    return this.state.expectedReward;
  }
  
  setExpectedReward(expectedReward) {
    this.state.expectedReward = expectedReward;
    return this;
  }
  
  getHeight() {
    return this.state.height;
  }
  
  setHeight(height) {
    this.state.height = height;
    return this;
  }
  
  getPrevHash() {
    return this.state.prevId;
  }
  
  setPrevHash(prevId) {
    this.state.prevId = prevId;
    return this;
  }
  
  getReservedOffset() {
    return this.state.reservedOffset;
  }
  
  setReservedOffset(reservedOffset) {
    this.state.reservedOffset = reservedOffset;
    return this;
  }
  
  getSeedHeight() {
    return this.state.height;
  }
  
  setSeedHeight(seedHeight) {
    this.state.seedHeight = seedHeight;
    return this;
  }
  
  getSeedHash() {
    return this.state.seedHash;
  }
  
  setSeedHash(seedHash) {
    this.state.seedHash = seedHash;
    return this;
  }
  
  getNextSeedHash() {
    return this.state.nextSeedHash
  }
  
  setNextSeedHash(nextSeedHash) {
    this.state.nextSeedHash = nextSeedHash;
    return this;
  }
}

var MoneroBlockTemplate_1 = MoneroBlockTemplate;

/**
 * Monero daemon connection span.
 */

class MoneroConnectionSpan$2 {
  
  constructor(state) {
    this.state = Object.assign({}, state);
  }
  
  toJson() {
    return Object.assign({}, this.state);
  }
  
  getConnectionId() {
    return this.state.connectionId;
  }

  setConnectionId(connectionId) {
    this.state.connectionId = connectionId;
    return this;
  }
  
  getNumBlocks() {
    return this.state.numBlocks;
  }

  setNumBlocks(numBlocks) {
    this.state.numBlocks = numBlocks;
    return this;
  }
  
  getRemoteAddress() {
    return this.state.remoteAddress;
  }

  setRemoteAddress(remoteAddress) {
    this.state.remoteAddress = remoteAddress;
    return this;
  }
  
  getRate() {
    return this.state.rate;
  }

  setRate(rate) {
    this.state.rate = rate;
    return this;
  }
  
  getSpeed() {
    return this.state.speed;
  }

  setSpeed(speed) {
    this.state.speed = speed;
    return this;
  }
  
  getSize() {
    return this.state.size;
  }
  
  setSize(size) {
    this.state.size = size;
    return this;
  }
  
  getStartHeight() {
    return this.state.startHeight;
  }
  
  setStartHeight(startHeight) {
    this.state.startHeight = startHeight;
    return this;
  }
}

var MoneroConnectionSpan_1 = MoneroConnectionSpan$2;

const BigInteger$e = biginteger.BigInteger;

/**
 * Monero daemon info.
 */
class MoneroDaemonInfo {
  
  constructor(state) {
    state = Object.assign({}, state);
    this.state = state;
    
    // deserialize BigIntegers
    if (state.difficulty !== undefined && !(state.difficulty instanceof BigInteger$e)) state.difficulty = BigInteger$e.parse(state.difficulty);
    if (state.cumulativeDifficulty !== undefined && !(state.cumulativeDifficulty instanceof BigInteger$e)) state.cumulativeDifficulty = BigInteger$e.parse(state.cumulativeDifficulty);
    if (state.credits !== undefined && !(state.credits instanceof BigInteger$e)) state.credits = BigInteger$e.parse(state.credits);
  }
  
  toJson() {
    let json = Object.assign([], this.state);
    if (json.difficulty) json.difficulty = json.difficulty.toString();
    if (json.cumulativeDifficulty) json.cumulativeDifficulty = json.cumulativeDifficulty.toString();
    if (json.credits) json.credits = json.credits.toString();
    return json;
  }
  
  getVersion() {
    return this.state.version;
  }
  
  setVersion(version) {
    this.state.version = version;
    return this;
  }
  
  getNumAltBlocks() {
    return this.state.numAltBlocks;
  }
  
  setNumAltBlocks(numAltBlocks) {
    this.state.numAltBlocks = numAltBlocks;
    return this;
  }
  
  getBlockSizeLimit() {
    return this.state.blockSizeLimit;
  }
  
  setBlockSizeLimit(blockSizeLimit) {
    this.state.blockSizeLimit = blockSizeLimit;
    return this;
  }
  
  getBlockSizeMedian() {
    return this.state.blockSizeMedian;
  }
  
  setBlockSizeMedian(blockSizeMedian) {
    this.state.blockSizeMedian = blockSizeMedian;
    return this;
  }
  
  getBlockWeightLimit() {
    return this.state.blockWeightLimit;
  }
  
  setBlockWeightLimit(blockWeightLimit) {
    this.state.blockWeightLimit = blockWeightLimit;
    return this;
  }
  
  getBlockWeightMedian() {
    return this.state.blockWeightMedian;
  }
  
  setBlockWeightMedian(blockWeightMedian) {
    this.state.blockWeightMedian = blockWeightMedian;
    return this;
  }
  
  getBootstrapDaemonAddress() {
    return this.state.bootstrapDaemonAddress;
  }
  
  setBootstrapDaemonAddress(bootstrapDaemonAddress) {
    this.state.bootstrapDaemonAddress = bootstrapDaemonAddress;
    return this;
  }
  
  getDifficulty() {
    return this.state.difficulty;
  }
  
  setDifficulty(difficulty) {
    this.state.difficulty = difficulty;
    return this;
  }
  
  getCumulativeDifficulty() {
    return this.state.cumulativeDifficulty;
  }
  
  setCumulativeDifficulty(cumulativeDifficulty) {
    this.state.cumulativeDifficulty = cumulativeDifficulty;
    return this;
  }
  
  getFreeSpace() {
    return this.state.freeSpace;
  }
  
  setFreeSpace(freeSpace) {
    this.state.freeSpace = freeSpace;
    return this;
  }
  
  getNumOfflinePeers() {
    return this.state.numOfflinePeers;
  }
  
  setNumOfflinePeers(numOfflinePeers) {
    this.state.numOfflinePeers = numOfflinePeers;
    return this;
  }
  
  getNumOnlinePeers() {
    return this.state.numOnlinePeers;
  }
  
  setNumOnlinePeers(numOnlinePeers) {
    this.state.numOnlinePeers = numOnlinePeers;
    return this;
  }
  
  getHeight() {
    return this.state.height;
  }
  
  setHeight(height) {
    this.state.height = height;
    return this;
  }
  
  getHeightWithoutBootstrap() {
    return this.state.heightWithoutBootstrap;
  }
  
  setHeightWithoutBootstrap(heightWithoutBootstrap) {
    this.state.heightWithoutBootstrap = heightWithoutBootstrap;
    return this;
  }
  
  getNetworkType() {
    return this.state.networkType;
  }

  setNetworkType(networkType) {
    this.state.networkType = networkType;
    return this;
  }

  isOffline() {
    return this.state.isOffline;
  }
  
  setIsOffline(isOffline) {
    this.state.isOffline = isOffline;
    return this;
  }
  
  getNumIncomingConnections() {
    return this.state.numIncomingConnections;
  }
  
  setNumIncomingConnections(numIncomingConnections) {
    this.state.numIncomingConnections = numIncomingConnections;
    return this;
  }
  
  getNumOutgoingConnections() {
    return this.state.numOutgoingConnections;
  }
  
  setNumOutgoingConnections(numOutgoingConnections) {
    this.state.numOutgoingConnections = numOutgoingConnections;
    return this;
  }
  
  getNumRpcConnections() {
    return this.state.numRpcConnections;
  }
  
  setNumRpcConnections(numRpcConnections) {
    this.state.numRpcConnections = numRpcConnections;
    return this;
  }
  
  getStartTimestamp() {
    return this.state.startTimestamp;
  }
  
  setStartTimestamp(startTimestamp) {
    this.state.startTimestamp = startTimestamp;
    return this;
  }
  
  getAdjustedTimestamp() {
    return this.state.adjustedTimestamp;
  }
  
  setAdjustedTimestamp(adjustedTimestamp) {
    this.state.adjustedTimestamp = adjustedTimestamp;
    return this;
  }
  
  getTarget() {
    return this.state.target;
  }
  
  setTarget(target) {
    this.state.target = target;
    return this;
  }
  
  getTargetHeight() {
    return this.state.targetHeight;
  }
  
  setTargetHeight(targetHeight) {
    this.state.targetHeight = targetHeight;
    return this;
  }
  
  getTopBlockHash() {
    return this.state.topBlockHash;
  }
  
  setTopBlockHash(topBlockHash) {
    this.state.topBlockHash = topBlockHash;
    return this;
  }
  
  getNumTxs() {
    return this.state.numTxs;
  }
  
  setNumTxs(numTxs) {
    this.state.numTxs = numTxs;
    return this;
  }
  
  getNumTxsPool() {
    return this.state.numTxsPool;
  }
  
  setNumTxsPool(numTxsPool) {
    this.state.numTxsPool = numTxsPool;
    return this;
  }
  
  getWasBootstrapEverUsed() {
    return this.state.wasBootstrapEverUsed;
  }
  
  setWasBootstrapEverUsed(wasBootstrapEverUsed) {
    this.state.wasBootstrapEverUsed = wasBootstrapEverUsed;
    return this;
  }
  
  getDatabaseSize() {
    return this.state.databaseSize;
  }
  
  setDatabaseSize(databaseSize) {
    this.state.databaseSize = databaseSize;
    return this;
  }
  
  getUpdateAvailable() {
    return this.state.updateAvailable;
  }
  
  setUpdateAvailable(updateAvailable) {
    this.state.updateAvailable = updateAvailable;
    return this;
  }
  
  getCredits() {
    return this.state.credits;
  }
  
  setCredits(credits) {
    this.state.credits = credits;
    return this;
  }
  
  isBusySyncing() {
    return this.state.isBusySyncing;
  }
  
  setIsBusySyncing(isBusySyncing) {
    this.state.isBusySyncing = isBusySyncing;
    return this;
  }
  
  isSynchronized() {
    return this.state.isSynchronized;
  }
  
  setIsSynchronized(isSynchronized) {
    this.state.isSynchronized = isSynchronized;
    return this;
  }
  
  isRestricted() {
    return this.state.isRestricted;
  }
  
  setIsRestricted(isRestricted) {
    this.state.isRestricted = isRestricted;
    return this;
  }
}

var MoneroDaemonInfo_1 = MoneroDaemonInfo;

/**
 * Receives notifications as a daemon is updated.
 */

class MoneroDaemonListener {
  
  /**
   * Called when a new block is added to the chain.
   * 
   * @param {MoneroBlockHeader} header - the header of the block added to the chain
   */
  async onBlockHeader(header) {
    this.lastHeader = header;
  }
  
  /**
   * Get the last notified block header.
   * 
   * @return {MoneroBlockHeader} the last notified block header
   */
  getLastBlockHeader() {
    return this.lastHeader;
  }
}

var MoneroDaemonListener_1 = MoneroDaemonListener;

const BigInteger$d = biginteger.BigInteger;

/**
 * Models a peer to the daemon.
 */
class MoneroPeer$1 {
  
  constructor(state) {
    this.state = Object.assign({}, state);
    if (this.state.rpcCreditsPerHash !== undefined && !(this.state.rpcCreditsPerHash instanceof BigInteger$d)) this.state.rpcCreditsPerHash = BigInteger$d.parse(this.state.rpcCreditsPerHash);
  }
  
  toJson() {
    let json = Object.assign({}, this.state);
    if (json.rpcCreditsPerHash) json.rpcCreditsPerHash = json.rpcCreditsPerHash.toString();
    return json;
  }
  
  getId() {
    return this.state.id;
  }

  setId(id) {
    this.state.id = id;
    return this;
  }

  getAddress() {
    return this.state.address;
  }

  setAddress(address) {
    this.state.address = address;
    return this;
  }

  getHost() {
    return this.state.host;
  }

  setHost(host) {
    this.state.host = host;
    return this;
  }

  getPort() {
    return this.state.port;
  }

  setPort(port) {
    this.state.port = port;
    return this;
  }
  
  /**
   * Indicates if the peer was online when last checked (aka "white listed" as
   * opposed to "gray listed").
   * 
   * @return {boolean} true if peer was online when last checked, false otherwise
   */
  isOnline() {
    return this.state.isOnline;
  }
  
  setIsOnline(isOnline) {
    this.state.isOnline = isOnline;
    return this;
  }
  
  getLastSeenTimestamp() {
    return this.state.lastSeenTimestamp;
  }
  
  setLastSeenTimestamp(lastSeenTimestamp) {
    this.state.lastSeenTimestamp = lastSeenTimestamp;
    return this;
  }
  
  getPruningSeed() {
    return this.state.pruningSeed;
  }
  
  setPruningSeed(pruningSeed) {
    this.state.pruningSeed = pruningSeed;
    return this;
  }
  
  getRpcPort() {
    return this.state.rpcPort;
  }

  setRpcPort(rpcPort) {
    this.state.rpcPort = rpcPort;
    return this;
  }
  
  getRpcCreditsPerHash() {
    return this.state.rpcCreditsPerHash;
  }
  
  setRpcCreditsPerHash(rpcCreditsPerHash) {
    this.state.rpcCreditsPerHash = rpcCreditsPerHash;
    return this;
  }
  
    getId() {
    return this.state.id;
  }

  setId(id) {
    this.state.id = id;
    return this;
  }

  getAvgDownload() {
    return this.state.avgDownload;
  }

  setAvgDownload(avgDownload) {
    this.state.avgDownload = avgDownload;
    return this;
  }

  getAvgUpload() {
    return this.state.avgUpload;
  }

  setAvgUpload(avgUpload) {
    this.state.avgUpload = avgUpload;
    return this;
  }

  getCurrentDownload() {
    return this.state.currentDownload;
  }

  setCurrentDownload(currentDownload) {
    this.state.currentDownload = currentDownload;
    return this;
  }

  getCurrentUpload() {
    return this.state.currentUpload;
  }

  setCurrentUpload(currentUpload) {
    this.state.currentUpload = currentUpload;
    return this;
  }

  getHeight() {
    return this.state.height;
  }

  setHeight(height) {
    this.state.height = height;
    return this;
  }

  isIncoming() {
    return this.state.isIncoming;
  }

  setIsIncoming(isIncoming) {
    this.state.isIncoming = isIncoming;
    return this;
  }

  getLiveTime() {
    return this.state.liveTime;
  }

  setLiveTime(liveTime) {
    this.state.liveTime = liveTime;
    return this;
  }

  isLocalIp() {
    return this.state.isLocalIp;
  }

  setIsLocalIp(isLocalIp) {
    this.state.isLocalIp = isLocalIp;
    return this;
  }

  isLocalHost() {
    return this.state.isLocalHost;
  }

  setIsLocalHost(isLocalHost) {
    this.state.isLocalHost = isLocalHost;
    return this;
  }

  getNumReceives() {
    return this.state.numReceives;
  }

  setNumReceives(numReceives) {
    this.state.numReceives = numReceives;
    return this;
  }

  getNumSends() {
    return this.state.numSends;
  }

  setNumSends(numSends) {
    this.state.numSends = numSends;
    return this;
  }

  getReceiveIdleTime() {
    return this.state.receiveIdleTime;
  }

  setReceiveIdleTime(receiveIdleTime) {
    this.state.receiveIdleTime = receiveIdleTime;
    return this;
  }

  getSendIdleTime() {
    return this.state.sendIdleTime;
  }

  setSendIdleTime(sendIdleTime) {
    this.state.sendIdleTime = sendIdleTime;
    return this;
  }

  getState() {
    return this.state.state;
  }

  setState(state) {
    this.state.state = state;
    return this;
  }

  getNumSupportFlags() {
    return this.state.numSupportFlags;
  }

  setNumSupportFlags(numSupportFlags) {
    this.state.numSupportFlags = numSupportFlags;
    return this;
  }
  
  getType() {
    return this.state.type;
  }
  
  setType(type) {
    this.state.type = type;
    return this;
  }
}

var MoneroPeer_1 = MoneroPeer$1;

const BigInteger$c = biginteger.BigInteger;
const MoneroConnectionSpan$1 = MoneroConnectionSpan_1;
const MoneroPeer = MoneroPeer_1;

/**
 * Models daemon synchronization information.
 */
class MoneroDaemonSyncInfo {
  
  constructor(state) {
    
    // copy state
    state = Object.assign({}, state);
    
    // deserialize if necessary
    if (state.peers) {
      for (let i = 0; i < state.peers.length; i++) {
        if (!(state.peers[i] instanceof MoneroPeer)) {
          state.peers[i] = new MoneroPeer(state.peers[i]);
        }
      }
    }
    if (state.spans) {
      for (let i = 0; i < state.spans.length; i++) {
        if (!(state.spans[i] instanceof MoneroConnectionSpan$1)) {
          state.spans[i] = new MoneroConnectionSpan$1(state.spans[i]);
        }
      }
    }
    if (state.credits !== undefined && !(state.credits instanceof BigInteger$c)) state.credits = BigInteger$c.parse(state.credits);
    
    // assign internal state
    this.state = state;
  }
  
  toJson() {
    let json = Object.assign({}, this.state);
    if (json.peers) {
      for (let i = 0; i < json.peers.length; i++) {
        json.peers[i] = json.peers[i].toJson();
      }
    }
    if (json.spans) {
      for (let i = 0; i < json.spans.length; i++) {
        json.spans[i] = json.spans[i].toJson();
      }
    }
    if (json.credits) json.credits = json.credits.toString();
    return json;
  }
  
  getHeight() {
    return this.state.height;
  }
  
  setHeight(height) {
    this.state.height = height;
    return this;
  }
  
  getPeers() {
    return this.state.peers;
  }
  
  setPeers(peers) {
    this.state.peers = peers;
    return this;
  }
  
  getSpans() {
    return this.state.spans;
  }
  
  setSpans(spans) {
    this.state.spans = spans;
    return this;
  }
  
  getTargetHeight() {
    return this.state.targetHeight;
  }
  
  setTargetHeight(targetHeight) {
    this.state.targetHeight = targetHeight;
    return this;
  }
  
  getNextNeededPruningSeed() {
    return this.state.nextNeededPruningSeed;
  }
  
  setNextNeededPruningSeed(nextNeededPruningSeed) {
    this.state.nextNeededPruningSeed = nextNeededPruningSeed;
    return this;
  }
  
  getOverview() {
    return this.state.overview;
  }
  
  setOverview(overview) {
    this.state.overview = overview;
    return this;
  }
  
  getCredits() {
    return this.state.credits;
  }
  
  setCredits(credits) {
    this.state.credits = credits;
    return this;
  }
  
  getTopBlockHash() {
    return this.state.topBlockHash;
  }
  
  setTopBlockHash(topBlockHash) {
    this.state.topBlockHash = topBlockHash;
    return this;
  }
}

var MoneroDaemonSyncInfo_1 = MoneroDaemonSyncInfo;

/**
 * Models the result of checking for a daemon update.
 */

class MoneroDaemonUpdateCheckResult$2 {
  
  /**
   * Deep copy constructor.
   * 
   * @param {MoneroDaemonUpdateCheckResult} is an existing result to deep copy from
   */
  constructor(result) {
    this.state = {};
    if (result !== undefined) {
      assert(result instanceof MoneroDaemonUpdateCheckResult$2);
      this.setIsUpdateAvailable(result.isUpdateAvailable());
      this.setVersion(result.getVersion());
      this.setHash(result.getHash());
      this.setAutoUri(result.getAutoUri());
      this.setUserUri(result.getUserUri());
    }
  }
  
  /**
   * Indicates if an update is available.
   * 
   * @return {boolean} true if an update is available, false otherwise
   */
  isUpdateAvailable() {
    return this.state.isUpdateAvailable;
  }
  
  setIsUpdateAvailable(isUpdateAvailable) {
    this.state.isUpdateAvailable = isUpdateAvailable;
    return this;
  }
  
  /**
   * Get the update's version.
   * 
   * @return {string} is the update's version
   */
  getVersion() {
    return this.state.version;
  }
  
  setVersion(version) {
    this.state.version = version;
    return this;
  }
  
  /**
   * Get the update's hash.
   * 
   * @return {string} is the update's hash
   */
  getHash() {
    return this.state.hash;
  }
  
  setHash(hash) {
    this.state.hash = hash;
    return this;
  }
  
  /**
   * Get the uri to automatically download the update.
   * 
   * @return {string} is the uri to automatically download the update
   */
  getAutoUri() {
    return this.state.autoUri;
  }
  
  setAutoUri(autoUri) {
    this.state.autoUri = autoUri;
    return this;
  }
  
  /**
   * Get the uri to manually download the update.
   * 
   * @return {string} is the uri to manually download the update
   */
  getUserUri() {
    return this.state.userUri;
  }
  
  setUserUri(userUri) {
    this.state.userUri = userUri;
    return this;
  }
}

var MoneroDaemonUpdateCheckResult_1 = MoneroDaemonUpdateCheckResult$2;

const MoneroDaemonUpdateCheckResult$1 = MoneroDaemonUpdateCheckResult_1;

/**
 * Models the result of downloading an update.
 */
class MoneroDaemonUpdateDownloadResult$1 extends MoneroDaemonUpdateCheckResult$1 {
  
  /**
   * Construct a download result.
   * 
   * @param {MoneroDaemonUpdateCheckResult} is an existing result to copy from
   */
  constructor(result) {
    super(result);
  }
  
  /**
   * Get the path the update was downloaded to.
   * 
   * @return {string} is the path the update was downloaded to
   */
  getDownloadPath() {
    return this.state.downloadPath;
  }
  
  setDownloadPath(downloadPath) {
    this.state.downloadPath = downloadPath;
    return this;
  }
}

var MoneroDaemonUpdateDownloadResult_1 = MoneroDaemonUpdateDownloadResult$1;

const BigInteger$b = biginteger.BigInteger;

/**
 * Monero hard fork info.
 */
class MoneroHardForkInfo {
  
  constructor(state) {
    this.state = Object.assign({}, state);
    if (this.state.credits !== undefined && !(this.state.credits instanceof BigInteger$b)) this.state.credits = BigInteger$b.parse(this.state.credits);
  }
  
  toJson() {
    let json = Object.assign({}, this.state);
    if (json.credits) json.credits = json.credits.toString();
    return json;
  }
  
  getEarliestHeight() {
    return this.state.earliestHeight;
  }

  setEarliestHeight(earliestHeight) {
    this.state.earliestHeight = earliestHeight;
    return this;
  }

  isEnabled() {
    return this.state.isEnabled;
  }

  setIsEnabled(isEnabled) {
    this.state.isEnabled = isEnabled;
    return this;
  }

  getState() {
    return this.state.state;
  }

  setState(state) {
    this.state.state = state;
    return this;
  }

  getThreshold() {
    return this.state.threshold;
  }

  setThreshold(threshold) {
    this.state.threshold = threshold;
    return this;
  }

  getVersion() {
    return this.state.version;
  }

  setVersion(version) {
    this.state.version = version;
    return this;
  }

  getNumVotes() {
    return this.state.numVotes;
  }

  setNumVotes(numVotes) {
    this.state.numVotes = numVotes;
    return this;
  }

  getWindow() {
    return this.state.window;
  }

  setWindow(window) {
    this.state.window = window;
    return this;
  }

  getVoting() {
    return this.state.voting;
  }

  setVoting(voting) {
    this.state.voting = voting;
    return this;
  }
  
  getCredits() {
    return this.state.credits;
  }
  
  setCredits(credits) {
    this.state.credits = credits;
    return this;
  }
  
  getTopBlockHash() {
    return this.state.topBlockHash;
  }
  
  setTopBlockHash(topBlockHash) {
    this.state.topBlockHash = topBlockHash;
    return this;
  }
}

var MoneroHardForkInfo_1 = MoneroHardForkInfo;

/**
 * Enumerate key image spent statuses.
 * 
 * @hideconstructor
 */

class MoneroKeyImageSpentStatus {}

/**
 * Key image is not spent (value=0).
 */
MoneroKeyImageSpentStatus.NOT_SPENT = 0;

/**
 * Key image is confirmed (value=1).
 */
MoneroKeyImageSpentStatus.CONFIRMED = 1;

/**
 * Key image is in the pool (value=2).
 */
MoneroKeyImageSpentStatus.TX_POOL = 2;

var MoneroKeyImageSpentStatus_1 = MoneroKeyImageSpentStatus;

const BigInteger$a = biginteger.BigInteger;

/**
 * Model for the summation of miner emissions and fees.
 */
class MoneroMinerTxSum {
  
  constructor(state) {
    state = Object.assign({}, state);
    this.state = state;
    
    // deserialize BigIntegers
    if (state.emissionSum !== undefined && !(state.emissionSum instanceof BigInteger$a)) state.emissionSum = BigInteger$a.parse(state.emissionSum);
    if (state.feeSum !== undefined && !(state.feeSum instanceof BigInteger$a)) state.feeSum = BigInteger$a.parse(state.feeSum);
  }
  
  toJson() {
    let json = Object.assign({}, this.state);
    if (this.getEmissionSum()) json.emissionSum = this.getEmissionSum().toString();
    if (this.getFeeSum()) json.feeSum = this.getFeeSum().toString();
    return json;
  }
  
  getEmissionSum() {
    return this.state.emissionSum;
  }
  
  setEmissionSum(emissionSum) {
    this.state.emissionSum = emissionSum;
    return this;
  }
  
  getFeeSum() {
    return this.state.feeSum;
  }
  
  setFeeSum(feeSum) {
    this.state.feeSum = feeSum;
    return this;
  }
}

var MoneroMinerTxSum_1 = MoneroMinerTxSum;

/**
 * Models daemon mining status.
 */

class MoneroMiningStatus {
  
  constructor(state) {
    if (!state) state = {};
    else if (state instanceof MoneroMiningStatus) state = state.toJson();
    else if (typeof state === "object") state = Object.assign({}, state);
    else throw new MoneroError("state must be a MoneroMiningStatus or JavaScript object");
    this.state = state;
  }
  
  toJson() {
    return Object.assign({}, this.state);
  }
  
  isActive() {
    return this.state.isActive;
  }
  
  setIsActive(isActive) {
    this.state.isActive = isActive;
    return this;
  }
  
  getAddress() {
    return this.state.address;
  }
  
  setAddress(address) {
    this.state.address = address;
    return this;
  }
  
  getSpeed() {
    return this.state.speed;
  }
  
  setSpeed(speed) {
    this.state.speed = speed;
    return this;
  }
  
  getNumThreads() {
    return this.state.numThreads;
  }
  
  setNumThreads(numThreads) {
    this.state.numThreads = numThreads;
    return this;
  }
  
  isBackground() {
    return this.state.isBackground;
  }
  
  setIsBackground(isBackground) {
    this.state.isBackground = isBackground;
    return this;
  }
}

var MoneroMiningStatus_1 = MoneroMiningStatus;

const BigInteger$9 = biginteger.BigInteger;

/**
 * Entry in a Monero output histogram (see get_output_histogram of Daemon RPC documentation).
 */
class MoneroOutputHistogramEntry {
  
  constructor(state) {
    this.state = Object.assign({}, state);
    if (this.state.amount !== undefined && !(this.state.amount instanceof BigInteger$9)) this.state.amount = BigInteger$9.parse(this.state.amount);
  }
  
  toJson() {
    let json = Object.assign({}, this.state);
    if (json.amount) json.amount = json.amount.toString();
    return json;
  }
  
  getAmount() {
    return this.state.amount;
  }
  
  setAmount(amount) {
    this.state.amount = amount;
    return this;
  }

  getNumInstances() {
    return this.state.numInstances;
  }

  setNumInstances(numInstances) {
    this.state.numInstances = numInstances;
    return this;
  }

  getNumUnlockedInstances() {
    return this.state.numUnlockedInstances;
  }

  setNumUnlockedInstances(numUnlockedInstances) {
    this.state.numUnlockedInstances = numUnlockedInstances;
    return this;
  }

  getNumRecentInstances() {
    return this.state.numRecentInstances;
  }

  setNumRecentInstances(numRecentInstances) {
    this.state.numRecentInstances = numRecentInstances;
    return this;
  }
}

var MoneroOutputHistogramEntry_1 = MoneroOutputHistogramEntry;

const BigInteger$8 = biginteger.BigInteger;

/**
 * Models the result from submitting a tx to a daemon.
 */
class MoneroSubmitTxResult {
  
  constructor(state) {
    state = Object.assign({}, state);
    this.state = state;
    
    // deserialize BigIntegers
    if (state.credits !== undefined && !(state.credits instanceof BigInteger$8)) state.credits = BigInteger$8.parse(state.credits);
  }
  
  toJson() {
    let json = Object.assign({}, this.state);
    if (json.credits) json.credits = json.credits.toString();
    return json;
  }
  
  isGood() {
    return this.state.isGood;
  }
  
  setIsGood(isGood) {
    this.state.isGood = isGood;
    return this;
  }
  
  isRelayed() {
    return this.state.isRelayed;
  }
  
  setIsRelayed(isRelayed) {
    this.state.isRelayed = isRelayed;
    return this;
  }
  
  isDoubleSpendSeen() {
    return this.state.isDoubleSpendSeen;
  }
  
  setIsDoubleSpend(isDoubleSpendSeen) {
    this.state.isDoubleSpendSeen = isDoubleSpendSeen;
    return this;
  }
  
  isFeeTooLow() {
    return this.state.isFeeTooLow;
  }
  
  setIsFeeTooLow(isFeeTooLow) {
    this.state.isFeeTooLow = isFeeTooLow;
    return this;
  }
  
  isMixinTooLow() {
    return this.state.isMixinTooLow;
  }
  
  setIsMixinTooLow(isMixinTooLow) {
    this.state.isMixinTooLow = isMixinTooLow;
    return this;
  }
  
  hasInvalidInput() {
    return this.state.hasInvalidInput;
  }
  
  setHasInvalidInput(hasInvalidInput) {
    this.state.hasInvalidInput = hasInvalidInput;
    return this;
  }
  
  hasInvalidOutput() {
    return this.state.hasInvalidOutput;
  }
  
  setHasInvalidOutput(hasInvalidOutput) {
    this.state.hasInvalidOutput = hasInvalidOutput;
    return this;
  }
  
  hasTooFewOutputs() {
    return this.state.hasTooFewOutputs;
  }
  
  setHasTooFewOutputs(hasTooFewOutputs) {
    this.state.hasTooFewOutputs = hasTooFewOutputs;
    return this;
  }
  
  isOverspend() {
    return this.state.isOverspend;
  }
  
  setIsOverspend(isOverspend) {
    this.state.isOverspend = isOverspend;
    return this;
  }
  
  getReason() {
    return this.state.reason;
  }
  
  setReason(reason) {
    this.state.reason = reason;
    return this;
  }
  
  isTooBig() {
    return this.state.isTooBig;
  }
  
  setIsTooBig(isTooBig) {
    this.state.isTooBig = isTooBig;
    return this;
  }
  
  getSanityCheckFailed() {
    return this.state.sanityCheckFailed;
  }
  
  setSanityCheckFailed(sanityCheckFailed) {
    this.state.sanityCheckFailed = sanityCheckFailed;
    return this;
  }
  
  getCredits() {
    return this.state.credits;
  }
  
  setCredits(credits) {
    this.state.credits = credits;
    return this;
  }
  
  getTopBlockHash() {
    return this.state.topBlockHash;
  }
  
  setTopBlockHash(topBlockHash) {
    this.state.topBlockHash = topBlockHash;
    return this;
  }
}

var MoneroSubmitTxResult_1 = MoneroSubmitTxResult;

const BigInteger$7 = biginteger.BigInteger;

/**
 * Models transaction pool statistics.
 */
class MoneroTxPoolStats {
  
  constructor(state) {
    this.state = Object.assign({}, state);
    if (this.state.feeTotal !== undefined && !(this.state.feeTotal instanceof BigInteger$7)) this.state.feeTotal = BigInteger$7.parse(this.state.feeTotal);
  }
  
  toJson() {
    let json = Object.assign({}, this.state);
    if (json.feeTotal) json.feeTotal = json.feeTotal.toString();
    return json;
  }
  
  getNumTxs() {
    return this.state.numTxs;
  }
  
  setNumTxs(numTxs) {
    this.state.numTxs = numTxs;
    return this;
  }
  
  getNumNotRelayed() {
    return this.state.numNotRelayed;
  }
  
  setNumNotRelayed(numNotRelayed) {
    this.state.numNotRelayed = numNotRelayed;
    return this;
  }
  
  getNumFailing() {
    return this.state.numFailing;
  }
  
  setNumFailing(numFailing) {
    this.state.numFailing = numFailing;
    return this;
  }
  
  getNumDoubleSpends() {
    return this.state.numDoubleSpends;
  }
  
  setNumDoubleSpends(numDoubleSpends) {
    this.state.numDoubleSpends = numDoubleSpends;
    return this;
  }
  
  getNum10m() {
    return this.state.num10m;
  }
  
  setNum10m(num10m) {
    this.state.num10m = num10m;
    return this;
  }
  
  getFeeTotal() {
    return this.state.feeTotal;
  }
  
  setFeeTotal(feeTotal) {
    this.state.feeTotal = feeTotal;
    return this;
  }
  
  getBytesMax() {
    return this.state.bytesMax;
  }
  
  setBytesMax(bytesMax) {
    this.state.bytesMax = bytesMax;
    return this;
  }
  
  getBytesMed() {
    return this.state.bytesMed;
  }
  
  setBytesMed(bytesMed) {
    this.state.bytesMed = bytesMed;
    return this;
  }
  
  getBytesMin() {
    return this.state.bytesMin;
  }
  
  setBytesMin(bytesMin) {
    this.state.bytesMin = bytesMin;
    return this;
  }
  
  getBytesTotal() {
    return this.state.bytesTotal;
  }
  
  setBytesTotal(bytesTotal) {
    this.state.bytesTotal = bytesTotal;
    return this;
  }
  
  // TODO: histo... what?
  getHisto() {
    return this.state.histo;
  }
  
  setHisto(histo) {
    this.state.histo = histo;
    return this;
  }
  
  getHisto98pc() {
    return this.state.histo98pc;
  }
  
  setHisto98pc(histo98pc) {
    this.state.histo98pc = histo98pc;
    return this;
  }
  
  getOldestTimestamp() {
    return this.state.oldestTimestamp;
  }
  
  setOldestTimestamp(oldestTimestamp) {
    this.state.oldestTimestamp = oldestTimestamp;
    return this;
  }
}

var MoneroTxPoolStats_1 = MoneroTxPoolStats;

/**
 * Models a Monero version.
 */

class MoneroVersion {
  
  /**
   * Construct the model.
   * 
   * @param number is the version number
   * @param isRelease indicates if this version is a release
   */
  constructor(number, isRelease) {
    this.state = {};
    this.state.number = number;
    this.state.isRelease = isRelease;
  }

  getNumber() {
    return this.state.number;
  }

  setNumber(number) {
    this.state.number = number;
    return this;
  }

  isRelease() {
    return this.state.isRelease;
  }

  setIsRelease(isRelease) {
    this.state.isRelease = isRelease;
    return this;
  }
  
  copy() {
    return new MoneroKeyImage(this);
  }
  
  toJson() {
    return Object.assign({}, this.state);
  }
}

var MoneroVersion_1 = MoneroVersion;

const BigInteger$6 = biginteger.BigInteger;
const GenUtils$1 = GenUtils_1;
const assert$4 = require$$0;

/**
 * Monero subaddress model.
 */
class MoneroSubaddress$1 {
  
  constructor(stateOrAddress, accountIndex, index) {
    if (stateOrAddress === undefined || typeof stateOrAddress === "string") {
      this.state = {};
      this.setAddress(stateOrAddress);
      this.setAccountIndex(accountIndex);
      this.setIndex(index);
    } else {
      this.state = stateOrAddress;
      assert$4(accountIndex === undefined && index === undefined, "Can construct MoneroSubaddress with object or params but not both");
      if (this.state.balance !== undefined && !(this.state.balance instanceof BigInteger$6)) this.state.balance = BigInteger$6.parse(this.state.balance);
      if (this.state.unlockedBalance !== undefined && !(this.state.unlockedBalance instanceof BigInteger$6)) this.state.unlockedBalance = BigInteger$6.parse(this.state.unlockedBalance);
    }
  }
  
  toJson() {
    let json = Object.assign({}, this.state);
    if (json.balance) json.balance = json.balance.toString();
    if (json.unlockedBalance) json.unlockedBalance = json.unlockedBalance.toString();
    return json;
  }
  
  getAccountIndex() {
    return this.state.accountIndex;
  }

  setAccountIndex(accountIndex) {
    this.state.accountIndex = accountIndex;
    return this;
  }

  getIndex() {
    return this.state.index;
  }

  setIndex(index) {
    this.state.index = index;
    return this;
  }
  
  getAddress() {
    return this.state.address;
  }

  setAddress(address) {
    this.state.address = address;
    return this;
  }

  getLabel() {
    return this.state.label;
  }

  setLabel(label) {
    this.state.label = label;
    return this;
  }

  getBalance() {
    return this.state.balance;
  }

  setBalance(balance) {
    this.state.balance = balance;
    return this;
  }

  getUnlockedBalance() {
    return this.state.unlockedBalance;
  }

  setUnlockedBalance(unlockedBalance) {
    this.state.unlockedBalance = unlockedBalance;
    return this;
  }

  getNumUnspentOutputs() {
    return this.state.numUnspentOutputs;
  }

  setNumUnspentOutputs(numUnspentOutputs) {
    this.state.numUnspentOutputs = numUnspentOutputs;
    return this;
  }

  isUsed() {
    return this.state.isUsed;
  }

  setIsUsed(isUsed) {
    this.state.isUsed = isUsed;
    return this;
  }

  getNumBlocksToUnlock() {
    return this.state.numBlocksToUnlock;
  }

  setNumBlocksToUnlock(numBlocksToUnlock) {
    this.state.numBlocksToUnlock = numBlocksToUnlock;
    return this;
  }
  
  toString(indent) {
    let str = "";
    str += GenUtils$1.kvLine("Account index", this.getAccountIndex(), indent);
    str += GenUtils$1.kvLine("Subaddress index", this.getIndex(), indent);
    str += GenUtils$1.kvLine("Address", this.getAddress(), indent);
    str += GenUtils$1.kvLine("Label", this.getLabel(), indent);
    str += GenUtils$1.kvLine("Balance", this.getBalance(), indent);
    str += GenUtils$1.kvLine("Unlocked balance", this.getUnlockedBalance(), indent);
    str += GenUtils$1.kvLine("Num unspent outputs", this.getNumUnspentOutputs(), indent);
    str += GenUtils$1.kvLine("Is used", this.isUsed(), indent);
    str += GenUtils$1.kvLine("Num blocks to unlock", this.isUsed(), indent);
    return str.slice(0, str.length - 1);  // strip last newline
  }
}

var MoneroSubaddress_1 = MoneroSubaddress$1;

const assert$3 = require$$0;
const BigInteger$5 = biginteger.BigInteger;
const MoneroSubaddress = MoneroSubaddress_1;

/**
 * Monero account model.
 */
class MoneroAccount {
  
  constructor(stateOrIndex, primaryAddress, balance, unlockedBalance, subaddresses) {
    
    // construct from json
    if (typeof stateOrIndex === "object") {
      this.state = stateOrIndex;
      
      // deserialize balances
      if (this.state.balance !== undefined && !(this.state.balance instanceof BigInteger$5)) this.state.balance = BigInteger$5.parse(this.state.balance);
      if (this.state.unlockedBalance !== undefined && !(this.state.unlockedBalance instanceof BigInteger$5)) this.state.unlockedBalance = BigInteger$5.parse(this.state.unlockedBalance);
      
      // deserialize subaddresses
      if (this.state.subaddresses) {
        for (let i = 0; i < this.state.subaddresses.length; i++) {
          if (!(this.state.subaddresses[i] instanceof MoneroSubaddress)) {
            this.state.subaddresses[i] = new MoneroSubaddress(this.state.subaddresses[i]);
          }
        }
      }
    }
    
    // construct from individual params
    else {
      this.state = {};
      this.setIndex(stateOrIndex);
      this.setPrimaryAddress(primaryAddress);
      this.setBalance(balance);
      this.setUnlockedBalance(unlockedBalance);
      this.setSubaddresses(subaddresses);
    }
  }
  
  toJson() {
    let json = Object.assign({}, this.state);
    if (json.balance) json.balance = json.balance.toString();
    if (json.unlockedBalance) json.unlockedBalance = json.unlockedBalance.toString();
    if (json.subaddresses) {
      for (let i = 0; i < json.subaddresses.length; i++) {
        json.subaddresses[i] = json.subaddresses[i].toJson();
      }
    }
    return json;
  }
  
  getIndex() {
    return this.state.index;
  }
  
  setIndex(index) {
    this.state.index = index;
    return this;
  }
  
  getPrimaryAddress() {
    return this.state.primaryAddress;
  }

  setPrimaryAddress(primaryAddress) {
    this.state.primaryAddress = primaryAddress;
    return this;
  }
  
  getBalance() {
    return this.state.balance;
  }
  
  setBalance(balance) {
    this.state.balance = balance;
    return this;
  }
  
  getUnlockedBalance() {
    return this.state.unlockedBalance;
  }
  
  setUnlockedBalance(unlockedBalance) {
    this.state.unlockedBalance = unlockedBalance;
    return this;
  }
  
  getTag() {
    return this.state.tag;
  }
  
  setTag(tag) {
    this.state.tag = tag;
    return this;
  }
  
  getSubaddresses() {
    return this.state.subaddresses;
  }
  
  setSubaddresses(subaddresses) {
    assert$3(subaddresses === undefined || Array.isArray(subaddresses), "Given subaddresses must be undefined or an array of subaddresses");
    this.state.subaddresses = subaddresses;
    if (subaddresses) {
      for (let subaddress of subaddresses) {
        subaddress.setAccountIndex(this.state.index);
      }
    }
    return this;
  }
  
  toString(indent = 0) {
    let str = "";
    str += GenUtils.kvLine("Index", this.getIndex(), indent);
    str += GenUtils.kvLine("Primary address", this.getPrimaryAddress(), indent);
    str += GenUtils.kvLine("Balance", this.getBalance(), indent);
    str += GenUtils.kvLine("Unlocked balance", this.getUnlockedBalance(), indent);
    str += GenUtils.kvLine("Tag", this.getTag(), indent);
    if (this.getSubaddresses() != null) {
      sb += GenUtils.kvLine("Subaddresses", "", indent);
      for (let i = 0; i < this.getSubaddresses().size(); i++) {
        str += GenUtils.kvLine(i + 1, "", indent + 1);
        str += this.getSubaddresses()[i].toString(indent + 2) + "\n";
      }
    }
    return str.slice(0, str.length - 1);  // strip last newline
  }
}

var MoneroAccount_1 = MoneroAccount;

/**
 * Represents an account tag.
 */

class MoneroAccountTag$1 {
  
  constructor(tag, label, accountIndices) {
    this.tag = tag;
    this.label = label;
    this.accountIndices = accountIndices;
  }
  
  getTag() {
    return this.tag;
  }
  
  setTag(tag) {
    this.tag = tag;
    return this;
  }
  
  getLabel() {
    return this.label;
  }
  
  setLabel(label) {
    this.label = label;
    return this;
  }
  
  getAccountIndices() {
    return this.accountIndices;
  }
  
  setAccountIndices(accountIndices) {
    this.accoutIndices = accountIndices;
    return this;
  }
}

var MoneroAccountTag_1 = MoneroAccountTag$1;

/**
 * Monero address book entry model
 */

class MoneroAddressBookEntry {
  
  constructor(state) {
    this.state = Object.assign({}, state);
  }
  
  toJson() {
    return Object.assign({}, this.state);
  }
  
  getIndex() {
    return this.state.index;
  }
  
  setIndex(index) {
    this.state.index = index;
    return this;
  }
  
  getAddress() {
    return this.state.address;
  }
  
  setAddress(address) {
    this.state.address = address;
    return this;
  }
  
  getDescription() {
    return this.state.description;
  }
  
  setDescription(description) {
    this.state.description = description;
    return this;
  }
  
  getPaymentId() {
    return this.state.paymentId;
  }
  
  setPaymentId(paymentId) {
    this.state.paymentId = paymentId;
    return this;
  }
}

var MoneroAddressBookEntry_1 = MoneroAddressBookEntry;

/**
 * Base class for results from checking a transaction or reserve proof.
 * 
 * @class
 */

class MoneroCheck$2 {
  
  constructor(state) {
    this.state = Object.assign({}, state);
  }

  isGood() {
    return this.state.isGood;
  }

  setIsGood(isGood) {
    this.state.isGood = isGood;
    return this;
  }
}

var MoneroCheck_1 = MoneroCheck$2;

const BigInteger$4 = biginteger.BigInteger;
const MoneroCheck$1 = MoneroCheck_1;

/**
 * Results from checking a reserve proof.
 * 
 * @extends {MoneroCheck}
 */
class MoneroCheckReserve extends MoneroCheck$1 {
  
  constructor(state) {
    super(state);
    if (this.state.totalAmount !== undefined && !(this.state.totalAmount instanceof BigInteger$4)) this.state.totalAmount = BigInteger$4.parse(this.state.totalAmount);
    if (this.state.unconfirmedSpentAmount !== undefined && !(this.state.unconfirmedSpentAmount instanceof BigInteger$4)) this.state.unconfirmedSpentAmount = BigInteger$4.parse(this.state.unconfirmedSpentAmount);
  }
  
  toJson() {
    let json = Object.assign({}, this.state);
    if (this.getTotalAmount()) json.totalAmount = this.getTotalAmount().toString();
    if (this.getUnconfirmedSpentAmount()) json.unconfirmedSpentAmount = this.getUnconfirmedSpentAmount().toString();
    return json;
  }
  
  getTotalAmount() {
    return this.state.totalAmount;
  }

  setTotalAmount(totalAmount) {
    this.state.totalAmount = totalAmount;
    return this;
  }
  
  getUnconfirmedSpentAmount() {
    return this.state.unconfirmedSpentAmount;
  }

  setUnconfirmedSpentAmount(unconfirmedSpentAmount) {
    this.state.unconfirmedSpentAmount = unconfirmedSpentAmount;
    return this;
  }
}

var MoneroCheckReserve_1 = MoneroCheckReserve;

const MoneroCheck = MoneroCheck_1;
const BigInteger$3 = biginteger.BigInteger;

/**
 * Results from checking a transaction key.
 * 
 * @extends {MoneroCheck}
 */
class MoneroCheckTx extends MoneroCheck {
  
  constructor(state) {
    super(state);
    if (this.state.receivedAmount !== undefined && !(this.state.receivedAmount instanceof BigInteger$3)) this.state.receivedAmount = BigInteger$3.parse(this.state.receivedAmount);
  }
  
  toJson() {
    let json = Object.assign({}, this.state);
    if (this.getReceivedAmount()) json.receivedAmount = this.getReceivedAmount().toString();
    return json;
  }

  inTxPool() {
    return this.state.inTxPool;
  }
  
  setInTxPool(inTxPool) {
    this.state.inTxPool = inTxPool;
    return this;
  }
  
  getNumConfirmations() {
    return this.state.numConfirmations;
  }
  
  setNumConfirmations(numConfirmations) {
    this.state.numConfirmations = numConfirmations;
    return this;
  }
  
  getReceivedAmount() {
    return this.state.receivedAmount;
  }
  
  setReceivedAmount(receivedAmount) {
    this.state.receivedAmount = receivedAmount;
    return this;
  }
}

var MoneroCheckTx_1 = MoneroCheckTx;

const BigInteger$2 = biginteger.BigInteger;

/**
 * Models results from importing key images.
 */
class MoneroKeyImageImportResult {
  
  constructor(state) {
    state = Object.assign({}, state);
    if (state.spentAmount !== undefined && !(state.spentAmount instanceof BigInteger$2)) state.spentAmount = BigInteger$2.parse(state.spentAmount);
    if (state.unspentAmount !== undefined && !(state.unspentAmount instanceof BigInteger$2)) state.unspentAmount = BigInteger$2.parse(state.unspentAmount);
    this.state = state;
  }
  
  toJson() {
    let json = Object.assign({}, this.state);
    if (this.getSpentAmount()) json.spentAmount = this.getSpentAmount().toString();
    if (this.getUnspentAmount()) json.unspentAmount = this.getUnspentAmount().toString();
    return json;
  }
  
  getHeight() {
    return this.state.height;
  }
  
  setHeight(height) {
    this.state.height = height;
    return this;
  }
  
  getSpentAmount() {
    return this.state.spentAmount;
  }
  
  setSpentAmount(spentAmount) {
    this.state.spentAmount = spentAmount;
    return this;
  }
  
  getUnspentAmount() {
    return this.state.unspentAmount;
  }
  
  setUnspentAmount(unspentAmount) {
    this.state.unspentAmount = unspentAmount;
    return this;
  }
}

var MoneroKeyImageImportResult_1 = MoneroKeyImageImportResult;

/**
 * Models information about a multisig wallet.
 */

class MoneroMultisigInfo {
  
  constructor(state) {
    this.state = Object.assign({}, state);
  }
  
  toJson() {
    return Object.assign({}, this.state);
  }
  
  isMultisig() {
    return this.state.isMultisig;
  }
  
  setIsMultisig(isMultisig) {
    this.state.isMultisig = isMultisig;
    return this;
  }
  
  isReady() {
    return this.state.isReady;
  }
  
  setIsReady(isReady) {
    this.state.isReady = isReady;
  }
  
  getThreshold() {
    return this.state.threshold;
  }
  
  setThreshold(threshold) {
    this.state.threshold = threshold;
  }
  
  getNumParticipants() {
    return this.state.numParticipants;
  }
  
  setNumParticipants(numParticipants) {
    this.state.numParticipants = numParticipants;
  }
}

var MoneroMultisigInfo_1 = MoneroMultisigInfo;

/**
 * Models the result of initializing a multisig wallet which results in the
 * multisig wallet's address xor another multisig hex to share with
 * participants to create the wallet.
 */

class MoneroMultisigInitResult {

  constructor(state) {
    this.state = Object.assign({}, state);
  }
  
  toJson() {
    return Object.assign({}, this.state);
  }
  
  getAddress() {
    return this.state.address;
  }
  
  setAddress(address) {
    this.state.address = address;
    return this;
  }
  
  getMultisigHex() {
    return this.state.multisigHex;
  }
  
  setMultisigHex(multisigHex) {
    this.state.multisigHex = multisigHex;
    return this;
  }
}

var MoneroMultisigInitResult_1 = MoneroMultisigInitResult;

/**
 * Models the result of signing multisig tx hex.
 */

class MoneroMultisigSignResult {
  
  constructor(state) {
    this.state = Object.assign({}, state);
  }
  
  toJson() {
    return Object.assign({}, this.state);
  }
  
  getSignedMultisigTxHex() {
    return this.state.signedMultisigTxHex;
  }

  setSignedMultisigTxHex(signedTxMultisigHex) {
    this.state.signedMultisigTxHex = signedTxMultisigHex;
  }

  getTxHashes() {
    return this.state.txHashes;
  }

  setTxHashes(txHashes) {
    this.state.txHashes = txHashes;
  }
}

var MoneroMultisigSignResult_1 = MoneroMultisigSignResult;

/**
 * Enumerates send priorities.
 * 
 * @hideconstructor
 */

class MoneroTxPriority {}

/**
 * Default priority (i.e. normal) (value=0).
 */
MoneroTxPriority.DEFAULT = 0;

/**
 * Unimportant priority (value=1).
 */
MoneroTxPriority.UNIMPORTANT = 1;

/**
 * Normal priority (value=2).
 */
MoneroTxPriority.NORMAL = 2;

/**
 * Elevated priority (value=3).
 */
MoneroTxPriority.ELEVATED = 3;

var MoneroTxPriority_1 = MoneroTxPriority;

const assert$2 = require$$0;
const BigInteger$1 = biginteger.BigInteger;
const MoneroDestination = MoneroDestination_1;
const MoneroError$3 = MoneroError_1;

/**
 * Configures a transaction to send, sweep, or create a payment URI.
 */
class MoneroTxConfig$1 {
  
  /**
   * <p>Generic request to transfer funds from a wallet.</p>
   * 
   * <p>Examples:</p>
   * 
   * <code>
   * let config1 = new MoneroTxConfig({<br>
   * &nbsp;&nbsp; accountIndex: 0,<br>
   * &nbsp;&nbsp; address: "59aZULsUF3YN...",<br>
   * &nbsp;&nbsp; amount: new BigInteger("500000"),<br>
   * &nbsp;&nbsp; priority: MoneroTxPriority.NORMAL,<br>
   * &nbsp;&nbsp; relay: true<br>
   * });<br><br>
   * </code>
   * 
   * @param {MoneroTxConfig|object} config - configures the transaction to create (optional)
   * @param {string} config.address - single destination address
   * @param {BigInteger} config.amount - single destination amount
   * @param {int} config.accountIndex - source account index to transfer funds from
   * @param {int} config.subaddressIndex - source subaddress index to transfer funds from
   * @param {int[]} config.subaddressIndices - source subaddress indices to transfer funds from
   * @param {boolean} config.relay - relay the transaction to peers to commit to the blockchain
   * @param {MoneroTxPriority} config.priority - transaction priority (default MoneroTxPriority.NORMAL)
   * @param {MoneroDestination[]} config.destinations - addresses and amounts in a multi-destination tx
   * @param {string} config.paymentId - transaction payment ID
   * @param {int} config.unlockHeight - minimum height for the transaction to unlock (default 0)
   * @param {string} config.note - transaction note saved locally with the wallet
   * @param {string} config.recipientName - recipient name saved locally with the wallet
   * @param {boolean} config.canSplit - allow funds to be transferred using multiple transactions
   * @param {BigInteger} config.belowAmount - for sweep requests, include outputs below this amount when sweeping wallet, account, subaddress, or all unlocked funds 
   * @param {boolean} config.sweepEachSubaddress - for sweep requests, sweep each subaddress individually instead of together if true
   * @param {string} config.keyImage - key image to sweep (ignored except in sweepOutput() requests)
   */
  constructor(config, relaxValidation) {  // relax validation for internal use to process json from rpc or cpp
    if (arguments.length > 2) throw new MoneroError$3("MoneroTxConfig can be constructed with only two parameters but was given " + arguments.length)
    
    // initialize internal state
    if (!config) this.state = {};
    else if (config instanceof MoneroTxConfig$1) this.state = config.toJson();
    else if (typeof config === "object") {
      this.state = Object.assign({}, config);
      if (relaxValidation && typeof this.state.amount === "number") this.state.amount = BigInteger$1.parse(this.state.amount);
    }
    else throw new MoneroError$3("Invalid argument given to MoneroTxConfig: " + typeof config);
    
    // deserialize if necessary
    if (this.state.destinations) {
      assert$2(this.state.address === undefined && this.state.amount === undefined, "Tx configuration may specify destinations or an address/amount but not both");
      this.setDestinations(this.state.destinations.map(destination => destination instanceof MoneroDestination ? destination : new MoneroDestination(destination)));
    }
    
    // alias 'address' and 'amount' to single destination to support e.g. createTx({address: "..."})
    if (this.state.address || this.state.amount) {
      assert$2(!this.state.destinations, "Tx configuration may specify destinations or an address/amount but not both");
      this.setAddress(this.state.address);
      this.setAmount(this.state.amount);
      delete this.state.address;
      delete this.state.amount;
    }
    
    // alias 'subaddressIndex' to subaddress indices
    if (this.state.subaddressIndex !== undefined) {
      this.setSubaddressIndices([this.state.subaddressIndex]);
      delete this.state.subaddressIndex;
    }
  }
  
  copy() {
    return new MoneroTxConfig$1(this);
  }
  
  toJson() {
    let json = Object.assign({}, this.state); // copy state
    if (this.getDestinations()) {
      json.destinations = [];
      for (let destination of this.getDestinations()) json.destinations.push(destination.toJson());
    }
    if (this.getFee()) json.fee = this.getFee().toString();
    if (this.getBelowAmount()) json.belowAmount = this.getBelowAmount().toString();
    return json;
  }
  
  /**
   * Set the address of a single-destination configuration.
   * 
   * @param {string} address - the address to set for the single destination
   * @return {MoneroTxConfig} this configuration for chaining
   */
  setAddress(address) {
    if (this.state.destinations !== undefined && this.state.destinations.length > 1) throw new MoneroError$3("Cannot set address because MoneroTxConfig already has multiple destinations");
    if (this.state.destinations === undefined || this.state.destinations.length === 0) this.addDestination(new MoneroDestination(address));
    else this.state.destinations[0].setAddress(address);
    return this;
  }
  
  /**
   * Get the address of a single-destination configuration.
   * 
   * @return {string} the address of the single destination
   */
  getAddress() {
    if (this.state.destinations === undefined || this.state.destinations.length !== 1) throw new MoneroError$3("Cannot get address because MoneroTxConfig does not have exactly one destination");
    return this.state.destinations[0].getAddress();
  }
  
  /**
   * Set the amount of a single-destination configuration.
   * 
   * @param {BigInteger|string} amount - the amount to set for the single destination
   * @return {MoneroTxConfig} this configuration for chaining
   */
  setAmount(amount) {
    if (amount !== undefined && !(this.state.amount instanceof BigInteger$1)) {
      if (typeof amount === "number") throw new MoneroError$3("Destination amount must be BigInteger or string");
      try { amount = BigInteger$1.parse(amount); }
      catch (err) { throw new MoneroError$3("Invalid destination amount: " + amount); }
    }
    if (this.state.destinations !== undefined && this.state.destinations.length > 1) throw new MoneroError$3("Cannot set amount because MoneroTxConfig already has multiple destinations");
    if (this.state.destinations === undefined || this.state.destinations.length === 0) this.addDestination(new MoneroDestination(undefined, amount));
    else this.state.destinations[0].setAmount(amount);
    return this;
  }
  
  /**
   * Get the amount of a single-destination configuration.
   * 
   * @return {BigInteger} the amount of the single destination
   */
  getAmount() {
    if (this.state.destinations === undefined || this.state.destinations.length !== 1) throw new MoneroError$3("Cannot get amount because MoneroTxConfig does not have exactly one destination");
    return this.state.destinations[0].getAmount();
  }
  
  addDestination(destinationOrAddress, amount) {
    if (typeof destinationOrAddress === "string") return this.addDestination(new MoneroDestination(destinationOrAddress, amount));
    assert$2(destinationOrAddress instanceof MoneroDestination);
    if (this.state.destinations === undefined) this.state.destinations = [];
    this.state.destinations.push(destinationOrAddress);
    return this;
  }
  
  getDestinations() {
    return this.state.destinations;
  }
  
  setDestinations(destinations) {
    if (arguments.length > 1) destinations = Array.from(arguments);
    this.state.destinations = destinations;
    return this;
  }
  
  setDestination(destination) {
    return this.setDestinations(destination ? [destination] : destination);
  }
  
  getPaymentId() {
    return this.state.paymentId;
  }
  
  setPaymentId(paymentId) {
    this.state.paymentId = paymentId;
    return this;
  }
  
  getPriority() {
    return this.state.priority;
  }
  
  setPriority(priority) {
    this.state.priority = priority;
    return this;
  }
  
  getFee() {
    return this.state.fee;
  }
  
  setFee(fee) {
    this.state.fee = fee;
    return this;
  }
  
  getAccountIndex() {
    return this.state.accountIndex;
  }
  
  setAccountIndex(accountIndex) {
    this.state.accountIndex = accountIndex;
    return this;
  }
  
  setSubaddressIndex(subaddressIndex) {
    this.setSubaddressIndices([subaddressIndex]);
    return this;
  }
  
  getSubaddressIndices() {
    return this.state.subaddressIndices;
  }
  
  setSubaddressIndices(subaddressIndices) {
    if (arguments.length > 1) subaddressIndices = Array.from(arguments);
    this.state.subaddressIndices = subaddressIndices;
    return this;
  }
  
  getUnlockHeight() {
    return this.state.unlockHeight;
  }
  
  setUnlockHeight(unlockHeight) {
    this.state.unlockHeight = unlockHeight;
    return this;
  }
  
  getRelay() {
    return this.state.relay;
  }
  
  setRelay(relay) {
    this.state.relay = relay;
    return this;
  }
  
  getCanSplit() {
    return this.state.canSplit;
  }
  
  setCanSplit(canSplit) {
    this.state.canSplit = canSplit;
    return this;
  }
  
  getNote() {
    return this.state.note;
  }
  
  setNote(note) {
    this.state.note = note;
    return this;
  }
  
  getRecipientName() {
    return this.state.recipientName;
  }
  
  setRecipientName(recipientName) {
    this.state.recipientName = recipientName;
    return this;
  }
  
  // --------------------------- SPECIFIC TO SWEEP ----------------------------
  
  getBelowAmount() {
    return this.state.belowAmount;
  }
  
  setBelowAmount(belowAmount) {
    this.state.belowAmount = belowAmount;
    return this;
  }
  
  getSweepEachSubaddress() {
    return this.state.sweepEachSubaddress;
  }
  
  setSweepEachSubaddress(sweepEachSubaddress) {
    this.state.sweepEachSubaddress = sweepEachSubaddress;
    return this;
  }
  
  /**
   * Get the key image hex of the output to sweep.
   * 
   * return {string} is the key image hex of the output to sweep
   */
  getKeyImage() {
    return this.state.keyImage;
  }
  
  /**
   * Set the key image hex of the output to sweep.
   * 
   * @param {string} keyImage is the key image hex of the output to sweep
   */
  setKeyImage(keyImage) {
    this.state.keyImage = keyImage;
    return this;
  }
}

var MoneroTxConfig_1 = MoneroTxConfig$1;

/**
 * Result from syncing a Monero wallet.
 */

class MoneroSyncResult {
  
  constructor(numBlocksFetched, receivedMoney) {
    this.setNumBlocksFetched(numBlocksFetched);
    this.setReceivedMoney(receivedMoney);
  }
  
  getNumBlocksFetched() {
    return this.numBlocksFetched;
  }
  
  setNumBlocksFetched(numBlocksFetched) {
    this.numBlocksFetched = numBlocksFetched;
    return this;
  }
  
  getReceivedMoney() {
    return this.receivedMoney;
  }
  
  setReceivedMoney(receivedMoney) {
    this.receivedMoney = receivedMoney;
    return this;
  }
}

var MoneroSyncResult_1 = MoneroSyncResult;

/**
 * Default wallet listener which takes no action on notifications.
 */

class MoneroWalletListener {
  
  /**
   * Invoked as the wallet is synchronized.
   * 
   * @param {number} height - height of the synced block 
   * @param {number} startHeight - starting height of the sync request
   * @param {number} endHeight - ending height of the sync request
   * @param {number} percentDone - sync progress as a percentage
   * @param {string} message - human-readable description of the current progress
   */
  async onSyncProgress(height, startHeight, endHeight, percentDone, message) { }

  /**
   * Invoked when a new block is added to the chain.
   * 
   * @param {int} height - the height of the new block (i.e. the number of blocks before it).
   */
  async onNewBlock(height) { }
  
  /**
   * Invoked when the wallet's balances change.
   * 
   * @param {BigInteger} newBalance - new wallet balance
   * @param {BigInteger} newUnlockedBalance - new unlocked wallet balance
   */
  async onBalancesChanged(newBalance, newUnlockedBalance) { }

  /**
   * Invoked 3 times per received output: once when unconfirmed, once when confirmed, and
   * once when unlocked.
   * 
   * The notified output includes basic fields only, so the output or its transaction should be fetched to get all available fields.
   * 
   * @param {MoneroOutputWallet} output - the received output
   */
  async onOutputReceived(output) { }
  
  /**
   * Invoked twice per spent output: once when confirmed and once when unlocked.
   * 
   * The notified output includes basic fields only, so the output or its transaction should be fetched to get all available fields.
   * 
   * @param {MoneroOutputWallet} output - the spent output
   */
  async onOutputSpent(output) { }
}

var MoneroWalletListener_1 = MoneroWalletListener;

var MoneroWalletConfig_1;
var hasRequiredMoneroWalletConfig;

function requireMoneroWalletConfig () {
	if (hasRequiredMoneroWalletConfig) return MoneroWalletConfig_1;
	hasRequiredMoneroWalletConfig = 1;
	const GenUtils = GenUtils_1;
	const MoneroError = MoneroError_1;
	const MoneroNetworkType = MoneroNetworkType_1;
	const MoneroRpcConnection = requireMoneroRpcConnection();

	/**
	 * Configuration to create a Monero wallet.
	 */
	class MoneroWalletConfig {
	  
	  /**
	   * Construct a configuration to open or create a wallet.
	   * 
	   * @param {object|MoneroWalletConfig} config - MoneroWalletConfig or equivalent config object
	   * @param {string} config.path - path of the wallet to open or create
	   * @param {string} config.password - password of the wallet to open
	   * @param {string|number} config.networkType - network type of the wallet to open (one of "mainnet", "testnet", "stagenet" or MoneroNetworkType.MAINNET|TESTNET|STAGENET)
	   * @param {string} config.serverUri - uri of the wallet's server (optional)
	   * @param {string} config.serverUsername - username of the wallet's server (optional)
	   * @param {string} config.serverPassword - password of the wallet's server (optional)
	   * @param {boolean} config.rejectUnauthorized - reject self-signed server certificates if true (default true)
	   * @param {MoneroRpcConnection|object} config.server - MoneroRpcConnection or equivalent JS object configuring the server connection (optional)
	   * @param {Uint8Array} config.keysData - wallet keys data to open (optional)
	   * @param {Uint8Array} config.cacheData - wallet cache data to open (optional)
	   * @param {boolean} config.proxyToWorker - proxies wallet operations to a worker in order to not block the main thread (default true)
	   * @param {fs} config.fs - Node.js compatible file system to use (defaults to disk or in-memory FS if browser)
	   * @param {boolean} config.saveCurrent - specifies if the current RPC wallet should be saved before being closed
	   * @param {number} config.accountLookahead - number of accounts to scan (optional)
	   * @param {number} config.subaddressLookahead - number of subaddresses to scan per account (optional)
	   */
	  constructor(config) {
	    
	    // initialize internal config
	    if (!config) config = {};
	    else if (config instanceof MoneroWalletConfig) config = config.toJson();
	    else if (typeof config === "object") config = Object.assign({}, config);
	    else throw new MoneroError("config must be a MoneroWalletConfig or JavaScript object");
	    this.config = config;
	    
	    // normalize config
	    this.setNetworkType(config.networkType);
	    if (config.server) this.setServer(config.server);
	    delete this.config.server;
	    
	    // check for unsupported fields
	    for (let key of Object.keys(this.config)) {
	      if (!GenUtils.arrayContains(MoneroWalletConfig.SUPPORTED_FIELDS, key)) {
	        throw new MoneroError("Wallet config includes unsupported field: '" + key + "'");
	      }
	    }
	  }
	  
	  toJson() {
	    let json = Object.assign({}, this.config);
	    json.fs = undefined; // remove filesystem
	    return json;
	  }
	  
	  getPath() {
	    return this.config.path;
	  }
	  
	  setPath(path) {
	    this.config.path = path;
	    return this;
	  }
	  
	  getPassword() {
	    return this.config.password;
	  }
	  
	  setPassword(password) {
	    this.config.password = password;
	    return this;
	  }
	  
	  getNetworkType() {
	    return this.config.networkType;
	  }
	  
	  setNetworkType(networkTypeOrStr) {
	    this.config.networkType = typeof networkTypeOrStr === "string" ? MoneroNetworkType.parse(networkTypeOrStr) : networkTypeOrStr;
	    return this;
	  }
	  
	  getServer() {
	    return !this.config.serverUri ? undefined : new MoneroRpcConnection({uri: this.config.serverUri, username: this.config.serverUsername, password: this.config.serverPassword, rejectUnauthorized: this.config.rejectUnauthorized})
	  }
	  
	  setServer(server) {
	    if (server && !(server instanceof MoneroRpcConnection)) server = new MoneroRpcConnection(server);
	    this.config.serverUri = server === undefined ? undefined : server.getUri();
	    this.config.serverUsername = server === undefined ? undefined : server.getUsername();
	    this.config.serverPassword = server === undefined ? undefined : server.getPassword();
	    this.config.rejectUnauthorized = server === undefined ? undefined : server.getRejectUnauthorized();
	    return this;
	  }
	  
	  getServerUri() {
	    return this.config.serverUri;
	  }
	  
	  setServerUri(serverUri) {
	    this.config.serverUri = serverUri;
	    return this;
	  }
	  
	  getServerUsername() {
	    return this.config.serverUsername;
	  }
	  
	  setServerUsername(serverUsername) {
	    this.config.serverUsername = serverUsername;
	    return this;
	  }
	  
	  getServerPassword() {
	    return this.config.serverPassword;
	  }
	  
	  setServerPassword(serverPassword) {
	    this.config.serverPassword = serverPassword;
	    return this;
	  }
	  
	  getRejectUnauthorized() {
	    return this.config.rejectUnauthorized;
	  }
	  
	  setRejectUnauthorized(rejectUnauthorized) {
	    this.config.rejectUnauthorized = rejectUnauthorized;
	    return this;
	  }
	  
	  getMnemonic() {
	    return this.config.mnemonic;
	  }
	  
	  setMnemonic(mnemonic) {
	    this.config.mnemonic = mnemonic;
	    return this;
	  }
	  
	  getSeedOffset() {
	    return this.config.seedOffset;
	  }
	  
	  setSeedOffset(seedOffset) {
	    this.config.seedOffset = seedOffset;
	    return this;
	  }
	  
	  getPrimaryAddress() {
	    return this.config.primaryAddress;
	  }
	  
	  setPrimaryAddress(primaryAddress) {
	    this.config.primaryAddress = primaryAddress;
	    return this;
	  }
	  
	  getPrivateViewKey() {
	    return this.config.privateViewKey;
	  }
	  
	  setPrivateViewKey(privateViewKey) {
	    this.config.privateViewKey = privateViewKey;
	    return this;
	  }
	  
	  getPrivateSpendKey() {
	    return this.config.privateSpendKey;
	  }
	  
	  setPrivateSpendKey(privateSpendKey) {
	    this.config.privateSpendKey = privateSpendKey;
	    return this;
	  }
	  
	  getRestoreHeight() {
	    return this.config.restoreHeight;
	  }
	  
	  setRestoreHeight(restoreHeight) {
	    this.config.restoreHeight = restoreHeight;
	    return this;
	  }
	  
	  getLanguage() {
	    return this.config.language;
	  }
	  
	  setLanguage(language) {
	    this.config.language = language;
	    return this;
	  }
	  
	  getSaveCurrent() {
	    return this.config.saveCurrent;
	  }
	  
	  setSaveCurrent(saveCurrent) {
	    this.config.saveCurrent = saveCurrent;
	    return this;
	  }
	  
	  getProxyToWorker() {
	    return this.config.proxyToWorker;
	  }
	  
	  setProxyToWorker(proxyToWorker) {
	    this.config.proxyToWorker = proxyToWorker;
	    return this;
	  }
	  
	  getFs() {
	    return this.config.fs;
	  }
	  
	  setFs(fs) {
	    this.config.fs = fs;
	    return this;
	  }
	  
	  getKeysData() {
	    return this.config.keysData;
	  }
	  
	  setKeysData(keysData) {
	    this.config.keysData = keysData;
	    return this;
	  }
	  
	  getCacheData() {
	    return this.config.cacheData;
	  }
	  
	  setCacheData(cacheData) {
	    this.config.cacheData = cacheData;
	    return this;
	  }
	  
	  getAccountLookahead() {
	    return this.state.accountLookahead;
	  }
	  
	  setAccountLookahead(accountLookahead) {
	    this.state.accountLookahead = accountLookahead;
	    return this;
	  }
	  
	  getSubaddressLookahead() {
	    return this.state.subaddressLookahead;
	  }
	  
	  setSubaddressLookahead(subaddressLookahead) {
	    this.state.subaddressLookahead = subaddressLookahead;
	    return this;
	  }
	}

	MoneroWalletConfig.SUPPORTED_FIELDS = ["path", "password", "networkType", "serverUri", "serverUsername", "serverPassword", "rejectUnauthorized", "mnemonic", "seedOffset", "primaryAddress", "privateViewKey", "privateSpendKey", "restoreHeight", "language", "saveCurrent", "proxyToWorker", "fs", "keysData", "cacheData", "accountLookahead", "subaddressLookahead"];

	MoneroWalletConfig_1 = MoneroWalletConfig;
	return MoneroWalletConfig_1;
}

/**
 * Enumerate message signature types.
 * 
 * @hideconstructor
 */

class MoneroMessageSignatureType {}

/**
 * Sign with spend key (value=0).
 */
MoneroMessageSignatureType.SIGN_WITH_SPEND_KEY = 0;

/**
 * Sign with the view key (value=1).
 */
MoneroMessageSignatureType.SIGN_WITH_VIEW_KEY = 1;

var MoneroMessageSignatureType_1 = MoneroMessageSignatureType;

/**
 * Message signature verification result.
 * 
 * @class
 */

class MoneroMessageSignatureResult {
  
  constructor(stateOrIsGood, isOld, signatureType, version) {
    if (typeof stateOrIsGood === "boolean") {
      this.state = {};
      this.state.isGood = stateOrIsGood;
      this.state.isOld = isOld;
      this.state.signatureType = signatureType;
      this.state.version = version;
    } else {
      this.state = stateOrIsGood;
    }
  }
  
  toJson() {
    return Object.assign({}, this.state);
  }

  isGood() {
    return this.state.isGood;
  }

  setIsGood(isGood) {
    this.state.isGood = isGood;
    return this;
  }
  
  isOld() {
    return this.state.isOld;
  }

  setIsOld(isOld) {
    this.state.isOld = isOld;
    return this;
  }
  
  getSignatureType() {
    return this.state.signatureType;
  }

  setSignatureType(signatureType) {
    this.state.signatureType = signatureType;
    return this;
  }
  
  getVersion() {
    return this.state.version;
  }

  setVersion(version) {
    this.state.version = version;
    return this;
  }
}

var MoneroMessageSignatureResult_1 = MoneroMessageSignatureResult;

var MoneroConnectionManager_1;
var hasRequiredMoneroConnectionManager;

function requireMoneroConnectionManager () {
	if (hasRequiredMoneroConnectionManager) return MoneroConnectionManager_1;
	hasRequiredMoneroConnectionManager = 1;
	const GenUtils = GenUtils_1;
	const MoneroError = MoneroError_1;
	const MoneroRpcConnection = requireMoneroRpcConnection();
	const TaskLooper = TaskLooper_1;
	const ThreadPool = ThreadPool_1;

	/**
	 * <p>Manages a collection of prioritized connections to daemon or wallet RPC endpoints.</p>
	 *
	 * <p>Example usage:</p>
	 * 
	 * <code>
	 * // imports<br>
	 * const monerojs = require("monero-javascript");<br>
	 * const MoneroRpcConnection = monerojs.MoneroRpcConnection;<br>
	 * const MoneroConnectionManager = monerojs.MoneroConnectionManager;<br>
	 * const MoneroConnectionManagerListener = monerojs.MoneroConnectionManagerListener;<br><br>
	 * 
	 * // create connection manager<br>
	 * let connectionManager = new MoneroConnectionManager();<br><br>
	 * 
	 * // add managed connections with priorities<br>
	 * connectionManager.addConnection(new MoneroRpcConnection("http://localhost:38081").setPriority(1)); // use localhost as first priority<br>
	 * connectionManager.addConnection(new MoneroRpcConnection("http://example.com")); // default priority is prioritized last<br><br>
	 * 
	 * // set current connection<br>
	 * connectionManager.setConnection(new MoneroRpcConnection("http://foo.bar", "admin", "password")); // connection is added if new<br><br>
	 * 
	 * // check connection status<br>
	 * await connectionManager.checkConnection();<br>
	 * console.log("Connection manager is connected: " + connectionManager.isConnected());<br>
	 * console.log("Connection is online: " + connectionManager.getConnection().isOnline());<br>
	 * console.log("Connection is authenticated: " + connectionManager.getConnection().isAuthenticated());<br><br>
	 * 
	 * // receive notifications of any changes to current connection<br>
	 * connectionManager.addListener(new class extends MoneroConnectionManagerListener {<br>
	 * &nbsp;&nbsp; onConnectionChanged(connection) {<br>
	 * &nbsp;&nbsp;&nbsp;&nbsp; console.log("Connection changed to: " + connection);<br>
	 * &nbsp;&nbsp; }<br>
	 * });<br><br>
	 *  
	 * // check connection status every 10 seconds<br>
	 * await connectionManager.startCheckingConnection(10000);<br><br>
	 * 
	 * // automatically switch to best available connection if disconnected<br>
	 * connectionManager.setAutoSwitch(true);<br><br>
	 * 
	 * // get best available connection in order of priority then response time<br>
	 * let bestConnection = await connectionManager.getBestAvailableConnection();<br><br>
	 * 
	 * // check status of all connections<br>
	 * await connectionManager.checkConnections();<br><br>
	 * 
	 * // get connections in order of current connection, online status from last check, priority, and name<br>
	 * let connections = connectionManager.getConnections();<br><br>
	 * 
	 * // clear connection manager<br>
	 * connectionManager.clear();
	 * <code>
	 */
	class MoneroConnectionManager {
	  
	  /**
	   * Construct a connection manager.
	   * 
	   * @param {boolean} proxyToWorker - configure all connections to proxy to worker (default true)
	   */
	  constructor(proxyToWorker) {
	    this._proxyToWorker = proxyToWorker !== false;
	    this._timeoutInMs = MoneroConnectionManager.DEFAULT_TIMEOUT;
	    this._connections = [];
	    this._listeners = [];
	  }
	  
	  /**
	   * Add a listener to receive notifications when the connection changes.
	   * 
	   * @param {MoneroConnectionManagerListener} listener - the listener to add
	   * @return {MoneroConnectionManager} this connection manager for chaining
	   */
	  addListener(listener) {
	    this._listeners.push(listener);
	    return this;
	  }
	  
	  /**
	   * Remove a listener.
	   * 
	   * @param {MoneroConnectionManagerListener} listener - the listener to remove
	   * @return {MoneroConnectionManager} this connection manager for chaining
	   */
	  removeListener(listener) {
	    if (!GenUtils.remove(this._listeners, listener)) throw new MoneroError("Monero connection manager does not contain listener to remove");
	    return this;
	  }
	  
	  /**
	   * Remove all listeners.
	   * 
	   * @return {MoneroConnectionManager} this connection manager for chaining
	   */
	  removeListeners() {
	    this._listeners.splice(0, this._listeners.length);
	    return this;
	  }
	  
	  /**
	   * Add a connection. The connection may have an elevated priority for this manager to use.
	   * 
	   * @param {MoneroRpcConnection} connection - the connection to add
	   * @return {Promise<MoneroConnectionManager>} this connection manager for chaining
	   */
	  async addConnection(connection) {
	    for (let aConnection of this._connections) {
	      if (aConnection.getUri() === connection.getUri()) throw new MoneroError("Connection URI already exists");
	    }
	    if (this._proxyToWorker !== undefined) connection.setProxyToWorker(this._proxyToWorker);
	    this._connections.push(connection);
	    return this;
	  }
	  
	  /**
	   * Remove a connection.
	   * 
	   * @param {string} uri - of the the connection to remove
	   * @return {Promise<MoneroConnectionManager>} this connection manager for chaining
	   */
	  async removeConnection(uri) {
	    let connection = this.getConnectionByUri(uri);
	    if (!connection) throw new MoneroError("No connection exists with URI: " + uri);
	    GenUtils.remove(connections, connection);
	    if (connection === this._currentConnection) {
	      this._currentConnection = undefined;
	      this._onConnectionChanged(this._currentConnection);
	    }
	    return this;
	  }
	  
	  /**
	   * Indicates if the connection manager is connected to a node.
	   * 
	   * @return {boolean} true if the current connection is set, online, and not unauthenticated. false otherwise
	   */
	  isConnected() {
	    return this._currentConnection && this._currentConnection.isConnected();
	  }
	  
	  /**
	   * Get the current connection.
	   * 
	   * @return {MoneroRpcConnection} the current connection or undefined if no connection set
	   */
	  getConnection() {
	    return this._currentConnection;
	  }
	  
	  /**
	   * Get a connection by URI.
	   * 
	   * @param {string} uri is the URI of the connection to get
	   * @return {MoneroRpcConnection} the connection with the URI or undefined if no connection with the URI exists
	   */
	  getConnectionByUri(uri) {
	    for (let connection of this._connections) if (connection.getUri() === uri) return connection;
	    return undefined;
	  }
	  
	  /**
	   * Get all connections in order of current connection (if applicable), online status, priority, and name.
	   * 
	   * @return {MoneroRpcConnection[]} the list of sorted connections
	   */
	  getConnections() {
	    let sortedConnections = GenUtils.copyArray(this._connections);
	    sortedConnections.sort(this._compareConnections.bind(this));
	    return sortedConnections;
	  }
	  
	  /**
	   * Get the best available connection in order of priority then response time.
	   * 
	   * @param {MoneroRpcConnection[]} excludedConnections - connections to be excluded from consideration (optional)
	   * @return {Promise<MoneroRpcConnection>} the best available connection in order of priority then response time, undefined if no connections available
	   */
	  async getBestAvailableConnection(excludedConnections) {
	    
	    // try connections within each ascending priority
	    for (let prioritizedConnections of this._getConnectionsInAscendingPriority()) {
	      try {
	        
	        // create promises to check connections
	        let that = this;
	        let checkPromises = [];
	        for (let connection of prioritizedConnections) {
	          if (excludedConnections && GenUtils.arrayContains(excludedConnections, connection)) continue;
	          checkPromises.push(new Promise(async function(resolve, reject) {
	            await connection.checkConnection(that._timeoutInMs);
	            if (connection.isConnected()) resolve(connection);
	            reject();
	          }));
	        }
	        
	        // use first available connection
	        let firstAvailable = await Promise.any(checkPromises);
	        if (firstAvailable) return firstAvailable;
	      } catch (err) {
	        if (!(err instanceof AggregateError)) throw new MoneroError(err);
	      }
	    }
	    return undefined;
	  }
	  
	  /**
	   * Set the current connection.
	   * Provide a URI to select an existing connection without updating its credentials.
	   * Provide a MoneroRpcConnection to add new connection or update credentials of existing connection with same URI.
	   * Notify if current connection changes.
	   * Does not check the connection.
	   * 
	   * @param {string|MoneroRpcConnection} uriOrConnection - is the uri of the connection or the connection to make current (default undefined for no current connection)
	   * @return {MoneroConnectionManager} this connection manager for chaining
	   */
	  setConnection(uriOrConnection) {
	    
	    // handle uri
	    if (uriOrConnection && typeof uriOrConnection === "string") {
	      let connection = this.getConnectionByUri(uriOrConnection);
	      return this.setConnection(connection === undefined ? new MoneroRpcConnection(uriOrConnection) : connection);
	    }
	    
	    // handle connection
	    let connection = uriOrConnection;
	    if (this._currentConnection === connection) return this;
	    
	    // check if setting undefined connection
	    if (!connection) {
	      this._currentConnection = undefined;
	      this._onConnectionChanged(undefined);
	      return this;
	    }
	    
	    // validate connection
	    if (!(connection instanceof MoneroRpcConnection)) throw new MoneroError("Must provide string or MoneroRpcConnection to set connection");
	    if (!connection.getUri()) throw new MoneroError("Connection is missing URI");
	    
	    // check if adding new connection
	    let prevConnection = this.getConnectionByUri(connection.getUri());
	    if (!prevConnection) {
	      this.addConnection(connection);
	      this._currentConnection = connection;
	      if (this._proxyToWorker !== undefined) connection.setProxyToWorker(this._proxyToWorker);
	      this._onConnectionChanged(this._currentConnection);
	      return this;
	    }
	    
	    // check if updating current connection
	    if (prevConnection !== this._currentConnection || prevConnection.getUsername() !== connection.getUsername() || prevConnection.getPassword() !== connection.getPassword() || prevConnection.getPriority() !== connection.getPriority()) {
	      prevConnection.setCredentials(connection.getUsername(), connection.getPassword());
	      prevConnection.setPriority(connection.getPriority());
	      this._currentConnection = prevConnection;
	      if (this._proxyToWorker !== undefined) connection.setProxyToWorker(this._proxyToWorker);
	      this._onConnectionChanged(this._currentConnection);
	    }
	    
	    return this;
	  }
	  
	  /**
	   * Check the current connection. If disconnected and auto switch enabled, switches to best available connection.
	   * 
	   * @return {Promise<MoneroConnectionManager>} this connection manager for chaining
	   */
	  async checkConnection() {
	    let connectionChanged = false;
	    let connection = this.getConnection();
	    if (connection && await connection.checkConnection(this._timeoutInMs)) connectionChanged = true;
	    if (this._autoSwitch && !this.isConnected()) {
	      let bestConnection = await this.getBestAvailableConnection([connection]);
	      if (bestConnection) {
	        this.setConnection(bestConnection);
	        return this;
	      }
	    }
	    if (connectionChanged) await this._onConnectionChanged(connection);   
	    return this;
	  }
	  
	  /**
	   * Check all managed connections.
	   * 
	   * @return {Promise<MoneroConnectionManager>} this connection manager for chaining
	   */
	  async checkConnections() {
	    
	    // check all connections
	    await Promise.all(this.checkConnectionPromises());
	    
	    // auto switch to best connection
	    if (this._autoSwitch && !this.isConnected()) {
	      for (let prioritizedConnections of this._getConnectionsInAscendingPriority()) {
	        let bestConnection;
	        for (let prioritizedConnection of prioritizedConnections) {
	          if (prioritizedConnection.isConnected() && (!bestConnection || prioritizedConnection.getResponseTime() < bestConnection.getResponseTime())) {
	            bestConnection = prioritizedConnection;
	          }
	        }
	        if (bestConnection) {
	          this.setConnection(bestConnection);
	          break;
	        }
	      }
	    }
	    return this;
	  }
	  
	  /**
	   * Check all managed connections, returning a promise for each connection check.
	   * Does not auto switch if disconnected.
	   *
	   * @return {Promise[]} a promise for each connection in the order of getConnections().
	   */
	  checkConnectionPromises() {
	    let that = this;
	    let checkPromises = [];
	    let pool = new ThreadPool(this._connections.length);
	    for (let connection of this.getConnections()) {
	      checkPromises.push(pool.submit(async function() {
	        try {
	          if (await connection.checkConnection(that._timeoutInMs) && connection === this._currentConnection) await that._onConnectionChanged(connection);
	        } catch (err) {
	          // ignore error
	        }
	      }));
	    }
	    Promise.all(checkPromises);
	    return checkPromises;
	  }
	  
	  /**
	   * Check the connection and start checking the connection periodically.
	   * 
	   * @param {number} periodMs is the time between checks in milliseconds (default 10000 or 10 seconds)
	   * @return {Promise<MoneroConnectionManager>} this connection manager for chaining (after first checking the connection)
	   */
	  async startCheckingConnection(periodMs) {
	    await this.checkConnection();
	    if (!periodMs) periodMs = MoneroConnectionManager.DEFAULT_CHECK_CONNECTION_PERIOD;
	    if (this._checkLooper) return this;
	    let that = this;
	    let firstCheck = true;
	    this._checkLooper = new TaskLooper(async function() {
	      if (firstCheck) {
	        firstCheck = false; // skip first check
	        return;
	      }
	      try { await that.checkConnection(); }
	      catch (err) { console.error("Error checking connection: " + err); }
	    });
	    this._checkLooper.start(periodMs);
	    return this;
	  }
	  
	  /**
	   * Stop checking the connection status periodically.
	   * 
	   * @return {MoneroConnectionManager} this connection manager for chaining
	   */
	  stopCheckingConnection() {
	    if (this._checkLooper) this._checkLooper.stop();
	    delete this._checkLooper;
	    return this;
	  }

	  /**
	   * Automatically switch to best available connection if current connection is disconnected after being checked.
	   * 
	   * @param {boolean} autoSwitch specifies if the connection should switch on disconnect
	   * @return {MoneroConnectionManager} this connection manager for chaining
	   */
	  setAutoSwitch(autoSwitch) {
	    this._autoSwitch = autoSwitch;
	    return this;
	  }
	  
	  /**
	   * Get if auto switch is enabled or disabled.
	   * 
	   * @return {boolean} true if auto switch enabled, false otherwise
	   */
	  getAutoSwitch() {
	    return this._autoSwitch;
	  }
	  
	  /**
	   * Set the maximum request time before its connection is considered offline.
	   * 
	   * @param {int} timeoutInMs - the timeout before the connection is considered offline
	   * @return {MoneroConnectionManager} this connection manager for chaining
	   */
	  setTimeout(timeoutInMs) {
	    this._timeoutInMs = timeoutInMs;
	    return this;
	  }
	  
	  /**
	   * Get the request timeout.
	   * 
	   * @return {int} the request timeout before a connection is considered offline
	   */
	  getTimeout() {
	    return this._timeoutInMs;
	  }
	  
	  /**
	   * Collect connectable peers of the managed connections.
	   *
	   * @return {MoneroRpcConnection[]} connectable peers
	   */
	  async getPeerConnections() {
	    throw new MoneroError("Not implemented");
	  }
	  
	  /**
	   * Disconnect from the current connection.
	   * 
	   * @return {MoneroConnectionManager} this connection manager for chaining
	   */
	  disconnect() {
	    this.setConnection(undefined);
	    return this;
	  }
	  
	  /**
	   * Remove all connections.
	   * 
	   * @return {MoneroConnectonManager} this connection manager for chaining
	   */
	  clear() {
	    this._connections.splice(0, this._connections.length);
	    if (this._currentConnection) {
	      this._currentConnection = undefined;
	      this._onConnectionChanged(undefined);
	    }
	    return this;
	  }
	  
	  /**
	   * Reset to default state.
	   * 
	   * @return {MoneroConnectonManager} this connection manager for chaining
	   */
	  reset() {
	    this.removeListeners();
	    this.stopCheckingConnection();
	    this.clear();
	    this._timeoutMs = MoneroConnectionManager.DEFAULT_TIMEOUT;
	    this._autoSwitch = false;
	    return this;
	  }
	  
	  // ------------------------------ PRIVATE HELPERS ---------------------------
	  
	  async _onConnectionChanged(connection) {
	    let promises = [];
	    for (let listener of this._listeners) promises.push(listener.onConnectionChanged(connection));
	    return Promise.all(promises);
	  }
	  
	  _getConnectionsInAscendingPriority() {
	    let connectionPriorities = new Map();
	    for (let connection of this._connections) {
	      if (!connectionPriorities.has(connection.getPriority())) connectionPriorities.set(connection.getPriority(), []);
	      connectionPriorities.get(connection.getPriority()).push(connection);
	    }
	    let ascendingPriorities = new Map([...connectionPriorities].sort((a, b) => parseInt(a[0]) - parseInt(b[0]))); // create map in ascending order
	    let ascendingPrioritiesList = [];
	    for (let priorityConnections of ascendingPriorities.values()) ascendingPrioritiesList.push(priorityConnections);
	    if (connectionPriorities.has(0)) ascendingPrioritiesList.push(ascendingPrioritiesList.splice(0, 1)[0]); // move priority 0 to end
	    return ascendingPrioritiesList;
	  }
	  
	  _compareConnections(c1, c2) {
	    
	      // current connection is first
	      if (c1 === this._currentConnection) return -1;
	      if (c2 === this._currentConnection) return 1;
	      
	      // order by availability then priority then by name
	      if (c1.isOnline() === c2.isOnline()) {
	        if (c1.getPriority() === c2.getPriority()) return c1.getUri().localeCompare(c2.getUri());
	        else return c1.getPriority() == 0 ? 1 : c2.getPriority() == 0 ? -1 : c1.getPriority() - c2.getPriority();
	      } else {
	        if (c1.isOnline()) return -1;
	        else if (c2.isOnline()) return 1;
	        else if (c1.isOnline() === undefined) return -1;
	        else return 1; // c1 is offline
	      }
	  }
	}

	MoneroConnectionManager.DEFAULT_TIMEOUT = 5000;
	MoneroConnectionManager.DEFAULT_CHECK_CONNECTION_PERIOD = 15000;

	MoneroConnectionManager_1 = MoneroConnectionManager;
	return MoneroConnectionManager_1;
}

/**
 * Default connection manager listener which takes no action on notifications.
 */

class MoneroConnectionManagerListener {
  
  /**
   * Notified on connection change events.
   * 
   * @param {MoneroRpcConnection} connection - the connection manager's current connection
   */
  async onConnectionChanged(connection) { }
}

var MoneroConnectionManagerListener_1 = MoneroConnectionManagerListener;

const MoneroError$2 = MoneroError_1;

/**
 * Copyright (c) woodser
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * Monero daemon interface and default implementations.
 * 
 * @interface
 */
class MoneroDaemon {
    
  /**
   * Register a listener to receive daemon notifications.
   * 
   * @param {MoneroDaemonListener} listener - listener to receive daemon notifications
   */
  async addListener(listener) {
    throw new MoneroError$2("Subclass must implement");
  }
  
  /**
   * Unregister a listener to receive daemon notifications.
   * 
   * @param {MoneroDaemonListener} listener - listener to unregister
   */
  async removeListener(listener) {
    throw new MoneroError$2("Subclass must implement");
  }
  
  /**
   * Get the listeners registered with the daemon.
   * 
   * @return {MoneroDaemonListener[]} the registered listeners
   */
  getListeners() {
    throw new MoneroError$2("Subclass must implement");
  }
  
  /**
   * Indicates if the client is connected to the daemon via RPC.
   * 
   * @return {boolean} true if the client is connected to the daemon, false otherwise
   */
  async isConnected() {
    throw new MoneroError$2("Subclass must implement");
  }
  
  /**
   * Gets the version of the daemon.
   * 
   * @return {MoneroVersion} the version of the daemon
   */
  async getVersion() {
    throw new MoneroError$2("Subclass must implement");
  }
  
  /**
   * Indicates if the daemon is trusted xor untrusted.
   * 
   * @return {boolean} true if the daemon is trusted, false otherwise
   */
  async isTrusted() {
    throw new MoneroError$2("Subclass must implement");
  }
  
  /**
   * Get the number of blocks in the longest chain known to the node.
   * 
   * @return {int} the number of blocks
   */
  async getHeight() {
    throw new MoneroError$2("Subclass must implement");
  }
  
  /**
   * Get a block's hash by its height.
   * 
   * @param {int} height - height of the block hash to get
   * @return {string} the block's hash at the given height
   */
  async getBlockHash(height) {
    throw new MoneroError$2("Subclass must implement");
  }
  
  /**
   * Get a block template for mining a new block.
   * 
   * @param {string} walletAddress - address of the wallet to receive miner transactions if block is successfully mined
   * @param {int} reserveSize - reserve size (optional)
   * @return {MoneroBlockTemplate} is a block template for mining a new block
   */
  async getBlockTemplate(walletAddress, reserveSize) {
    throw new MoneroError$2("Subclass must implement");
  }
  
  /**
   * Get the last block's header.
   * 
   * @return {MoneroBlockHeader} last block's header
   */
  async getLastBlockHeader() {
    throw new MoneroError$2("Subclass must implement");
  }
  
  /**
   * Get a block header by its hash.
   * 
   * @param {string} blockHash - hash of the block to get the header of
   * @return {MoneroBlockHeader} block's header
   */
  async getBlockHeaderByHash(blockHash) {
    throw new MoneroError$2("Subclass must implement");
  }
  
  /**
   * Get a block header by its height.
   * 
   * @param {int} height - height of the block to get the header of
   * @return {MoneroBlockHeader} block's header
   */
  async getBlockHeaderByHeight(height) {
    throw new MoneroError$2("Subclass must implement");
  }
  
  /**
   * Get block headers for the given range.
   * 
   * @param {int} startHeight - start height lower bound inclusive (optional)
   * @param {int} endHeight - end height upper bound inclusive (optional)
   * @return {MoneroBlockHeader[]} for the given range
   */
  async getBlockHeadersByRange(startHeight, endHeight) {
    throw new MoneroError$2("Subclass must implement");
  }
  
  /**
   * Get a block by hash.
   * 
   * @param {string} blockHash - hash of the block to get
   * @return {MoneroBlock} with the given hash
   */
  async getBlockByHash(blockHash) {
    throw new MoneroError$2("Subclass must implement");
  }
  
  /**
   * Get blocks by hash.
   * 
   * @param {string[]} blockHashes - array of hashes; first 10 blocks hashes goes sequential,
   *        next goes in pow(2,n) offset, like 2, 4, 8, 16, 32, 64 and so on,
   *        and the last one is always genesis block
   * @param {int} startHeight - start height to get blocks by hash
   * @param {boolean} prune - specifies if returned blocks should be pruned (defaults to false)  // TODO: test default
   * @return {MoneroBlock[]} retrieved blocks
   */
  async getBlocksByHash(blockHashes, startHeight, prune) {
    throw new MoneroError$2("Subclass must implement");
  }
  
  /**
   * Get a block by height.
   * 
   * @param {int} height - height of the block to get
   * @return {MoneroBlock} with the given height
   */
  async getBlockByHeight(height) {
    throw new MoneroError$2("Subclass must implement");
  }
  
  /**
   * Get blocks at the given heights.
   * 
   * @param {int[]} heights - heights of the blocks to get
   * @return {MoneroBlock[]} are blocks at the given heights
   */
  async getBlocksByHeight(heights) {
    throw new MoneroError$2("Subclass must implement");
  }
  
  /**
   * Get blocks in the given height range.
   * 
   * @param {int} startHeight - start height lower bound inclusive (optional)
   * @param {int} endHeight - end height upper bound inclusive (optional)
   * @return {MoneroBlock[]} are blocks in the given height range
   */
  async getBlocksByRange(startHeight, endHeight) {
    throw new MoneroError$2("Subclass must implement");
  }
  
  /**
   * Get blocks in the given height range as chunked requests so that each request is
   * not too big.
   * 
   * @param {int} startHeight - start height lower bound inclusive (optional)
   * @param {int} endHeight - end height upper bound inclusive (optional)
   * @param {int} maxChunkSize - maximum chunk size in any one request (default 3,000,000 bytes)
   * @return {MoneroBlock[]} blocks in the given height range
   */
  async getBlocksByRangeChunked(startHeight, endHeight, maxChunkSize) {
    throw new MoneroError$2("Subclass must implement");
  }
  
  /**
   * Get block hashes as a binary request to the daemon.
   * 
   * @param {string[]} blockHashes - specify block hashes to fetch; first 10 blocks hash goes
   *        sequential, next goes in pow(2,n) offset, like 2, 4, 8, 16, 32, 64
   *        and so on, and the last one is always genesis block
   * @param {int} startHeight - starting height of block hashes to return
   * @return {string[]} requested block hashes     
   */
  async getBlockHashes(blockHashes, startHeight) {
    throw new MoneroError$2("Subclass must implement");
  }
  
  /**
   * Get a transaction by hash.
   * 
   * @param {string} txHash - hash of the transaction to get
   * @param {boolean} prune - specifies if the returned tx should be pruned (defaults to false)
   * @return {MoneroTx} transaction with the given hash
   */
  async getTx(txHash, prune = false) {
    return (await this.getTxs([txHash], prune))[0];
  }
  
  /**
   * Get transactions by hashes.
   * 
   * @param {string[]} txHashes - hashes of transactions to get
   * @param {boolean} prune - specifies if the returned txs should be pruned (defaults to false)
   * @return {MoneroTx[]} transactions with the given hashes
   */
  async getTxs(txHashes, prune = false) {
    throw new MoneroError$2("Subclass must implement");
  }
  
  /**
   * Get a transaction hex by hash.
   * 
   * @param {string} txHash - hash of the transaction to get hex from
   * @param {boolean} prune - specifies if the returned tx hex should be pruned (defaults to false)
   * @return {string} tx hex with the given hash
   */
  async getTxHex(txHash, prune = false) {
    return (await this.getTxHexes([txHash], prune))[0];
  }
  
  /**
   * Get transaction hexes by hashes.
   * 
   * @param {string[]} txHashes - hashes of transactions to get hexes from
   * @param {boolean} prune - specifies if the returned tx hexes should be pruned (defaults to false)
   * @return {string[]} tx hexes
   */
  async getTxHexes(txHashes, prune = false) {
    throw new MoneroError$2("Subclass must implement");
  }
  
  /**
   * Gets the total emissions and fees from the genesis block to the current height.
   * 
   * @param {int} height - height to start computing the miner sum
   * @param {int} numBlocks - number of blocks to include in the sum
   * @return {MoneroMinerTxSum} encapsulates the total emissions and fees since the genesis block
   */
  async getMinerTxSum(height, numBlocks) {
    throw new MoneroError$2("Subclass must implement");
  }
  
  /**
   * Get the fee estimate per kB.
   * 
   * @param {int} graceBlocks TODO
   * @return {BigInteger} fee estimate per kB.
   */
  async getFeeEstimate(graceBlocks) {
    throw new MoneroError$2("Subclass must implement");
  }
  
  /**
   * Submits a transaction to the daemon's pool.
   * 
   * @param {string} txHex - raw transaction hex to submit
   * @param {boolean} doNotRelay specifies if the tx should be relayed (optional)
   * @return {MoneroSubmitTxResult} contains submission results
   */
  async submitTxHex(txHex, doNotRelay) {
    throw new MoneroError$2("Subclass must implement");
  }
  
  /**
   * Relays a transaction by hash.
   * 
   * @param {string} txHash - hash of the transaction to relay
   */
  async relayTxByHash(txHash) {
    const assert = require$$0;
    assert.equal(typeof txHash, "string", "Must provide a transaction hash");
    await this.relayTxsByHash([txHash]);
  }
  
  /**
   * Relays transactions by hash.
   * 
   * @param {string[]} txHashes - hashes of the transactinos to relay
   */
  async relayTxsByHash(txHashes) {
    throw new MoneroError$2("Subclass must implement");
  }
  
  /**
   * Get valid transactions seen by the node but not yet mined into a block, as well
   * as spent key image information for the tx pool.
   * 
   * @return {MoneroTx[]} are transactions in the transaction pool
   */
  async getTxPool() {
    throw new MoneroError$2("Subclass must implement");
  }
  
  /**
   * Get hashes of transactions in the transaction pool.
   * 
   * @return {string[]} are hashes of transactions in the transaction pool
   */
  async getTxPoolHashes() {
    throw new MoneroError$2("Subclass must implement");
  }
  
  /**
   * Get all transaction pool backlog.
   * 
   * @return {MoneroTxBacklogEntry[]} backlog entries 
   */
  async getTxPoolBacklog() {
    throw new MoneroError$2("Subclass must implement");
  }
  
  /**
   * Get transaction pool statistics.
   * 
   * @return {MoneroTxPoolStats} contains statistics about the transaction pool
   */
  async getTxPoolStats() {
    throw new MoneroError$2("Subclass must implement");
  }
  
  /**
   * Flush transactions from the tx pool.
   * 
   * @param {(string|string[])} hashes - specific transactions to flush (defaults to all)
   */
  async flushTxPool(hashes) {
    throw new MoneroError$2("Subclass must implement");
  }
  
  /**
   * Get the spent status of the given key image.
   * 
   * @param {string} keyImage - key image hex to get the status of
   * @return {MoneroKeyImageSpentStatus} status of the key image
   */
  async getKeyImageSpentStatus(keyImage) {
    return (await this.getKeyImageSpentStatuses([keyImage]))[0];
  }
  
  /**
   * Get the spent status of each given key image.
   * 
   * @param {string[]} keyImages are hex key images to get the statuses of
   * @return {MoneroKeyImageSpentStatus[]} status for each key image
   */
  async getKeyImageSpentStatuses(keyImages) {
    throw new MoneroError$2("Subclass must implement");
  }
  
  /**
   * Get outputs identified by a list of output amounts and indices as a binary
   * request.
   * 
   * @param {MoneroOutput[]} outputs - identify each output by amount and index
   * @return {MoneroOutput[]} identified outputs
   */
  async getOutputs(outputs) {
    throw new MoneroError$2("Subclass must implement");
  }
  
  /**
   * Get a histogram of output amounts. For all amounts (possibly filtered by
   * parameters), gives the number of outputs on the chain for that amount.
   * RingCT outputs counts as 0 amount.
   * 
   * @param {BigInteger[]} amounts - amounts of outputs to make the histogram with
   * @param {int} minCount - TODO
   * @param {int} maxCount - TODO
   * @param {boolean} isUnlocked - makes a histogram with outputs with the specified lock state
   * @param {int} recentCutoff - TODO
   * @return {MoneroOutputHistogramEntry[]} are entries meeting the parameters
   */
  async getOutputHistogram(amounts, minCount, maxCount, isUnlocked, recentCutoff) {
    throw new MoneroError$2("Subclass must implement");
  }
  
  /**
   * Creates an output distribution.
   * 
   * @param {BigInteger[]} amounts - amounts of outputs to make the distribution with
   * @param {boolean} cumulative - specifies if the results should be cumulative (defaults to TODO)
   * @param {int} startHeight - start height lower bound inclusive (optional)
   * @param {int} endHeight - end height upper bound inclusive (optional)
   * @return {MoneroOutputDistributionEntry[]} are entries meeting the parameters
   */
  async getOutputDistribution(amounts, cumulative, startHeight, endHeight) {
    throw new MoneroError$2("Subclass must implement");
  }
  
  /**
   * Get general information about the state of the node and the network.
   * 
   * @return {MoneroDaemonInfo} is general information about the node and network
   */
  async getInfo() {
    throw new MoneroError$2("Subclass must implement");
  }
  
  /**
   * Get synchronization information.
   * 
   * @return {MoneroDaemonSyncInfo} contains sync information
   */
  async getSyncInfo() {
    throw new MoneroError$2("Subclass must implement");
  }
  
  /**
   * Look up information regarding hard fork voting and readiness.
   * 
   * @return {MoneroHardForkInfo} contains hard fork information
   */
  async getHardForkInfo() {
    throw new MoneroError$2("Subclass must implement");
  }
  
  /**
   * Get alternative chains seen by the node.
   * 
   * @return {MoneroAltChain[]} alternative chains
   */
  async getAltChains() {
    throw new MoneroError$2("Subclass must implement");
  }
  
  /**
   * Get known block hashes which are not on the main chain.
   * 
   * @return {string[]} known block hashes which are not on the main chain
   */
  async getAltBlockHashes() {
    throw new MoneroError$2("Subclass must implement");
  }
  
  /**
   * Get the download bandwidth limit.
   * 
   * @return {int} download bandwidth limit
   */
  async getDownloadLimit() {
    throw new MoneroError$2("Subclass must implement");
  }
  
  /**
   * Set the download bandwidth limit.
   * 
   * @param {int} limit - download limit to set (-1 to reset to default)
   * @return {int} new download limit after setting
   */
  async setDownloadLimit(limit) {
    throw new MoneroError$2("Subclass must implement");
  }
  
  /**
   * Reset the download bandwidth limit.
   * 
   * @return {int} download bandwidth limit after resetting
   */
  async resetDownloadLimit() {
    throw new MoneroError$2("Subclass must implement");
  }
  
  /**
   * Get the upload bandwidth limit.
   * 
   * @return {int} upload bandwidth limit
   */
  async getUploadLimit() {
    throw new MoneroError$2("Subclass must implement");
  }
  
  /**
   * Set the upload bandwidth limit.
   * 
   * @param limit - upload limit to set (-1 to reset to default)
   * @return {int} new upload limit after setting
   */
  async setUploadLimit(limit) {
    throw new MoneroError$2("Subclass must implement");
  }
  
  /**
   * Reset the upload bandwidth limit.
   * 
   * @return {int} upload bandwidth limit after resetting
   */
  async resetUploadLimit() {
    throw new MoneroError$2("Subclass must implement");
  }
  
  /**
   * Get peers with active incoming or outgoing connections to the node.
   * 
   * @return {MoneroPeer[]} the daemon's peers
   */
  async getPeers() {
    throw new MoneroError$2("Subclass must implement");
  }
  
  /**
   * Get known peers including their last known online status.
   * 
   * @return {MoneroPeer[]} the daemon's known peers
   */
  async getKnownPeers() {
    throw new MoneroError$2("Subclass must implement");
  }
  
  /**
   * Limit number of outgoing peers.
   * 
   * @param {int} limit - maximum number of outgoing peers
   */
  async setOutgoingPeerLimit(limit) {
    throw new MoneroError$2("Subclass must implement");
  }
  
  /**
   * Limit number of incoming peers.
   * 
   * @param {int} limit - maximum number of incoming peers
   */
  async setIncomingPeerLimit(limit) {
    throw new MoneroError$2("Subclass must implement");
  }
  
  /**
   * Get peer bans.
   * 
   * @return {MoneroBan[]} entries about banned peers
   */
  async getPeerBans() {
    throw new MoneroError$2("Subclass must implement");
  }

  /**
   * Ban a peer node.
   * 
   * @param {MoneroBan} ban - contains information about a node to ban
   */
  async setPeerBan(ban) {
    return await this.setPeerBans([ban]);
  }
  
  /**
   * Ban peers nodes.
   * 
   * @param {MoneroBan[]} bans - specify which peers to ban
   */
  async setPeerBans(bans) {
    throw new MoneroError$2("Subclass must implement");
  }
  
  /**
   * Start mining.
   * 
   * @param {string} address - address given miner rewards if the daemon mines a block
   * @param {integer} numThreads - number of mining threads to run
   * @param {boolean} isBackground - specifies if the miner should run in the background or not
   * @param {boolean} ignoreBattery - specifies if the battery state (e.g. on laptop) should be ignored or not
   */
  async startMining(address, numThreads, isBackground, ignoreBattery) {
    throw new MoneroError$2("Subclass must implement");
  }
  
  /**
   * Stop mining.
   */
  async stopMining() {
    throw new MoneroError$2("Subclass must implement");
  }
  
  /**
   * Get the daemon's mining status.
   * 
   * @return {MoneroMiningStatus} daemon's mining status
   */
  async getMiningStatus() {
    throw new MoneroError$2("Subclass must implement");
  }
  
  /**
   * Submit a mined block to the network.
   * 
   * @param {string} blockBlob - mined block to submit
   */
  async submitBlock(blockBlob) {
    await this.submitBlocks([blockBlob]);
  }
  
  /**
   * Submit mined blocks to the network.
   * 
   * @param {string[]} blockBlobs - mined blocks to submit
   */
  async submitBlocks(blockBlobs) {
    throw new MoneroError$2("Subclass must implement");
  }
  
  /**
   * Check for update.
   * 
   * @return {MoneroDaemonUpdateCheckResult} the result
   */
  async checkForUpdate() {
    throw new MoneroError$2("Subclass must implement");
  }
  
  /**
   * Download an update.
   * 
   * @param {string} path - path to download the update (optional)
   * @return {MoneroDaemonUpdateDownloadResult} the result
   */
  async downloadUpdate(path) {
    throw new MoneroError$2("Subclass must implement");
  }
  
  /**
   * Safely disconnect and shut down the daemon.
   */
  async stop() {
    throw new MoneroError$2("Subclass must implement");
  }
  
  /**
   * Get the header of the next block added to the chain.
   * 
   * @return {MoneroBlockHeader} header of the next block added to the chain
   */
  async waitForNextBlockHeader() {
    throw new MoneroError$2("Subclass must implement");
  }
  
  // ----------------------------- STATIC UTILITIES ---------------------------
  
  /**
   * Parses a network string to an enumerated type.
   * 
   * @param {string} network - network string to parse
   * @return {MoneroNetworkType} enumerated network type
   */
  static parseNetworkType(network) {
    const MoneroNetworkType = MoneroNetworkType_1;
    if (network === "mainnet") return MoneroNetworkType.MAINNET;
    if (network === "testnet") return MoneroNetworkType.TESTNET;
    if (network === "stagenet") return MoneroNetworkType.STAGENET;
    throw new MoneroError$2("Invalid network type to parse: " + network);
  }
}

var MoneroDaemon_1 = MoneroDaemon;

const assert$1 = require$$0;
const MoneroBlock = MoneroBlock_1;
const BigInteger = biginteger.BigInteger;
const MoneroError$1 = MoneroError_1;
const MoneroOutputQuery = requireMoneroOutputQuery();
const MoneroTransferQuery = requireMoneroTransferQuery();
const MoneroTxConfig = MoneroTxConfig_1;
const MoneroTxQuery$1 = requireMoneroTxQuery();
const MoneroTxSet = requireMoneroTxSet();

/**
 * Copyright (c) woodser
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * Monero wallet interface and default implementations.
 * 
 * @interface
 */
class MoneroWallet {
  
  /**
   * Register a listener to receive wallet notifications.
   * 
   * @param {MoneroWalletListener} listener - listener to receive wallet notifications
   */
  async addListener(listener) {
    throw new Error("Not supported");
  }
  
  /**
   * Unregister a listener to receive wallet notifications.
   * 
   * @param {MoneroWalletListener} listener - listener to unregister
   */
  async removeListener(listener) {
    throw new Error("Not supported");
  }
  
  /**
   * Get the listeners registered with the wallet.
   * 
   * @return {MoneroWalletListener[]} the registered listeners
   */
  getListeners() {
    throw new Error("Not supported");
  }
  
  /**
   * Indicates if the wallet is view-only, meaning it does not have the private
   * spend key and can therefore only observe incoming outputs.
   * 
   * @return {bool} true if the wallet is view-only, false otherwise
   */
  async isViewOnly() {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Set the wallet's daemon connection.
   * 
   * @param {string|MoneroRpcConnection} uriOrConnection - daemon's URI or connection (defaults to offline)
   * @param {string} username - username to authenticate with the daemon (optional)
   * @param {string} password - password to authenticate with the daemon (optional)
   */
  async setDaemonConnection(uriOrConnection, username, password) {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Get the wallet's daemon connection.
   * 
   * @return {MoneroRpcConnection} the wallet's daemon connection
   */
  async getDaemonConnection() {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Indicates if the wallet is connected to daemon.
   * 
   * @return {boolean} true if the wallet is connected to a daemon, false otherwise
   */
  async isConnectedToDaemon() {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Gets the version of the wallet.
   * 
   * @return {MoneroVersion} the version of the wallet
   */
  async getVersion() {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Get the wallet's path.
   * 
   * @return {string} the path the wallet can be opened with
   */
  async getPath() {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Get the wallet's mnemonic phrase derived from the seed.
   * 
   * @return {string} the wallet's mnemonic phrase
   */
  async getMnemonic() {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Get the language of the wallet's mnemonic phrase.
   * 
   * @return {string} the language of the wallet's mnemonic phrase
   */
  async getMnemonicLanguage() {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Get the wallet's private view key.
   * 
   * @return {string} the wallet's private view key
   */
  async getPrivateViewKey() {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Get the wallet's private spend key.
   * 
   * @return {string} the wallet's private spend key
   */
  async getPrivateSpendKey() {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Get the wallet's public view key.
   * 
   * @return {string} the wallet's public view key
   */
  async getPublicViewKey() {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Get the wallet's public spend key.
   * 
   * @return {string} the wallet's public spend key
   */
  async getPublicSpendKey() {
    throw new MoneroError$1("Not supported");
  }
    
  /**
   * Get the wallet's primary address.
   * 
   * @return {string} the wallet's primary address
   */
  async getPrimaryAddress() {
    return await this.getAddress(0, 0);
  }
  
  /**
   * Get the address of a specific subaddress.
   * 
   * @param {int} accountIdx - the account index of the address's subaddress
   * @param {int} subaddressIdx - the subaddress index within the account
   * @return {string} the receive address of the specified subaddress
   */
  async getAddress(accountIdx, subaddressIdx) {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Get the account and subaddress index of the given address.
   * 
   * @param {string} address - address to get the account and subaddress index from
   * @return {MoneroSubaddress} the account and subaddress indices
   */
  async getAddressIndex(address) {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Get an integrated address based on the given standard address and payment
   * ID. Uses the wallet's primary address if an address is not given.
   * Generates a random payment ID if a payment ID is not given.
   * 
   * @param {string} standardAddress is the standard address to generate the integrated address from (wallet's primary address if undefined)
   * @param {string} paymentId is the payment ID to generate an integrated address from (randomly generated if undefined)
   * @return {MoneroIntegratedAddress} the integrated address
   */
  async getIntegratedAddress(standardAddress, paymentId) {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Decode an integrated address to get its standard address and payment id.
   * 
   * @param {string} integratedAddress - integrated address to decode
   * @return {MoneroIntegratedAddress} the decoded integrated address including standard address and payment id
   */
  async decodeIntegratedAddress(integratedAddress) {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Get the block height that the wallet is synced to.
   * 
   * @return {int} the block height that the wallet is synced to
   */
  async getHeight() {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Get the blockchain's height.
   * 
   * @return {int} the blockchain's height
   */
  async getDaemonHeight() {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Get the blockchain's height by date as a conservative estimate for scanning.
   * 
   * @param {int} year - year of the height to get
   * @param {int} month - month of the height to get as a number between 1 and 12
   * @param {int} day - day of the height to get as a number between 1 and 31
   * @return the blockchain's approximate height at the given date
   */
  async getHeightByDate(year, month, day) {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Synchronize the wallet with the daemon as a one-time synchronous process.
   * 
   * @param {MoneroWalletListener|number} listenerOrStartHeight - listener xor start height (defaults to no sync listener, the last synced block)
   * @param {number} startHeight - startHeight if not given in first arg (defaults to last synced block)
   */
  async sync(listenerOrStartHeight, startHeight) {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Start background synchronizing with a maximum period between syncs.
   * 
   * @param {int} syncPeriodInMs - maximum period between syncs in milliseconds (default is wallet-specific)
   */
  async startSyncing(syncPeriodInMs) {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Stop synchronizing the wallet with the daemon.
   */
  async stopSyncing() {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Scan transactions by their hash/id.
   * 
   * @param {string[]} txHashes - tx hashes to scan
   */
  async scanTxs(txHashes) {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * <p>Rescan the blockchain for spent outputs.</p>
   * 
   * <p>Note: this can only be called with a trusted daemon.</p>
   * 
   * <p>Example use case: peer multisig hex is import when connected to an untrusted daemon,
   * so the wallet will not rescan spent outputs.  Then the wallet connects to a trusted
   * daemon.  This method should be manually invoked to rescan outputs.</p>
   */
  async rescanSpent() {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * <p>Rescan the blockchain from scratch, losing any information which cannot be recovered from
   * the blockchain itself.</p>
   * 
   * <p>WARNING: This method discards local wallet data like destination addresses, tx secret keys,
   * tx notes, etc.</p>
   */
  async rescanBlockchain() {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Get the balance of the wallet, account, or subaddress.
   * 
   * @param {int} accountIdx - index of the account to get the balance of (default all accounts)
   * @param {int} subaddressIdx - index of the subaddress to get the balance of (default all subaddresses)
   * @return {BigInteger} the balance of the wallet, account, or subaddress
   */
  async getBalance(accountIdx, subaddressIdx) {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Get the unlocked balance of the wallet, account, or subaddress.
   * 
   * @param {int} accountIdx - index of the account to get the unlocked balance of (optional)
   * @param {int} subaddressIdx - index of the subaddress to get the unlocked balance of (optional)
   * @return {BigInteger} the unlocked balance of the wallet, account, or subaddress
   */
  async getUnlockedBalance(accountIdx, subaddressIdx) {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Get the number of blocks until the next and last funds unlock.
   * 
   * @return {int[]} the number of blocks until the next and last funds unlock in elements 0 and 1, respectively, or undefined if no balance
   */
  async getNumBlocksToUnlock() {
    
    // get balances
    let balance = await this.getBalance();
    if (balance.compare(new BigInteger(0)) === 0) return [undefined, undefined]; // skip if no balance
    let unlockedBalance = await this.getUnlockedBalance();
    
    // compute number of blocks until next funds available
    let txs;
    let height;
    let numBlocksToNextUnlock = undefined;
    if (unlockedBalance.compare(new BigInteger(0)) > 0) numBlocksToNextUnlock = 0;
    else {
      txs = await this.getTxs({isLocked: true}); // get locked txs
      height = await this.getHeight(); // get most recent height
      for (let tx of txs) {
        let numBlocksToUnlock = Math.max((tx.isConfirmed() ? tx.getHeight() : height) + 10, tx.getUnlockHeight()) - height;
        numBlocksToNextUnlock = numBlocksToNextUnlock === undefined ? numBlocksToUnlock : Math.min(numBlocksToNextUnlock, numBlocksToUnlock);
      }
    }
    
    // compute number of blocks until all funds available
    let numBlocksToLastUnlock = undefined;
    if (balance.compare(unlockedBalance) === 0) {
      if (unlockedBalance.compare(new BigInteger(0)) > 0) numBlocksToLastUnlock = 0;
    } else {
      if (!txs) {
        txs = await this.getTxs({isLocked: true}); // get locked txs
        height = await this.getHeight(); // get most recent height
      }
      for (let tx of txs) {
        let numBlocksToUnlock = Math.max((tx.isConfirmed() ? tx.getHeight() : height) + 10, tx.getUnlockHeight()) - height;
        numBlocksToLastUnlock = numBlocksToLastUnlock === undefined ? numBlocksToUnlock : Math.max(numBlocksToLastUnlock, numBlocksToUnlock);
      }
    }
    
    return [numBlocksToNextUnlock, numBlocksToLastUnlock];
  }
  
  /**
   * Get accounts with a given tag.
   * 
   * @param {boolean} includeSubaddresses - include subaddresses if true
   * @param {string} tag - tag for filtering accounts, all accounts if undefined
   * @return {MoneroAccount[]} all accounts with the given tag
   */
  async getAccounts(includeSubaddresses, tag) {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Get an account.
   * 
   * @param {int} accountIdx - index of the account to get
   * @param {boolean} includeSubaddresses - include subaddresses if true
   * @return {MoneroAccount} the retrieved account
   */
  async getAccount(accountIdx, includeSubaddresses) {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Create a new account with a label for the first subaddress.
   * 
   * @param {string} label - label for account's first subaddress (optional)
   * @return {MoneroAccount} the created account
   */
  async createAccount(label) {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Get subaddresses in an account.
   * 
   * @param {int} accountIdx - account to get subaddresses within
   * @param {int[]} subaddressIndices - indices of subaddresses to get (optional)
   * @return {MoneroSubaddress[]} the retrieved subaddresses
   */
  async getSubaddresses(accountIdx, subaddressIndices) {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Get a subaddress.
   * 
   * @param {int} accountIdx - index of the subaddress's account
   * @param {int} subaddressIdx - index of the subaddress within the account
   * @return {MoneroSubaddress} the retrieved subaddress
   */
  async getSubaddress(accountIdx, subaddressIdx) {
    assert$1(accountIdx >= 0);
    assert$1(subaddressIdx >= 0);
    return (await this.getSubaddresses(accountIdx, subaddressIdx))[0];
  }
  
  /**
   * Create a subaddress within an account.
   * 
   * @param {int} accountIdx - index of the account to create the subaddress within
   * @param {string} label - the label for the subaddress (optional)
   * @return {MoneroSubaddress} the created subaddress
   */
  async createSubaddress(accountIdx, label) {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Get a wallet transaction by hash.
   * 
   * @param {string} txHash - hash of a transaction to get
   * @return {MoneroTxWallet} the identified transactions
   */
  async getTx(txHash) {
    let txs = await this.getTxs([txHash]);
    return txs.length === 0 ? undefined : txs[0]; 
  }
  
  /**
   * <p>Get wallet transactions.  Wallet transactions contain one or more
   * transfers that are either incoming or outgoing to the wallet.<p>
   * 
   * <p>Results can be filtered by passing a query object.  Transactions must
   * meet every criteria defined in the query in order to be returned.  All
   * criteria are optional and no filtering is applied when not defined.</p>
   * 
   * @param {(MoneroTxQuery|string[]|object)} query - configures the query (optional)
   * @param {boolean} query.isConfirmed - get txs that are confirmed or not (optional)
   * @param {boolean} query.inTxPool - get txs that are in the tx pool or not (optional)
   * @param {boolean} query.isRelayed - get txs that are relayed or not (optional)
   * @param {boolean} query.isFailed - get txs that are failed or not (optional)
   * @param {boolean} query.isMinerTx - get miner txs or not (optional)
   * @param {string} query.hash - get a tx with the hash (optional)
   * @param {string[]} query.hashes - get txs with the hashes (optional)
   * @param {string} query.paymentId - get transactions with the payment id (optional)
   * @param {string[]} query.paymentIds - get transactions with the payment ids (optional)
   * @param {boolean} query.hasPaymentId - get transactions with a payment id or not (optional)
   * @param {int} query.minHeight - get txs with height >= the given height (optional)
   * @param {int} query.maxHeight - get txs with height <= the given height (optional)
   * @param {boolean} query.isOutgoing - get txs with an outgoing transfer or not (optional)
   * @param {boolean} query.isIncoming - get txs with an incoming transfer or not (optional)
   * @param {MoneroTransferQuery} query.transferQuery - get txs that have a transfer that meets this query (optional)
   * @param {boolean} query.includeOutputs - specifies that tx outputs should be returned with tx results (optional)
   * @param {string[]} missingTxHashes - populated with hashes of unfound or unmet transactions that were queried by hash (throws error if undefined and queried transaction hashes are unfound or unmet) 
   * @return {MoneroTxWallet[]} wallet transactions per the configuration
   */
  async getTxs(query, missingTxHashes) {
    throw new MoneroError$1("Not supported");
  }

  /**
   * <p>Get incoming and outgoing transfers to and from this wallet.  An outgoing
   * transfer represents a total amount sent from one or more subaddresses
   * within an account to individual destination addresses, each with their
   * own amount.  An incoming transfer represents a total amount received into
   * a subaddress within an account.  Transfers belong to transactions which
   * are stored on the blockchain.</p>
   * 
   * <p>Results can be filtered by passing a query object.  Transfers must
   * meet every criteria defined in the query in order to be returned.  All
   * criteria are optional and no filtering is applied when not defined.</p>
   * 
   * @param {(MoneroTransferQuery|object)} query - configures the query (optional)
   * @param {boolean} query.isOutgoing - get transfers that are outgoing or not (optional)
   * @param {boolean} query.isIncoming - get transfers that are incoming or not (optional)
   * @param {string} query.address - wallet's address that a transfer either originated from (if outgoing) or is destined for (if incoming) (optional)
   * @param {int} query.accountIndex - get transfers that either originated from (if outgoing) or are destined for (if incoming) a specific account index (optional)
   * @param {int} query.subaddressIndex - get transfers that either originated from (if outgoing) or are destined for (if incoming) a specific subaddress index (optional)
   * @param {int[]} query.subaddressIndices - get transfers that either originated from (if outgoing) or are destined for (if incoming) specific subaddress indices (optional)
   * @param {BigInteger} query.amount - amount being transferred (optional)
   * @param {MoneroDestination[]} query.destinations - individual destinations of an outgoing transfer, which is local wallet data and NOT recoverable from the blockchain (optional)
   * @param {boolean} query.hasDestinations - get transfers that have destinations or not (optional)
   * @param {MoneroTxQuery} query.txQuery - get transfers whose transaction meets this query (optional)
   * @return {MoneroTransfer[]} wallet transfers that meet the query
   */
  async getTransfers(query) {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Get incoming transfers.
   * 
   * @param {(MoneroTransferQuery|object)} query - configures the query (optional)
   * @param {string} query.address - get incoming transfers to a specific address in the wallet (optional)
   * @param {int} query.accountIndex - get incoming transfers to a specific account index (optional)
   * @param {int} query.subaddressIndex - get incoming transfers to a specific subaddress index (optional)
   * @param {int[]} query.subaddressIndices - get transfers destined for specific subaddress indices (optional)
   * @param {BigInteger} query.amount - amount being transferred (optional)
   * @param {MoneroTxQuery} query.txQuery - get transfers whose transaction meets this query (optional)
   * @return {MoneroIncomingTransfer[]} incoming transfers that meet the query
   */
  async getIncomingTransfers(query) {
    query = MoneroWallet._normalizeTransferQuery(query);
    if (query.isIncoming() === false) throw new MoneroError$1("Transfer query contradicts getting incoming transfers");
    query.setIsIncoming(true);
    return this.getTransfers(query);
  }
  
  /**
   * Get outgoing transfers.
   * 
   * @param {(MoneroTransferQuery|object)} query - configures the query (optional)
   * @param {string} query.address - get outgoing transfers from a specific address in the wallet (optional)
   * @param {int} query.accountIndex - get outgoing transfers from a specific account index (optional)
   * @param {int} query.subaddressIndex - get outgoing transfers from a specific subaddress index (optional)
   * @param {int[]} query.subaddressIndices - get outgoing transfers from specific subaddress indices (optional)
   * @param {BigInteger} query.amount - amount being transferred (optional)
   * @param {MoneroDestination[]} query.destinations - individual destinations of an outgoing transfer, which is local wallet data and NOT recoverable from the blockchain (optional)
   * @param {boolean} query.hasDestinations - get transfers that have destinations or not (optional)
   * @param {MoneroTxQuery} query.txQuery - get transfers whose transaction meets this query (optional)
   * @return {MoneroOutgoingTransfer[]} outgoing transfers that meet the query
   */
  async getOutgoingTransfers(query) {
    query = MoneroWallet._normalizeTransferQuery(query);
    if (query.isOutgoing() === false) throw new MoneroError$1("Transfer query contradicts getting outgoing transfers");
    query.setIsOutgoing(true);
    return this.getTransfers(query);
  }
  
  /**
   * <p>Get outputs created from previous transactions that belong to the wallet
   * (i.e. that the wallet can spend one time).  Outputs are part of
   * transactions which are stored in blocks on the blockchain.</p>
   * 
   * <p>Results can be filtered by passing a query object.  Outputs must
   * meet every criteria defined in the query in order to be returned.  All
   * filtering is optional and no filtering is applied when not defined.</p>
   * 
   * @param {(MoneroOutputQuery|object)} query - configures the query (optional)
   * @param {int} query.accountIndex - get outputs associated with a specific account index (optional)
   * @param {int} query.subaddressIndex - get outputs associated with a specific subaddress index (optional)
   * @param {int[]} query.subaddressIndices - get outputs associated with specific subaddress indices (optional)
   * @param {BigInteger} query.amount - get outputs with a specific amount (optional)
   * @param {BigInteger} query.minAmount - get outputs greater than or equal to a minimum amount (optional)
   * @param {BigInteger} query.maxAmount - get outputs less than or equal to a maximum amount (optional)
   * @param {boolean} query.isSpent - get outputs that are spent or not (optional)
   * @param {string|MoneroKeyImage} query.keyImage - get output with a key image or which matches fields defined in a MoneroKeyImage (optional)
   * @param {MoneroTxQuery} query.txQuery - get outputs whose transaction meets this filter (optional)
   * @return {MoneroOutputWallet[]} the queried outputs
   */
  async getOutputs(query) {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Export outputs in hex format.
   *
   * @param {boolean} all - export all outputs if true, else export the outputs since the last export
   * @return {string} outputs in hex format
   */
  async exportOutputs(all) {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Import outputs in hex format.
   * 
   * @param {string} outputsHex - outputs in hex format
   * @return {int} the number of outputs imported
   */
  async importOutputs(outputsHex) {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Export signed key images.
   * 
   * @param {boolean} all - export all key images if true, else export the key images since the last export
   * @return {MoneroKeyImage[]} the wallet's signed key images
   */
  async exportKeyImages(all) {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Import signed key images and verify their spent status.
   * 
   * @param {MoneroKeyImage[]} keyImages - images to import and verify (requires hex and signature)
   * @return {MoneroKeyImageImportResult} results of the import
   */
  async importKeyImages(keyImages) {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Get new key images from the last imported outputs.
   * 
   * @return {MoneroKeyImage[]} the key images from the last imported outputs
   */
  async getNewKeyImagesFromLastImport() {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Freeze an output.
   * 
   * @param {string} keyImage - key image of the output to freeze
   */
  async freezeOutput(keyImage) {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Thaw a frozen output.
   * 
   * @param {string} keyImage - key image of the output to thaw
   */
  async thawOutput(keyImage) {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Check if an output is frozen.
   * 
   * @param {string} keyImage - key image of the output to check if frozen
   * @return {boolean} true if the output is frozen, false otherwise
   */
  async isOutputFrozen(keyImage) {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Create a transaction to transfer funds from this wallet.
   * 
   * @param {MoneroTxConfig|object} config - configures the transaction to create (required)
   * @param {string} config.address - single destination address (required unless `destinations` provided)
   * @param {BigInteger|string} config.amount - single destination amount (required unless `destinations` provided)
   * @param {int} config.accountIndex - source account index to transfer funds from (required)
   * @param {int} config.subaddressIndex - source subaddress index to transfer funds from (optional)
   * @param {int[]} config.subaddressIndices - source subaddress indices to transfer funds from (optional)
   * @param {boolean} config.relay - relay the transaction to peers to commit to the blockchain (default false)
   * @param {MoneroTxPriority} config.priority - transaction priority (default MoneroTxPriority.NORMAL)
   * @param {MoneroDestination[]} config.destinations - addresses and amounts in a multi-destination tx (required unless `address` and `amount` provided)
   * @param {string} config.paymentId - transaction payment ID (optional)
   * @param {int} config.unlockHeight - minimum height for the transaction to unlock (default 0)
   * @return {MoneroTxWallet} the created transaction
   */
  async createTx(config) {
    config = MoneroWallet._normalizeCreateTxsConfig(config);
    if (config.getCanSplit() !== undefined) assert$1.equal(config.getCanSplit(), false, "Cannot split transactions using createTx(); use createTxs()");
    config.setCanSplit(false);
    return (await this.createTxs(config))[0];
  }
  
  /**
   * Create one or more transactions to transfer funds from this wallet.
   * 
   * @param {MoneroTxConfig|object} config - configures the transactions to create (required)
   * @param {string} config.address - single destination address (required unless `destinations` provided)
   * @param {BigInteger|string} config.amount - single destination amount (required unless `destinations` provided)
   * @param {int} config.accountIndex - source account index to transfer funds from (required)
   * @param {int} config.subaddressIndex - source subaddress index to transfer funds from (optional)
   * @param {int[]} config.subaddressIndices - source subaddress indices to transfer funds from (optional)
   * @param {boolean} config.relay - relay the transactions to peers to commit to the blockchain (default false)
   * @param {MoneroTxPriority} config.priority - transaction priority (default MoneroTxPriority.NORMAL)
   * @param {MoneroDestination[]} config.destinations - addresses and amounts in a multi-destination tx (required unless `address` and `amount` provided)
   * @param {string} config.paymentId - transaction payment ID (optional)
   * @param {int} config.unlockHeight - minimum height for the transactions to unlock (default 0)
   * @param {boolean} config.canSplit - allow funds to be transferred using multiple transactions (default true)
   * @return {MoneroTxWallet[]} the created transactions
   */
  async createTxs(config) {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Sweep an output by key image.
   * 
   * @param {MoneroTxConfig} config - configures the transaction to create (required)
   * @param {string} config.address - single destination address (required)
   * @param {string} config.keyImage - key image to sweep (required)
   * @param {boolean} config.relay - relay the transaction to peers to commit to the blockchain (default false)
   * @param {int} config.unlockHeight - minimum height for the transaction to unlock (default 0)
   * @param {MoneroTxPriority} config.priority - transaction priority (default MoneroTxPriority.NORMAL)
   * @return {MoneroTxWallet} the created transaction
   */
  async sweepOutput(config) {
    throw new MoneroError$1("Not supported");
  }

  /**
   * Sweep all unlocked funds according to the given configuration.
   * 
   * @param {MoneroTxConfig|object} config - configures the transactions to create (required)
   * @param {string} config.address - single destination address (required)
   * @param {int} config.accountIndex - source account index to sweep from (optional, defaults to all accounts)
   * @param {int} config.subaddressIndex - source subaddress index to sweep from (optional, defaults to all subaddresses)
   * @param {int[]} config.subaddressIndices - source subaddress indices to sweep from (optional)
   * @param {boolean} config.relay - relay the transactions to peers to commit to the blockchain (default false)
   * @param {MoneroTxPriority} config.priority - transaction priority (default MoneroTxPriority.NORMAL)
   * @param {int} config.unlockHeight - minimum height for the transactions to unlock (default 0)
   * @param {boolean} config.sweepEachSubaddress - sweep each subaddress individually if true (default false)
   * @return {MoneroTxWallet[]} the created transactions
   */
  async sweepUnlocked(config) {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * <p>Sweep all unmixable dust outputs back to the wallet to make them easier to spend and mix.</p>
   * 
   * <p>NOTE: Dust only exists pre RCT, so this method will throw "no dust to sweep" on new wallets.</p>
   * 
   * @param {boolean} relay - specifies if the resulting transaction should be relayed (default false)
   * @return {MoneroTxWallet[]} the created transactions
   */
  async sweepDust(relay) {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Relay a previously created transaction.
   * 
   * @param {(MoneroTxWallet|string)} txOrMetadata - transaction or its metadata to relay
   * @return {string} the hash of the relayed tx
   */
  async relayTx(txOrMetadata) {
    return (await this.relayTxs([txOrMetadata]))[0];
  }
  
  /**
   * Relay previously created transactions.
   * 
   * @param {(MoneroTxWallet[]|string[])} txsOrMetadatas - transactions or their metadata to relay
   * @return {string[]} the hashes of the relayed txs
   */
  async relayTxs(txsOrMetadatas) {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Describe a tx set from unsigned tx hex.
   * 
   * @param {string} unsignedTxHex - unsigned tx hex
   * @return {MoneroTxSet} the tx set containing structured transactions
   */
  async describeUnsignedTxSet(unsignedTxHex) {
    return this.describeTxSet(new MoneroTxSet().setUnsignedTxHex(unsignedTxHex));
  }
  
  /**
   * Describe a tx set from multisig tx hex.
   * 
   * @param {string} multisigTxHex - multisig tx hex
   * @return {MoneroTxSet} the tx set containing structured transactions
   */
  async describeMultisigTxSet(multisigTxHex) {
    return this.describeTxSet(new MoneroTxSet().setMultisigTxHex(multisigTxHex));
  }
  
  /**
   * Describe a tx set containing unsigned or multisig tx hex to a new tx set containing structured transactions.
   * 
   * @param {MoneroTxSet} txSet - a tx set containing unsigned or multisig tx hex
   * @return {MoneroTxSet} the tx set containing structured transactions
   */
  async describeTxSet(txSet) {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Sign unsigned transactions from a view-only wallet.
   * 
   * @param {string} unsignedTxHex - unsigned transaction hex from when the transactions were created
   * @return {string} the signed transaction hex
   */
  async signTxs(unsignedTxHex) {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Submit signed transactions from a view-only wallet.
   * 
   * @param {string} signedTxHex - signed transaction hex from signTxs()
   * @return {string[]} the resulting transaction hashes
   */
  async submitTxs(signedTxHex) {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Sign a message.
   * 
   * @param {string} message - the message to sign
   * @param {MoneroMessageSignatureType} signatureType - sign with spend key or view key (default spend key)
   * @param {int} accountIdx - the account index of the message signature (default 0)
   * @param {int} subaddressIdx - the subaddress index of the message signature (default 0)
   * @return {string} the signature
   */
  async signMessage(message, signatureType, accountIdx, subaddressIdx) {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Verify a signature on a message.
   * 
   * @param {string} message - signed message
   * @param {string} address - signing address
   * @param {string} signature - signature
   * @return {MoneroMessageSignatureResult} true if the signature is good, false otherwise
   */
  async verifyMessage(message, address, signature) {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Get a transaction's secret key from its hash.
   * 
   * @param {string} txHash - transaction's hash
   * @return {string} - transaction's secret key
   */
  async getTxKey(txHash) {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Check a transaction in the blockchain with its secret key.
   * 
   * @param {string} txHash - transaction to check
   * @param {string} txKey - transaction's secret key
   * @param {string} address - destination public address of the transaction
   * @return {MoneroCheckTx} the result of the check
   */
  async checkTxKey(txHash, txKey, address) {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Get a transaction signature to prove it.
   * 
   * @param {string} txHash - transaction to prove
   * @param {string} address - destination public address of the transaction
   * @param {string} message - message to include with the signature to further authenticate the proof (optional)
   * @return {string} the transaction signature
   */
  async getTxProof(txHash, address, message) {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Prove a transaction by checking its signature.
   * 
   * @param {string} txHash - transaction to prove
   * @param {string} address - destination public address of the transaction
   * @param {string} message - message included with the signature to further authenticate the proof (optional)
   * @param {string} signature - transaction signature to confirm
   * @return {MoneroCheckTx} the result of the check
   */
  async checkTxProof(txHash, address, message, signature) {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Generate a signature to prove a spend. Unlike proving a transaction, it does not require the destination public address.
   * 
   * @param {string} txHash - transaction to prove
   * @param {string} message - message to include with the signature to further authenticate the proof (optional)
   * @return {string} the transaction signature
   */
  async getSpendProof(txHash, message) {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Prove a spend using a signature. Unlike proving a transaction, it does not require the destination public address.
   * 
   * @param {string} txHash - transaction to prove
   * @param {string} message - message included with the signature to further authenticate the proof (optional)
   * @param {string} signature - transaction signature to confirm
   * @return {boolean} true if the signature is good, false otherwise
   */
  async checkSpendProof(txHash, message, signature) {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Generate a signature to prove the entire balance of the wallet.
   * 
   * @param message - message included with the signature to further authenticate the proof (optional)
   * @return the reserve proof signature
   */
  async getReserveProofWallet(message) {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Generate a signature to prove an available amount in an account.
   * 
   * @param {int} accountIdx - account to prove ownership of the amount
   * @param {BigInteger} amount - minimum amount to prove as available in the account
   * @param {string} message - message to include with the signature to further authenticate the proof (optional)
   * @return {string} the reserve proof signature
   */
  async getReserveProofAccount(accountIdx, amount, message) {
    throw new MoneroError$1("Not supported");
  }

  /**
   * Proves a wallet has a disposable reserve using a signature.
   * 
   * @param {string} address - public wallet address
   * @param {string} message - message included with the signature to further authenticate the proof (optional)
   * @param {string} signature - reserve proof signature to check
   * @return {MoneroCheckReserve} the result of checking the signature proof
   */
  async checkReserveProof(address, message, signature) {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Get a transaction note.
   * 
   * @param {string} txHash - transaction to get the note of
   * @return {string} the tx note
   */
  async getTxNote(txHash) {
    return (await this.getTxNotes([txHash]))[0];
  }
  
  /**
   * Get notes for multiple transactions.
   * 
   * @param {string[]} txHashes - hashes of the transactions to get notes for
   * @return {string[]} notes for the transactions
   */
  async getTxNotes(txHashes) {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Set a note for a specific transaction.
   * 
   * @param {string} txHash - hash of the transaction to set a note for
   * @param {string} note - the transaction note
   */
  async setTxNote(txHash, note) {
    await this.setTxNotes([txHash], [note]);
  }
  
  /**
   * Set notes for multiple transactions.
   * 
   * @param {string[]} txHashes - transactions to set notes for
   * @param {string[]} notes - notes to set for the transactions
   */
  async setTxNotes(txHashes, notes) {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Get address book entries.
   * 
   * @param {int[]} entryIndices - indices of the entries to get
   * @return {MoneroAddressBookEntry[]} the address book entries
   */
  async getAddressBookEntries(entryIndices) {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Add an address book entry.
   * 
   * @param {string} address - entry address
   * @param {string} description - entry description (optional)
   * @return {int} the index of the added entry
   */
  async addAddressBookEntry(address, description) {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Edit an address book entry.
   * 
   * @param {number} index - index of the address book entry to edit
   * @param {boolean} setAddress - specifies if the address should be updated
   * @param {string} address - updated address
   * @param {boolean} setDescription - specifies if the description should be updated
   * @param {string} description - updated description
   */
  async editAddressBookEntry(index, setAddress, address, setDescription, description) {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Delete an address book entry.
   * 
   * @param {int} entryIdx - index of the entry to delete
   */
  async deleteAddressBookEntry(entryIdx) {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Tag accounts.
   * 
   * @param {string} tag - tag to apply to the specified accounts
   * @param {int[]} accountIndices - indices of the accounts to tag
   */
  async tagAccounts(tag, accountIndices) {
    throw new MoneroError$1("Not supported");
  }

  /**
   * Untag accounts.
   * 
   * @param {int[]} accountIndices - indices of the accounts to untag
   */
  async untagAccounts(accountIndices) {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Return all account tags.
   * 
   * @return {MoneroAccountTag[]} the wallet's account tags
   */
  async getAccountTags() {
    throw new MoneroError$1("Not supported");
  }

  /**
   * Sets a human-readable description for a tag.
   * 
   * @param {string} tag - tag to set a description for
   * @param {string} label - label to set for the tag
   */
  async setAccountTagLabel(tag, label) {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Creates a payment URI from a send configuration.
   * 
   * @param {MoneroTxConfig} config - specifies configuration for a potential tx
   * @return {string} the payment uri
   */
  async getPaymentUri(config) {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Parses a payment URI to a tx config.
   * 
   * @param {string} uri - payment uri to parse
   * @return {MoneroTxConfig} the send configuration parsed from the uri
   */
  async parsePaymentUri(uri) {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Get an attribute.
   * 
   * @param {string} key - attribute to get the value of
   * @return {string} the attribute's value
   */
  async getAttribute(key) {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Set an arbitrary attribute.
   * 
   * @param {string} key - attribute key
   * @param {string} val - attribute value
   */
  async setAttribute(key, val) {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Start mining.
   * 
   * @param {int} numThreads - number of threads created for mining (optional)
   * @param {boolean} backgroundMining - specifies if mining should occur in the background (optional)
   * @param {boolean} ignoreBattery - specifies if the battery should be ignored for mining (optional)
   */
  async startMining(numThreads, backgroundMining, ignoreBattery) {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Stop mining.
   */
  async stopMining() {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Indicates if importing multisig data is needed for returning a correct balance.
   * 
   * @return {boolean} true if importing multisig data is needed for returning a correct balance, false otherwise
   */
  async isMultisigImportNeeded() {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Indicates if this wallet is a multisig wallet.
   * 
   * @return {boolean} true if this is a multisig wallet, false otherwise
   */
  async isMultisig() {
    return (await this.getMultisigInfo()).isMultisig();
  }
  
  /**
   * Get multisig info about this wallet.
   * 
   * @return {MoneroMultisigInfo} multisig info about this wallet
   */
  async getMultisigInfo() {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Get multisig info as hex to share with participants to begin creating a
   * multisig wallet.
   * 
   * @return {string} this wallet's multisig hex to share with participants
   */
  async prepareMultisig() {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Make this wallet multisig by importing multisig hex from participants.
   * 
   * @param {String[]} multisigHexes - multisig hex from each participant
   * @param {int} threshold - number of signatures needed to sign transfers
   * @param {string} password - wallet password
   * @return {string} this wallet's multisig hex to share with participants
   */
  async makeMultisig(multisigHexes, threshold, password) {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Exchange multisig hex with participants in a M/N multisig wallet.
   * 
   * This process must be repeated with participants exactly N-M times.
   * 
   * @param {string[]} multisigHexes are multisig hex from each participant
   * @param {string} password - wallet's password // TODO monero-project: redundant? wallet is created with password
   * @return {MoneroMultisigInitResult} the result which has the multisig's address xor this wallet's multisig hex to share with participants iff not done
   */
  async exchangeMultisigKeys(multisigHexes, password) {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Export this wallet's multisig info as hex for other participants.
   * 
   * @return {string} this wallet's multisig info as hex for other participants
   */
  async exportMultisigHex() {
    throw new MoneroError$1("Not supported?");
  }
  
  /**
   * Import multisig info as hex from other participants.
   * 
   * @param {string[]} multisigHexes - multisig hex from each participant
   * @return {int} the number of outputs signed with the given multisig hex
   */
  async importMultisigHex(multisigHexes) {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Sign multisig transactions from a multisig wallet.
   * 
   * @param {string} multisigTxHex - unsigned multisig transactions as hex
   * @return {MoneroMultisigSignResult} the result of signing the multisig transactions
   */
  async signMultisigTxHex(multisigTxHex) {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Submit signed multisig transactions from a multisig wallet.
   * 
   * @param {string} signedMultisigTxHex - signed multisig hex returned from signMultisigTxHex()
   * @return {string[]} the resulting transaction hashes
   */
  async submitMultisigTxHex(signedMultisigTxHex) {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Change the wallet password.
   * 
   * @param {string} oldPassword - the wallet's old password
   * @param {string} newPassword - the wallet's new password
   */
  async changePassword(oldPassword, newPassword) {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Save the wallet at its current path.
   */
  save() {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Optionally save then close the wallet.
   *
   * @param {boolean} save - specifies if the wallet should be saved before being closed (default false)
   */
  async close(save) {
    throw new MoneroError$1("Not supported");
  }
  
  /**
   * Indicates if this wallet is closed or not.
   * 
   * @return {boolean} true if the wallet is closed, false otherwise
   */
  async isClosed() {
    throw new MoneroError$1("Not supported");
  }
  
  // -------------------------------- PRIVATE ---------------------------------
  
  static _normalizeTxQuery(query) {
    if (query instanceof MoneroTxQuery$1) query = query.copy();
    else if (Array.isArray(query)) query = new MoneroTxQuery$1().setHashes(query);
    else {
      query = Object.assign({}, query);
      query = new MoneroTxQuery$1(query);
    }
    if (query.getBlock() === undefined) query.setBlock(new MoneroBlock().setTxs([query]));
    if (query.getInputQuery()) query.getInputQuery().setTxQuery(query);
    if (query.getOutputQuery()) query.getOutputQuery().setTxQuery(query);
    return query;
  }
  
  static _normalizeTransferQuery(query) {
    if (query === undefined) query = new MoneroTransferQuery();
    else if (query instanceof MoneroTransferQuery) {
      if (query.getTxQuery() === undefined) query = query.copy();
      else {
        let txQuery = query.getTxQuery().copy();
        if (query.getTxQuery().getTransferQuery() === query) query = txQuery.getTransferQuery();
        else {
          assert$1.equal(query.getTxQuery().getTransferQuery(), undefined, "Transfer query's tx query must be circular reference or null");
          query = query.copy();
          query.setTxQuery(txQuery);
        }
      }
    } else {
      query = Object.assign({}, query);
      query = new MoneroTransferQuery(query);
    }
    if (query.getTxQuery() === undefined) query.setTxQuery(new MoneroTxQuery$1());
    query.getTxQuery().setTransferQuery(query);
    if (query.getTxQuery().getBlock() === undefined) query.getTxQuery().setBlock(new MoneroBlock().setTxs([query.getTxQuery()]));
    return query;
  }
  
  static _normalizeOutputQuery(query) {
    if (query === undefined) query = new MoneroOutputQuery();
    else if (query instanceof MoneroOutputQuery) {
      if (query.getTxQuery() === undefined) query = query.copy();
      else {
        let txQuery = query.getTxQuery().copy();
        if (query.getTxQuery().getOutputQuery() === query) query = txQuery.getOutputQuery();
        else {
          assert$1.equal(query.getTxQuery().getOutputQuery(), undefined, "Output query's tx query must be circular reference or null");
          query = query.copy();
          query.setTxQuery(txQuery);
        }
      }
    } else {
      query = Object.assign({}, query);
      query = new MoneroOutputQuery(query);
    }
    if (query.getTxQuery() === undefined) query.setTxQuery(new MoneroTxQuery$1());
    query.getTxQuery().setOutputQuery(query);
    if (query.getTxQuery().getBlock() === undefined) query.getTxQuery().setBlock(new MoneroBlock().setTxs([query.getTxQuery()]));
    return query;
  }
  
  static _normalizeCreateTxsConfig(config) {
    if (config === undefined || !(config instanceof Object)) throw new MoneroError$1("Must provide MoneroTxConfig or equivalent JS object");
    config = new MoneroTxConfig(config);
    assert$1(config.getDestinations() && config.getDestinations().length > 0, "Must provide destinations");
    assert$1.equal(config.getSweepEachSubaddress(), undefined);
    assert$1.equal(config.getBelowAmount(), undefined);
    return config;
  }
  
  static _normalizeSweepOutputConfig(config) {
    if (config === undefined || !(config instanceof Object)) throw new MoneroError$1("Must provide MoneroTxConfig or equivalent JS object");
    config = new MoneroTxConfig(config);
    assert$1.equal(config.getSweepEachSubaddress(), undefined);
    assert$1.equal(config.getBelowAmount(), undefined);
    assert$1.equal(config.getCanSplit(), undefined, "Cannot split transactions when sweeping an output");
    if (!config.getDestinations() || config.getDestinations().length !== 1 || !config.getDestinations()[0].getAddress()) throw new MoneroError$1("Must provide exactly one destination address to sweep output to");
    return config;
  }
  
  static _normalizeSweepUnlockedConfig(config) {
    if (config === undefined || !(config instanceof Object)) throw new MoneroError$1("Must provide MoneroTxConfig or equivalent JS object");
    config = new MoneroTxConfig(config);
    if (config.getDestinations() === undefined || config.getDestinations().length != 1) throw new MoneroError$1("Must provide exactly one destination to sweep to");
    if (config.getDestinations()[0].getAddress() === undefined) throw new MoneroError$1("Must provide destination address to sweep to");
    if (config.getDestinations()[0].getAmount() !== undefined) throw new MoneroError$1("Cannot provide amount in sweep config");
    if (config.getKeyImage() !== undefined) throw new MoneroError$1("Key image defined; use sweepOutput() to sweep an output by its key image");
    if (config.getSubaddressIndices() !== undefined && config.getSubaddressIndices().length === 0) config.setSubaddressIndices(undefined);
    if (config.getAccountIndex() === undefined && config.getSubaddressIndices() !== undefined) throw new MoneroError$1("Must provide account index if subaddress indices are provided");
    return config;
  }
}

MoneroWallet.DEFAULT_LANGUAGE = "English";

var MoneroWallet_1 = MoneroWallet;

var MoneroDaemonRpc_1;
var hasRequiredMoneroDaemonRpc;

function requireMoneroDaemonRpc () {
	if (hasRequiredMoneroDaemonRpc) return MoneroDaemonRpc_1;
	hasRequiredMoneroDaemonRpc = 1;
	const assert = require$$0;
	const BigInteger = biginteger.BigInteger;
	const GenUtils = GenUtils_1;
	const LibraryUtils = requireLibraryUtils();
	const TaskLooper = TaskLooper_1;
	const MoneroAltChain = MoneroAltChain_1;
	const MoneroBan = MoneroBan_1;
	const MoneroBlock = MoneroBlock_1;
	const MoneroBlockHeader = MoneroBlockHeader_1;
	const MoneroBlockTemplate = MoneroBlockTemplate_1;
	const MoneroDaemon = MoneroDaemon_1;
	const MoneroDaemonInfo = MoneroDaemonInfo_1;
	const MoneroDaemonListener = MoneroDaemonListener_1;
	const MoneroDaemonSyncInfo = MoneroDaemonSyncInfo_1;
	const MoneroError = MoneroError_1;
	const MoneroHardForkInfo = MoneroHardForkInfo_1;
	const MoneroKeyImage = MoneroKeyImage_1;
	const MoneroMinerTxSum = MoneroMinerTxSum_1;
	const MoneroMiningStatus = MoneroMiningStatus_1;
	const MoneroNetworkType = MoneroNetworkType_1;
	const MoneroOutput = MoneroOutput_1;
	const MoneroOutputHistogramEntry = MoneroOutputHistogramEntry_1;
	const MoneroPeer = MoneroPeer_1;
	const MoneroRpcConnection = requireMoneroRpcConnection();
	const MoneroSubmitTxResult = MoneroSubmitTxResult_1;
	const MoneroTx = MoneroTx_1;
	const MoneroTxPoolStats = MoneroTxPoolStats_1;
	const MoneroUtils = requireMoneroUtils();
	const MoneroVersion = MoneroVersion_1;

	/**
	 * Copyright (c) woodser
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in all
	 * copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	 * SOFTWARE.
	 */

	/**
	 * Implements a MoneroDaemon as a client of monerod.
	 * 
	 * @implements {MoneroDaemon}
	 * @hideconstructor
	 */
	class MoneroDaemonRpc extends MoneroDaemon {
	  
	  /**
	   * <p>Construct a daemon RPC client (for internal use).<p>
	   * 
	   * @param {string|object|MoneroRpcConnection} uriOrConfig - uri of monerod or JS config object or MoneroRpcConnection
	   * @param {string} uriOrConfig.uri - uri of monerod
	   * @param {string} uriOrConfig.username - username to authenticate with monerod (optional)
	   * @param {string} uriOrConfig.password - password to authenticate with monerod (optional)
	   * @param {boolean} uriOrConfig.rejectUnauthorized - rejects self-signed certificates if true (default true)
	   * @param {number} uriOrConfig.pollInterval - poll interval to query for updates in ms (default 5000)
	   * @param {string} username - username to authenticate with monerod (optional)
	   * @param {string} password - password to authenticate with monerod (optional)
	   * @param {boolean} rejectUnauthorized - rejects self-signed certificates if true (default true)
	   * @param {number} pollInterval - poll interval to query for updates in ms (default 5000)
	   * @param {boolean} proxyToWorker - runs the daemon client in a worker if true (default true)
	   */
	  constructor(uriOrConfig, username, password, rejectUnauthorized, pollInterval, proxyToWorker) {
	    super();
	    if (GenUtils.isArray(uriOrConfig)) throw new Error("Use monerojs.connectToDaemonRpc(...) to use terminal parameters");
	    this.config = MoneroDaemonRpc._normalizeConfig(uriOrConfig, username, password, rejectUnauthorized, pollInterval, proxyToWorker);
	    if (this.config.proxyToWorker) throw new Error("Use monerojs.connectToDaemonRpc(...) to proxy to worker");
	    let rpcConfig = Object.assign({}, this.config);
	    delete rpcConfig.proxyToWorker;
	    delete rpcConfig.pollInterval;
	    this.rpc = new MoneroRpcConnection(rpcConfig);
	    this.listeners = [];      // block listeners
	    this.cachedHeaders = {};  // cached headers for fetching blocks in bound chunks
	  }
	  
	  /**
	   * <p>Create a client connected to monerod (for internal use).</p>
	   * 
	   * @param {string|string[]|object|MoneroRpcConnection} uriOrConfig - uri of monerod or terminal parameters or JS config object or MoneroRpcConnection
	   * @param {string} uriOrConfig.uri - uri of monerod
	   * @param {string} uriOrConfig.username - username to authenticate with monerod (optional)
	   * @param {string} uriOrConfig.password - password to authenticate with monerod (optional)
	   * @param {boolean} uriOrConfig.rejectUnauthorized - rejects self-signed certificates if true (default true)
	   * @param {number} uriOrConfig.pollInterval - poll interval to query for updates in ms (default 5000)
	   * @param {boolean} uriOrConfig.proxyToWorker - run the daemon client in a worker if true (default true)
	   * @param {string} username - username to authenticate with monerod (optional)
	   * @param {string} password - password to authenticate with monerod (optional)
	   * @param {boolean} rejectUnauthorized - rejects self-signed certificates if true (default true)
	   * @param {number} pollInterval - poll interval to query for updates in ms (default 5000)
	   * @param {boolean} proxyToWorker - runs the daemon client in a worker if true (default true)
	   * @return {MoneroDaemonRpc} the daemon RPC client
	   */
	  static async _connectToDaemonRpc(uriOrConfig, username, password, rejectUnauthorized, pollInterval, proxyToWorker) {
	    if (GenUtils.isArray(uriOrConfig)) return MoneroDaemonRpc._startMonerodProcess(uriOrConfig, rejectUnauthorized, pollInterval, proxyToWorker); // handle array as terminal command
	    let config = MoneroDaemonRpc._normalizeConfig(uriOrConfig, username, password, rejectUnauthorized, pollInterval, proxyToWorker);
	    if (config.proxyToWorker) return MoneroDaemonRpcProxy.connect(config);
	    else return new MoneroDaemonRpc(config);
	  }
	  
	  static async _startMonerodProcess(cmd, rejectUnauthorized, pollInterval, proxyToWorker) {
	    assert(GenUtils.isArray(cmd), "Must provide string array with command line parameters");
	    
	    // start process
	    this.process = require$$29.spawn(cmd[0], cmd.slice(1), {});
	    this.process.stdout.setEncoding('utf8');
	    this.process.stderr.setEncoding('utf8');
	    
	    // return promise which resolves after starting monerod
	    let uri;
	    let that = this;
	    let output = "";
	    return new Promise(function(resolve, reject) {
	      
	      // handle stdout
	      that.process.stdout.on('data', async function(data) {
	        let line = data.toString();
	        LibraryUtils.log(2, line);
	        output += line + '\n'; // capture output in case of error
	        
	        // extract uri from e.g. "I Binding on 127.0.0.1 (IPv4):38085"
	        let uriLineContains = "Binding on ";
	        let uriLineContainsIdx = line.indexOf(uriLineContains);
	        if (uriLineContainsIdx >= 0) {
	          let host = line.substring(uriLineContainsIdx + uriLineContains.length, line.lastIndexOf(' '));
	          let unformattedLine = line.replace(/\u001b\[.*?m/g, '').trim(); // remove color formatting
	          let port = unformattedLine.substring(unformattedLine.lastIndexOf(':') + 1);
	          let sslIdx = cmd.indexOf("--rpc-ssl");
	          let sslEnabled = sslIdx >= 0 ? "enabled" == cmd[sslIdx + 1].toLowerCase() : false;
	          uri = (sslEnabled ? "https" : "http") + "://" + host + ":" + port;
	        }
	        
	        // read success message
	        if (line.indexOf("core RPC server started ok") >= 0) {
	          
	          // get username and password from params
	          let userPassIdx = cmd.indexOf("--rpc-login");
	          let userPass = userPassIdx >= 0 ? cmd[userPassIdx + 1] : undefined;
	          let username = userPass === undefined ? undefined : userPass.substring(0, userPass.indexOf(':'));
	          let password = userPass === undefined ? undefined : userPass.substring(userPass.indexOf(':') + 1);
	          
	          // create client connected to internal process
	          let daemon = await that._connectToDaemonRpc(uri, username, password, rejectUnauthorized, pollInterval, proxyToWorker);
	          daemon.process = that.process;
	          
	          // resolve promise with client connected to internal process 
	          this.isResolved = true;
	          resolve(daemon);
	        }
	      });
	      
	      // handle stderr
	      that.process.stderr.on('data', function(data) {
	        if (LibraryUtils.getLogLevel() >= 2) console.error(data);
	      });
	      
	      // handle exit
	      that.process.on("exit", function(code) {
	        if (!this.isResolved) reject(new Error("monerod process terminated with exit code " + code + (output ? ":\n\n" + output : "")));
	      });
	      
	      // handle error
	      that.process.on("error", function(err) {
	        if (err.message.indexOf("ENOENT") >= 0) reject(new Error("monerod does not exist at path '" + cmd[0] + "'"));
	        if (!this.isResolved) reject(err);
	      });
	      
	      // handle uncaught exception
	      that.process.on("uncaughtException", function(err, origin) {
	        console.error("Uncaught exception in monerod process: " + err.message);
	        console.error(origin);
	        reject(err);
	      });
	    });
	  }
	  
	  /**
	   * Get the internal process running monerod.
	   * 
	   * @return the process running monerod, undefined if not created from new process
	   */
	  getProcess() {
	    return this.process;
	  }
	  
	  /**
	   * Stop the internal process running monerod, if applicable.
	   */
	  async stopProcess() {
	    if (this.process === undefined) throw new MoneroError("MoneroDaemonRpc instance not created from new process");
	    let listenersCopy = GenUtils.copyArray(this.getListeners());
	    for (let listener of listenersCopy) await this.removeListener(listener);
	    return GenUtils.killProcess(this.process);
	  }
	  
	  async addListener(listener) {
	    assert(listener instanceof MoneroDaemonListener, "Listener must be instance of MoneroDaemonListener");
	    this.listeners.push(listener);
	    this._refreshListening();
	  }
	  
	  async removeListener(listener) {
	    assert(listener instanceof MoneroDaemonListener, "Listener must be instance of MoneroDaemonListener");
	    let idx = this.listeners.indexOf(listener);
	    if (idx > -1) this.listeners.splice(idx, 1);
	    else throw new MoneroError("Listener is not registered with daemon");
	    this._refreshListening();
	  }
	  
	  getListeners() {
	    return this.listeners;
	  }
	  
	  /**
	   * Get the daemon's RPC connection.
	   * 
	   * @return {MoneroRpcConnection} the daemon's rpc connection
	   */
	  async getRpcConnection() {
	    return this.rpc;
	  }
	  
	  async isConnected() {
	    try {
	      await this.getVersion();
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }
	  
	  async getVersion() {
	    let resp = await this.rpc.sendJsonRequest("get_version");
	    MoneroDaemonRpc._checkResponseStatus(resp.result);
	    return new MoneroVersion(resp.result.version, resp.result.release);
	  }
	  
	  async isTrusted() {
	    let resp = await this.rpc.sendPathRequest("get_height");
	    MoneroDaemonRpc._checkResponseStatus(resp);
	    return !resp.untrusted;
	  }
	  
	  async getHeight() {
	    let resp = await this.rpc.sendJsonRequest("get_block_count");
	    MoneroDaemonRpc._checkResponseStatus(resp.result);
	    return resp.result.count;
	  }
	  
	  async getBlockHash(height) {
	    return (await this.rpc.sendJsonRequest("on_get_block_hash", [height])).result;  // TODO monero-wallet-rpc: no status returned
	  }
	  
	  async getBlockTemplate(walletAddress, reserveSize) {
	    assert(walletAddress && typeof walletAddress === "string", "Must specify wallet address to be mined to");
	    let resp = await this.rpc.sendJsonRequest("get_block_template", {wallet_address: walletAddress, reserve_size: reserveSize});
	    MoneroDaemonRpc._checkResponseStatus(resp.result);
	    return MoneroDaemonRpc._convertRpcBlockTemplate(resp.result);
	  }
	  
	  async getLastBlockHeader() {
	    let resp = await this.rpc.sendJsonRequest("get_last_block_header");
	    MoneroDaemonRpc._checkResponseStatus(resp.result);
	    return MoneroDaemonRpc._convertRpcBlockHeader(resp.result.block_header);
	  }
	  
	  async getBlockHeaderByHash(blockHash) {
	    let resp = await this.rpc.sendJsonRequest("get_block_header_by_hash", {hash: blockHash});
	    MoneroDaemonRpc._checkResponseStatus(resp.result);
	    return MoneroDaemonRpc._convertRpcBlockHeader(resp.result.block_header);
	  }
	  
	  async getBlockHeaderByHeight(height) {
	    let resp = await this.rpc.sendJsonRequest("get_block_header_by_height", {height: height});
	    MoneroDaemonRpc._checkResponseStatus(resp.result);
	    return MoneroDaemonRpc._convertRpcBlockHeader(resp.result.block_header);
	  }
	  
	  async getBlockHeadersByRange(startHeight, endHeight) {
	    
	    // fetch block headers
	    let resp = await this.rpc.sendJsonRequest("get_block_headers_range", {
	      start_height: startHeight,
	      end_height: endHeight
	    });
	    MoneroDaemonRpc._checkResponseStatus(resp.result);
	    
	    // build headers
	    let headers = [];
	    for (let rpcHeader of resp.result.headers) {
	      headers.push(MoneroDaemonRpc._convertRpcBlockHeader(rpcHeader));
	    }
	    return headers;
	  }
	  
	  async getBlockByHash(blockHash) {
	    let resp = await this.rpc.sendJsonRequest("get_block", {hash: blockHash});
	    MoneroDaemonRpc._checkResponseStatus(resp.result);
	    return MoneroDaemonRpc._convertRpcBlock(resp.result);
	  }
	  
	  async getBlockByHeight(height) {
	    let resp = await this.rpc.sendJsonRequest("get_block", {height: height});
	    MoneroDaemonRpc._checkResponseStatus(resp.result);
	    return MoneroDaemonRpc._convertRpcBlock(resp.result);
	  }
	  
	  async getBlocksByHeight(heights) {
	    
	    // fetch blocks in binary
	    let respBin = await this.rpc.sendBinaryRequest("get_blocks_by_height.bin", {heights: heights});
	    
	    // convert binary blocks to json
	    let rpcBlocks = await MoneroUtils.binaryBlocksToJson(respBin);
	    MoneroDaemonRpc._checkResponseStatus(rpcBlocks);
	    
	    // build blocks with transactions
	    assert.equal(rpcBlocks.txs.length, rpcBlocks.blocks.length);    
	    let blocks = [];
	    for (let blockIdx = 0; blockIdx < rpcBlocks.blocks.length; blockIdx++) {
	      
	      // build block
	      let block = MoneroDaemonRpc._convertRpcBlock(rpcBlocks.blocks[blockIdx]);
	      block.setHeight(heights[blockIdx]);
	      blocks.push(block);
	      
	      // build transactions
	      let txs = [];
	      for (let txIdx = 0; txIdx < rpcBlocks.txs[blockIdx].length; txIdx++) {
	        let tx = new MoneroTx();
	        txs.push(tx);
	        tx.setHash(rpcBlocks.blocks[blockIdx].tx_hashes[txIdx]);
	        tx.setIsConfirmed(true);
	        tx.setInTxPool(false);
	        tx.setIsMinerTx(false);
	        tx.setRelay(true);
	        tx.setIsRelayed(true);
	        tx.setIsFailed(false);
	        tx.setIsDoubleSpend(false);
	        MoneroDaemonRpc._convertRpcTx(rpcBlocks.txs[blockIdx][txIdx], tx);
	      }
	      
	      // merge into one block
	      block.setTxs([]);
	      for (let tx of txs) {
	        if (tx.getBlock()) block.merge(tx.getBlock());
	        else block.getTxs().push(tx.setBlock(block));
	      }
	    }
	    
	    return blocks;
	  }
	  
	  async getBlocksByRange(startHeight, endHeight) {
	    if (startHeight === undefined) startHeight = 0;
	    if (endHeight === undefined) endHeight = await this.getHeight() - 1;
	    let heights = [];
	    for (let height = startHeight; height <= endHeight; height++) heights.push(height);
	    return await this.getBlocksByHeight(heights);
	  }
	  
	  async getBlocksByRangeChunked(startHeight, endHeight, maxChunkSize) {
	    if (startHeight === undefined) startHeight = 0;
	    if (endHeight === undefined) endHeight = await this.getHeight() - 1;
	    let lastHeight = startHeight - 1;
	    let blocks = [];
	    while (lastHeight < endHeight) {
	      for (let block of await this._getMaxBlocks(lastHeight + 1, endHeight, maxChunkSize)) {
	        blocks.push(block);
	      }
	      lastHeight = blocks[blocks.length - 1].getHeight();
	    }
	    return blocks;
	  }
	  
	  async getTxs(txHashes, prune) {
	        
	    // validate input
	    assert(Array.isArray(txHashes) && txHashes.length > 0, "Must provide an array of transaction hashes");
	    assert(prune === undefined || typeof prune === "boolean", "Prune must be a boolean or undefined");
	        
	    // fetch transactions
	    let resp = await this.rpc.sendPathRequest("get_transactions", {
	      txs_hashes: txHashes,
	      decode_as_json: true,
	      prune: prune
	    });
	    try {
	      MoneroDaemonRpc._checkResponseStatus(resp);
	    } catch (e) {
	      if (e.message.indexOf("Failed to parse hex representation of transaction hash") >= 0) throw new MoneroError("Invalid transaction hash");
	      throw e;
	    }
	        
	    // build transaction models
	    let txs = [];
	    if (resp.txs) {
	      for (let txIdx = 0; txIdx < resp.txs.length; txIdx++) {
	        let tx = new MoneroTx();
	        tx.setIsMinerTx(false);
	        txs.push(MoneroDaemonRpc._convertRpcTx(resp.txs[txIdx], tx));
	      }
	    }
	    
	    // fetch unconfirmed txs from pool and merge additional fields  // TODO monerod: merge rpc calls so this isn't necessary?
	    let poolTxs = await this.getTxPool();
	    for (let tx of txs) {
	      for (let poolTx of poolTxs) {
	        if (tx.getHash() === poolTx.getHash()) tx.merge(poolTx);
	      }
	    }
	    
	    return txs;
	  }
	  
	  async getTxHexes(txHashes, prune) {
	    let hexes = [];
	    for (let tx of await this.getTxs(txHashes, prune)) hexes.push(prune ? tx.getPrunedHex() : tx.getFullHex());
	    return hexes;
	  }
	  
	  async getMinerTxSum(height, numBlocks) {
	    if (height === undefined) height = 0;
	    else assert(height >= 0, "Height must be an integer >= 0");
	    if (numBlocks === undefined) numBlocks = await this.getHeight();
	    else assert(numBlocks >= 0, "Count must be an integer >= 0");
	    let resp = await this.rpc.sendJsonRequest("get_coinbase_tx_sum", {height: height, count: numBlocks});
	    MoneroDaemonRpc._checkResponseStatus(resp.result);
	    let txSum = new MoneroMinerTxSum();
	    txSum.setEmissionSum(new BigInteger(resp.result.emission_amount));
	    txSum.setFeeSum(new BigInteger(resp.result.fee_amount));
	    return txSum;
	  }
	  
	  async getFeeEstimate(graceBlocks) {
	    let resp = await this.rpc.sendJsonRequest("get_fee_estimate", {grace_blocks: graceBlocks});
	    MoneroDaemonRpc._checkResponseStatus(resp.result);
	    return new BigInteger(resp.result.fee);
	  }
	  
	  async submitTxHex(txHex, doNotRelay) {
	    let resp = await this.rpc.sendPathRequest("send_raw_transaction", {tx_as_hex: txHex, do_not_relay: doNotRelay});
	    let result = MoneroDaemonRpc._convertRpcSubmitTxResult(resp);
	    
	    // set isGood based on status
	    try {
	      MoneroDaemonRpc._checkResponseStatus(resp); 
	      result.setIsGood(true);
	    } catch(e) {
	      result.setIsGood(false);
	    }
	    return result;
	  }
	  
	  async relayTxsByHash(txHashes) {
	    let resp = await this.rpc.sendJsonRequest("relay_tx", {txids: txHashes});
	    MoneroDaemonRpc._checkResponseStatus(resp.result);
	  }
	  
	  async getTxPool() {
	    
	    // send rpc request
	    let resp = await this.rpc.sendPathRequest("get_transaction_pool");
	    MoneroDaemonRpc._checkResponseStatus(resp);
	    
	    // build txs
	    let txs = [];
	    if (resp.transactions) {
	      for (let rpcTx of resp.transactions) {
	        let tx = new MoneroTx();
	        txs.push(tx);
	        tx.setIsConfirmed(false);
	        tx.setIsMinerTx(false);
	        tx.setInTxPool(true);
	        tx.setNumConfirmations(0);
	        MoneroDaemonRpc._convertRpcTx(rpcTx, tx);
	      }
	    }
	    
	    return txs;
	  }
	  
	  async getTxPoolHashes() {
	    throw new MoneroError("Not implemented");
	  }
	  
	  async getTxPoolBacklog() {
	    throw new MoneroError("Not implemented");
	  }

	  async getTxPoolStats() {
	    throw new MoneroError("Response contains field 'histo' which is binary'");
	  }
	  
	  async flushTxPool(hashes) {
	    if (hashes) hashes = GenUtils.listify(hashes);
	    let resp = await this.rpc.sendJsonRequest("flush_txpool", {txids: hashes});
	    MoneroDaemonRpc._checkResponseStatus(resp.result);
	  }
	  
	  async getKeyImageSpentStatuses(keyImages) {
	    if (keyImages === undefined || keyImages.length === 0) throw new MoneroError("Must provide key images to check the status of");
	    let resp = await this.rpc.sendPathRequest("is_key_image_spent", {key_images: keyImages});
	    MoneroDaemonRpc._checkResponseStatus(resp);
	    return resp.spent_status;
	  }
	  
	  async getOutputHistogram(amounts, minCount, maxCount, isUnlocked, recentCutoff) {
	    
	    // send rpc request
	    let resp = await this.rpc.sendJsonRequest("get_output_histogram", {
	      amounts: amounts,
	      min_count: minCount,
	      max_count: maxCount,
	      unlocked: isUnlocked,
	      recent_cutoff: recentCutoff
	    });
	    MoneroDaemonRpc._checkResponseStatus(resp.result);
	    
	    // build histogram entries from response
	    let entries = [];
	    if (!resp.result.histogram) return entries;
	    for (let rpcEntry of resp.result.histogram) {
	      entries.push(MoneroDaemonRpc._convertRpcOutputHistogramEntry(rpcEntry));
	    }
	    return entries;
	  }
	  
	  async getOutputDistribution(amounts, cumulative, startHeight, endHeight) {
	    throw new MoneroError("Not implemented (response 'distribution' field is binary)");
	    
	//    let amountStrs = [];
	//    for (let amount of amounts) amountStrs.push(amount.toJSValue());
	//    console.log(amountStrs);
	//    console.log(cumulative);
	//    console.log(startHeight);
	//    console.log(endHeight);
	//    
	//    // send rpc request
	//    console.log("*********** SENDING REQUEST *************");
	//    if (startHeight === undefined) startHeight = 0;
	//    let resp = await this.rpc.sendJsonRequest("get_output_distribution", {
	//      amounts: amountStrs,
	//      cumulative: cumulative,
	//      from_height: startHeight,
	//      to_height: endHeight
	//    });
	//    
	//    console.log("RESPONSE");
	//    console.log(resp);
	//    
	//    // build distribution entries from response
	//    let entries = [];
	//    if (!resp.result.distributions) return entries; 
	//    for (let rpcEntry of resp.result.distributions) {
	//      let entry = MoneroDaemonRpc._convertRpcOutputDistributionEntry(rpcEntry);
	//      entries.push(entry);
	//    }
	//    return entries;
	  }
	  
	  async getInfo() {
	    let resp = await this.rpc.sendJsonRequest("get_info");
	    MoneroDaemonRpc._checkResponseStatus(resp.result);
	    return MoneroDaemonRpc._convertRpcInfo(resp.result);
	  }
	  
	  async getSyncInfo() {
	    let resp = await this.rpc.sendJsonRequest("sync_info");
	    MoneroDaemonRpc._checkResponseStatus(resp.result);
	    return MoneroDaemonRpc._convertRpcSyncInfo(resp.result);
	  }
	  
	  async getHardForkInfo() {
	    let resp = await this.rpc.sendJsonRequest("hard_fork_info");
	    MoneroDaemonRpc._checkResponseStatus(resp.result);
	    return MoneroDaemonRpc._convertRpcHardForkInfo(resp.result);
	  }
	  
	  async getAltChains() {
	    
	//    // mocked response for test
	//    let resp = {
	//        status: "OK",
	//        chains: [
	//          {
	//            block_hash: "697cf03c89a9b118f7bdf11b1b3a6a028d7b3617d2d0ed91322c5709acf75625",
	//            difficulty: 14114729638300280,
	//            height: 1562062,
	//            length: 2
	//          }
	//        ]
	//    }
	    
	    let resp = await this.rpc.sendJsonRequest("get_alternate_chains");
	    MoneroDaemonRpc._checkResponseStatus(resp.result);
	    let chains = [];
	    if (!resp.result.chains) return chains;
	    for (let rpcChain of resp.result.chains) chains.push(MoneroDaemonRpc._convertRpcAltChain(rpcChain));
	    return chains;
	  }
	  
	  async getAltBlockHashes() {
	    
	//    // mocked response for test
	//    let resp = {
	//        status: "OK",
	//        untrusted: false,
	//        blks_hashes: ["9c2277c5470234be8b32382cdf8094a103aba4fcd5e875a6fc159dc2ec00e011","637c0e0f0558e284493f38a5fcca3615db59458d90d3a5eff0a18ff59b83f46f","6f3adc174a2e8082819ebb965c96a095e3e8b63929ad9be2d705ad9c086a6b1c","697cf03c89a9b118f7bdf11b1b3a6a028d7b3617d2d0ed91322c5709acf75625"]
	//    }
	    
	    let resp = await this.rpc.sendPathRequest("get_alt_blocks_hashes");
	    MoneroDaemonRpc._checkResponseStatus(resp);
	    if (!resp.blks_hashes) return [];
	    return resp.blks_hashes;
	  }
	  
	  async getDownloadLimit() {
	    return (await this._getBandwidthLimits())[0];
	  }
	  
	  async setDownloadLimit(limit) {
	    if (limit == -1) return await this.resetDownloadLimit();
	    if (!(GenUtils.isInt(limit) && limit > 0)) throw new MoneroError("Download limit must be an integer greater than 0");
	    return (await this._setBandwidthLimits(limit, 0))[0];
	  }
	  
	  async resetDownloadLimit() {
	    return (await this._setBandwidthLimits(-1, 0))[0];
	  }

	  async getUploadLimit() {
	    return (await this._getBandwidthLimits())[1];
	  }
	  
	  async setUploadLimit(limit) {
	    if (limit == -1) return await this.resetUploadLimit();
	    if (!(GenUtils.isInt(limit) && limit > 0)) throw new MoneroError("Upload limit must be an integer greater than 0");
	    return (await this._setBandwidthLimits(0, limit))[1];
	  }
	  
	  async resetUploadLimit() {
	    return (await this._setBandwidthLimits(0, -1))[1];
	  }
	  
	  async getPeers() {
	    let resp = await this.rpc.sendJsonRequest("get_connections");
	    MoneroDaemonRpc._checkResponseStatus(resp.result);
	    let peers = [];
	    if (!resp.result.connections) return peers;
	    for (let rpcConnection of resp.result.connections) {
	      peers.push(MoneroDaemonRpc._convertRpcConnection(rpcConnection));
	    }
	    return peers;
	  }
	  
	  async getKnownPeers() {
	    
	    // tx config
	    let resp = await this.rpc.sendPathRequest("get_peer_list");
	    MoneroDaemonRpc._checkResponseStatus(resp);
	    
	    // build peers
	    let peers = [];
	    if (resp.gray_list) {
	      for (let rpcPeer of resp.gray_list) {
	        let peer = MoneroDaemonRpc._convertRpcPeer(rpcPeer);
	        peer.setIsOnline(false); // gray list means offline last checked
	        peers.push(peer);
	      }
	    }
	    if (resp.white_list) {
	      for (let rpcPeer of resp.white_list) {
	        let peer = MoneroDaemonRpc._convertRpcPeer(rpcPeer);
	        peer.setIsOnline(true); // white list means online last checked
	        peers.push(peer);
	      }
	    }
	    return peers;
	  }
	  
	  async setOutgoingPeerLimit(limit) {
	    if (!(GenUtils.isInt(limit) && limit >= 0)) throw new MoneroError("Outgoing peer limit must be >= 0");
	    let resp = await this.rpc.sendPathRequest("out_peers", {out_peers: limit});
	    MoneroDaemonRpc._checkResponseStatus(resp);
	  }
	  
	  async setIncomingPeerLimit(limit) {
	    if (!(GenUtils.isInt(limit) && limit >= 0)) throw new MoneroError("Incoming peer limit must be >= 0");
	    let resp = await this.rpc.sendPathRequest("in_peers", {in_peers: limit});
	    MoneroDaemonRpc._checkResponseStatus(resp);
	  }
	  
	  async getPeerBans() {
	    let resp = await this.rpc.sendJsonRequest("get_bans");
	    MoneroDaemonRpc._checkResponseStatus(resp.result);
	    let bans = [];
	    for (let rpcBan of resp.result.bans) {
	      let ban = new MoneroBan();
	      ban.setHost(rpcBan.host);
	      ban.setIp(rpcBan.ip);
	      ban.setSeconds(rpcBan.seconds);
	      bans.push(ban);
	    }
	    return bans;
	  }
	  
	  async setPeerBans(bans) {
	    let rpcBans = [];
	    for (let ban of bans) rpcBans.push(MoneroDaemonRpc._convertToRpcBan(ban));
	    let resp = await this.rpc.sendJsonRequest("set_bans", {bans: rpcBans});
	    MoneroDaemonRpc._checkResponseStatus(resp.result);
	  }
	  
	  async startMining(address, numThreads, isBackground, ignoreBattery) {
	    assert(address, "Must provide address to mine to");
	    assert(GenUtils.isInt(numThreads) && numThreads > 0, "Number of threads must be an integer greater than 0");
	    assert(isBackground === undefined || typeof isBackground === "boolean");
	    assert(ignoreBattery === undefined || typeof ignoreBattery === "boolean");
	    let resp = await this.rpc.sendPathRequest("start_mining", {
	      miner_address: address,
	      threads_count: numThreads,
	      do_background_mining: isBackground,
	      ignore_battery: ignoreBattery,
	    });
	    MoneroDaemonRpc._checkResponseStatus(resp);
	  }
	  
	  async stopMining() {
	    let resp = await this.rpc.sendPathRequest("stop_mining");
	    MoneroDaemonRpc._checkResponseStatus(resp);
	  }
	  
	  async getMiningStatus() {
	    let resp = await this.rpc.sendPathRequest("mining_status");
	    MoneroDaemonRpc._checkResponseStatus(resp);
	    return MoneroDaemonRpc._convertRpcMiningStatus(resp);
	  }
	  
	  async submitBlocks(blockBlobs) {
	    assert(Array.isArray(blockBlobs) && blockBlobs.length > 0, "Must provide an array of mined block blobs to submit");
	    let resp = await this.rpc.sendJsonRequest("submit_block", blockBlobs);
	    MoneroDaemonRpc._checkResponseStatus(resp.result);
	  }
	  
	  async checkForUpdate() {
	    let resp = await this.rpc.sendPathRequest("update", {command: "check"});
	    MoneroDaemonRpc._checkResponseStatus(resp);
	    return MoneroDaemonRpc._convertRpcUpdateCheckResult(resp);
	  }
	  
	  async downloadUpdate(path) {
	    let resp = await this.rpc.sendPathRequest("update", {command: "download", path: path});
	    MoneroDaemonRpc._checkResponseStatus(resp);
	    return MoneroDaemonRpc._convertRpcUpdateDownloadResult(resp);
	  }
	  
	  async stop() {
	    let resp = await this.rpc.sendPathRequest("stop_daemon");
	    MoneroDaemonRpc._checkResponseStatus(resp);
	  }
	  
	  async waitForNextBlockHeader() {
	    let that = this;
	    return new Promise(async function(resolve) {
	      await that.addListener(new class extends MoneroDaemonListener {
	        async onBlockHeader(header) {
	          await that.removeListener(this);
	          resolve(header);
	        }
	      }); 
	    });
	  }
	  
	  // ----------- ADD JSDOC FOR SUPPORTED DEFAULT IMPLEMENTATIONS --------------
	  
	  async getTx() { return super.getTx(...arguments); }
	  async getTxHex() { return super.getTxHex(...arguments); }
	  async getKeyImageSpentStatus() { return super.getKeyImageSpentStatus(...arguments); }
	  async setPeerBan() { return super.setPeerBan(...arguments); }
	  async submitBlock() { return super.submitBlock(...arguments); }
	  
	  // ------------------------------- PRIVATE ----------------------------------
	  
	  _refreshListening() {
	    if (this.pollListener == undefined && this.listeners.length) this.pollListener = new DaemonPoller(this);
	    if (this.pollListener !== undefined) this.pollListener.setIsPolling(this.listeners.length > 0);
	  }
	  
	  async _getBandwidthLimits() {
	    let resp = await this.rpc.sendPathRequest("get_limit");
	    MoneroDaemonRpc._checkResponseStatus(resp);
	    return [resp.limit_down, resp.limit_up];
	  }
	  
	  async _setBandwidthLimits(downLimit, upLimit) {
	    if (downLimit === undefined) downLimit = 0;
	    if (upLimit === undefined) upLimit = 0;
	    let resp = await this.rpc.sendPathRequest("set_limit", {limit_down: downLimit, limit_up: upLimit});
	    MoneroDaemonRpc._checkResponseStatus(resp);
	    return [resp.limit_down, resp.limit_up];
	  }
	  
	  /**
	   * Get a contiguous chunk of blocks starting from a given height up to a maximum
	   * height or amount of block data fetched from the blockchain, whichever comes first.
	   * 
	   * @param {number} startHeight - start height to retrieve blocks (default 0)
	   * @param {number} maxHeight - maximum end height to retrieve blocks (default blockchain height)
	   * @param {number} maxReqSize - maximum amount of block data to fetch from the blockchain in bytes (default 3,000,000 bytes)
	   * @return {MoneroBlock[]} are the resulting chunk of blocks
	   */
	  async _getMaxBlocks(startHeight, maxHeight, maxReqSize) {
	    if (startHeight === undefined) startHeight = 0;
	    if (maxHeight === undefined) maxHeight = await this.getHeight() - 1;
	    if (maxReqSize === undefined) maxReqSize = MoneroDaemonRpc.MAX_REQ_SIZE;
	    
	    // determine end height to fetch
	    let reqSize = 0;
	    let endHeight = startHeight - 1;
	    while (reqSize < maxReqSize && endHeight < maxHeight) {
	      
	      // get header of next block
	      let header = await this._getBlockHeaderByHeightCached(endHeight + 1, maxHeight);
	      
	      // block cannot be bigger than max request size
	      assert(header.getSize() <= maxReqSize, "Block exceeds maximum request size: " + header.getSize());
	      
	      // done iterating if fetching block would exceed max request size
	      if (reqSize + header.getSize() > maxReqSize) break;
	      
	      // otherwise block is included
	      reqSize += header.getSize();
	      endHeight++;
	    }
	    return endHeight >= startHeight ? await this.getBlocksByRange(startHeight, endHeight) : [];
	  }
	  
	  /**
	   * Retrieves a header by height from the cache or fetches and caches a header
	   * range if not already in the cache.
	   * 
	   * @param {number} height - height of the header to retrieve from the cache
	   * @param {number} maxHeight - maximum height of headers to cache
	   */
	  async _getBlockHeaderByHeightCached(height, maxHeight) {
	    
	    // get header from cache
	    let cachedHeader = this.cachedHeaders[height];
	    if (cachedHeader) return cachedHeader;
	    
	    // fetch and cache headers if not in cache
	    let endHeight = Math.min(maxHeight, height + MoneroDaemonRpc.NUM_HEADERS_PER_REQ - 1);  // TODO: could specify end height to cache to optimize small requests (would like to have time profiling in place though)
	    let headers = await this.getBlockHeadersByRange(height, endHeight);
	    for (let header of headers) {
	      this.cachedHeaders[header.getHeight()] = header;
	    }
	    
	    // return the cached header
	    return this.cachedHeaders[height];
	  }
	  
	  // --------------------------------- STATIC ---------------------------------
	  
	  static _normalizeConfig(uriOrConfigOrConnection, username, password, rejectUnauthorized, pollInterval, proxyToWorker) {
	    let config;
	    if (typeof uriOrConfigOrConnection === "string") config = {uri: uriOrConfigOrConnection, username: username, password: password, proxyToWorker: proxyToWorker, rejectUnauthorized: rejectUnauthorized, pollInterval: pollInterval};
	    else {
	      if (typeof uriOrConfigOrConnection !== "object") throw new MoneroError("Invalid configuration to create rpc client; must be string, object, or MoneroRpcConnection");
	      if (username || password || rejectUnauthorized || pollInterval || proxyToWorker) throw new MoneroError("Can provide config object or params or new MoneroDaemonRpc(...) but not both");
	      if (uriOrConfigOrConnection instanceof MoneroRpcConnection) config = Object.assign({}, uriOrConfigOrConnection.getConfig());
	      else config = Object.assign({}, uriOrConfigOrConnection);
	    }
	    if (config.server) {
	      config = Object.assign(config, new MoneroRpcConnection(config.server).getConfig());
	      delete config.server;
	    }
	    if (config.pollInterval === undefined) config.pollInterval = 5000; // TODO: move to config
	    if (config.proxyToWorker === undefined) config.proxyToWorker = true;
	    return config;
	  }
	  
	  static _checkResponseStatus(resp) {
	    if (resp.status !== "OK") throw new MoneroError(resp.status);
	  }
	  
	  static _convertRpcBlockHeader(rpcHeader) {
	    if (!rpcHeader) return undefined;
	    let header = new MoneroBlockHeader();
	    for (let key of Object.keys(rpcHeader)) {
	      let val = rpcHeader[key];
	      if (key === "block_size") GenUtils.safeSet(header, header.getSize, header.setSize, val);
	      else if (key === "depth") GenUtils.safeSet(header, header.getDepth, header.setDepth, val);
	      else if (key === "difficulty") ;  // handled by wide_difficulty
	      else if (key === "cumulative_difficulty") ; // handled by wide_cumulative_difficulty
	      else if (key === "difficulty_top64") ;  // handled by wide_difficulty
	      else if (key === "cumulative_difficulty_top64") ; // handled by wide_cumulative_difficulty
	      else if (key === "wide_difficulty") header.setDifficulty(GenUtils.reconcile(header.getDifficulty(), MoneroDaemonRpc._prefixedHexToBI(val)));
	      else if (key === "wide_cumulative_difficulty") header.setCumulativeDifficulty(GenUtils.reconcile(header.getCumulativeDifficulty(), MoneroDaemonRpc._prefixedHexToBI(val)));
	      else if (key === "hash") GenUtils.safeSet(header, header.getHash, header.setHash, val);
	      else if (key === "height") GenUtils.safeSet(header, header.getHeight, header.setHeight, val);
	      else if (key === "major_version") GenUtils.safeSet(header, header.getMajorVersion, header.setMajorVersion, val);
	      else if (key === "minor_version") GenUtils.safeSet(header, header.getMinorVersion, header.setMinorVersion, val);
	      else if (key === "nonce") GenUtils.safeSet(header, header.getNonce, header.setNonce, val);
	      else if (key === "num_txes") GenUtils.safeSet(header, header.getNumTxs, header.setNumTxs, val);
	      else if (key === "orphan_status") GenUtils.safeSet(header, header.getOrphanStatus, header.setOrphanStatus, val);
	      else if (key === "prev_hash" || key === "prev_id") GenUtils.safeSet(header, header.getPrevHash, header.setPrevHash, val);
	      else if (key === "reward") GenUtils.safeSet(header, header.getReward, header.setReward, BigInteger.parse(val));
	      else if (key === "timestamp") GenUtils.safeSet(header, header.getTimestamp, header.setTimestamp, val);
	      else if (key === "block_weight") GenUtils.safeSet(header, header.getWeight, header.setWeight, val);
	      else if (key === "long_term_weight") GenUtils.safeSet(header, header.getLongTermWeight, header.setLongTermWeight, val);
	      else if (key === "pow_hash") GenUtils.safeSet(header, header.getPowHash, header.setPowHash, val === "" ? undefined : val);
	      else if (key === "tx_hashes") ;  // used in block model, not header model
	      else if (key === "miner_tx") ;   // used in block model, not header model
	      else if (key === "miner_tx_hash") header.setMinerTxHash(val);
	      else console.log("WARNING: ignoring unexpected block header field: '" + key + "': " + val);
	    }
	    return header;
	  }
	  
	  static _convertRpcBlock(rpcBlock) {
	    
	    // build block
	    let block = new MoneroBlock(MoneroDaemonRpc._convertRpcBlockHeader(rpcBlock.block_header ? rpcBlock.block_header : rpcBlock));
	    block.setHex(rpcBlock.blob);
	    block.setTxHashes(rpcBlock.tx_hashes === undefined ? [] : rpcBlock.tx_hashes);
	    
	    // build miner tx
	    let rpcMinerTx = rpcBlock.json ? JSON.parse(rpcBlock.json).miner_tx : rpcBlock.miner_tx;  // may need to be parsed from json
	    let minerTx = new MoneroTx();
	    block.setMinerTx(minerTx);
	    minerTx.setIsConfirmed(true);
	    minerTx.setIsMinerTx(true);
	    MoneroDaemonRpc._convertRpcTx(rpcMinerTx, minerTx);
	    
	    return block;
	  }
	  
	  /**
	   * Transfers RPC tx fields to a given MoneroTx without overwriting previous values.
	   * 
	   * TODO: switch from safe set
	   * 
	   * @param rpcTx - RPC map containing transaction fields
	   * @param tx  - MoneroTx to populate with values (optional)
	   * @returns tx - same tx that was passed in or a new one if none given
	   */
	  static _convertRpcTx(rpcTx, tx) {
	    if (rpcTx === undefined) return undefined;
	    if (tx === undefined) tx = new MoneroTx();
	    
	//    console.log("******** BUILDING TX ***********");
	//    console.log(rpcTx);
	//    console.log(tx.toString());
	    
	    // initialize from rpc map
	    let header;
	    for (let key of Object.keys(rpcTx)) {
	      let val = rpcTx[key];
	      if (key === "tx_hash" || key === "id_hash") GenUtils.safeSet(tx, tx.getHash, tx.setHash, val);
	      else if (key === "block_timestamp") {
	        if (!header) header = new MoneroBlockHeader();
	        GenUtils.safeSet(header, header.getTimestamp, header.setTimestamp, val);
	      }
	      else if (key === "block_height") {
	        if (!header) header = new MoneroBlockHeader();
	        GenUtils.safeSet(header, header.getHeight, header.setHeight, val);
	      }
	      else if (key === "last_relayed_time") GenUtils.safeSet(tx, tx.getLastRelayedTimestamp, tx.setLastRelayedTimestamp, val);
	      else if (key === "receive_time" || key === "received_timestamp") GenUtils.safeSet(tx, tx.getReceivedTimestamp, tx.setReceivedTimestamp, val);
	      else if (key === "confirmations") GenUtils.safeSet(tx, tx.getNumConfirmations, tx.setNumConfirmations, val); 
	      else if (key === "in_pool") {
	        GenUtils.safeSet(tx, tx.isConfirmed, tx.setIsConfirmed, !val);
	        GenUtils.safeSet(tx, tx.inTxPool, tx.setInTxPool, val);
	      }
	      else if (key === "double_spend_seen") GenUtils.safeSet(tx, tx.isDoubleSpendSeen, tx.setIsDoubleSpend, val);
	      else if (key === "version") GenUtils.safeSet(tx, tx.getVersion, tx.setVersion, val);
	      else if (key === "extra") {
	        if (typeof val === "string") console.log("WARNING: extra field as string not being asigned to int[]: " + key + ": " + val); // TODO: how to set string to int[]? - or, extra is string which can encode int[]
	        else GenUtils.safeSet(tx, tx.getExtra, tx.setExtra, val);
	      }
	      else if (key === "vin") {
	        if (val.length !== 1 || !val[0].gen) {  // ignore miner input TODO: why?
	          tx.setInputs(val.map(rpcVin => MoneroDaemonRpc._convertRpcOutput(rpcVin, tx)));
	        }
	      }
	      else if (key === "vout") tx.setOutputs(val.map(rpcOutput => MoneroDaemonRpc._convertRpcOutput(rpcOutput, tx)));
	      else if (key === "rct_signatures") GenUtils.safeSet(tx, tx.getRctSignatures, tx.setRctSignatures, val);
	      else if (key === "rctsig_prunable") GenUtils.safeSet(tx, tx.getRctSigPrunable, tx.setRctSigPrunable, val);
	      else if (key === "unlock_time") GenUtils.safeSet(tx, tx.getUnlockHeight, tx.setUnlockHeight, val);
	      else if (key === "as_json" || key === "tx_json") ;  // handled last so tx is as initialized as possible
	      else if (key === "as_hex" || key === "tx_blob") GenUtils.safeSet(tx, tx.getFullHex, tx.setFullHex, val ? val : undefined);
	      else if (key === "blob_size") GenUtils.safeSet(tx, tx.getSize, tx.setSize, val);
	      else if (key === "weight") GenUtils.safeSet(tx, tx.getWeight, tx.setWeight, val);
	      else if (key === "fee") GenUtils.safeSet(tx, tx.getFee, tx.setFee, BigInteger.parse(val));
	      else if (key === "relayed") GenUtils.safeSet(tx, tx.isRelayed, tx.setIsRelayed, val);
	      else if (key === "output_indices") GenUtils.safeSet(tx, tx.getOutputIndices, tx.setOutputIndices, val);
	      else if (key === "do_not_relay") GenUtils.safeSet(tx, tx.getRelay, tx.setRelay, !val);
	      else if (key === "kept_by_block") GenUtils.safeSet(tx, tx.isKeptByBlock, tx.setIsKeptByBlock, val);
	      else if (key === "signatures") GenUtils.safeSet(tx, tx.getSignatures, tx.setSignatures, val);
	      else if (key === "last_failed_height") {
	        if (val === 0) GenUtils.safeSet(tx, tx.isFailed, tx.setIsFailed, false);
	        else {
	          GenUtils.safeSet(tx, tx.isFailed, tx.setIsFailed, true);
	          GenUtils.safeSet(tx, tx.getLastFailedHeight, tx.setLastFailedHeight, val);
	        }
	      }
	      else if (key === "last_failed_id_hash") {
	        if (val === MoneroDaemonRpc.DEFAULT_ID) GenUtils.safeSet(tx, tx.isFailed, tx.setIsFailed, false);
	        else {
	          GenUtils.safeSet(tx, tx.isFailed, tx.setIsFailed, true);
	          GenUtils.safeSet(tx, tx.getLastFailedHash, tx.setLastFailedHash, val);
	        }
	      }
	      else if (key === "max_used_block_height") GenUtils.safeSet(tx, tx.getMaxUsedBlockHeight, tx.setMaxUsedBlockHeight, val);
	      else if (key === "max_used_block_id_hash") GenUtils.safeSet(tx, tx.getMaxUsedBlockHash, tx.setMaxUsedBlockHash, val);
	      else if (key === "prunable_hash") GenUtils.safeSet(tx, tx.getPrunableHash, tx.setPrunableHash, val ? val : undefined);
	      else if (key === "prunable_as_hex") GenUtils.safeSet(tx, tx.getPrunableHex, tx.setPrunableHex, val ? val : undefined);
	      else if (key === "pruned_as_hex") GenUtils.safeSet(tx, tx.getPrunedHex, tx.setPrunedHex, val ? val : undefined);
	      else console.log("WARNING: ignoring unexpected field in rpc tx: " + key + ": " + val);
	    }
	    
	    // link block and tx
	    if (header) tx.setBlock(new MoneroBlock(header).setTxs([tx]));
	    
	    // TODO monerod: unconfirmed txs misreport block height and timestamp
	    if (tx.getBlock() && tx.getBlock().getHeight() !== undefined && tx.getBlock().getHeight() === tx.getBlock().getTimestamp()) {
	      tx.setBlock(undefined);
	      tx.setIsConfirmed(false);
	    }
	    
	    // initialize remaining known fields
	    if (tx.isConfirmed()) {
	      GenUtils.safeSet(tx, tx.isRelayed, tx.setIsRelayed, true);
	      GenUtils.safeSet(tx, tx.getRelay, tx.setRelay, true);
	      GenUtils.safeSet(tx, tx.isFailed, tx.setIsFailed, false);
	    } else {
	      tx.setNumConfirmations(0);
	    }
	    if (tx.isFailed() === undefined) tx.setIsFailed(false);
	    if (tx.getOutputIndices() && tx.getOutputs())  {
	      assert.equal(tx.getOutputs().length, tx.getOutputIndices().length);
	      for (let i = 0; i < tx.getOutputs().length; i++) {
	        tx.getOutputs()[i].setIndex(tx.getOutputIndices()[i]);  // transfer output indices to outputs
	      }
	    }
	    if (rpcTx.as_json) MoneroDaemonRpc._convertRpcTx(JSON.parse(rpcTx.as_json), tx);
	    if (rpcTx.tx_json) MoneroDaemonRpc._convertRpcTx(JSON.parse(rpcTx.tx_json), tx);
	    if (!tx.isRelayed()) tx.setLastRelayedTimestamp(undefined);  // TODO monerod: returns last_relayed_timestamp despite relayed: false, self inconsistent
	    
	    // return built transaction
	    return tx;
	  }
	  
	  static _convertRpcOutput(rpcOutput, tx) {
	    let output = new MoneroOutput();
	    output.setTx(tx);
	    for (let key of Object.keys(rpcOutput)) {
	      let val = rpcOutput[key];
	      if (key === "gen") throw new MoneroError("Output with 'gen' from daemon rpc is miner tx which we ignore (i.e. each miner input is undefined)");
	      else if (key === "key") {
	        GenUtils.safeSet(output, output.getAmount, output.setAmount, new BigInteger(val.amount));
	        GenUtils.safeSet(output, output.getKeyImage, output.setKeyImage, new MoneroKeyImage(val.k_image));
	        GenUtils.safeSet(output, output.getRingOutputIndices, output.setRingOutputIndices, val.key_offsets);
	      }
	      else if (key === "amount") GenUtils.safeSet(output, output.getAmount, output.setAmount, BigInteger.parse(val));
	      else if (key === "target") {
	        let pubKey = val.key === undefined ? val.tagged_key.key : val.key; // TODO (monerod): rpc json uses {tagged_key={key=...}}, binary blocks use {key=...}
	        GenUtils.safeSet(output, output.getStealthPublicKey, output.setStealthPublicKey, pubKey);
	      }
	      else console.log("WARNING: ignoring unexpected field output: " + key + ": " + val);
	    }
	    return output;
	  }
	  
	  static _convertRpcBlockTemplate(rpcTemplate) {
	    let template = new MoneroBlockTemplate();
	    for (let key of Object.keys(rpcTemplate)) {
	      let val = rpcTemplate[key];
	      if (key === "blockhashing_blob") template.setBlockTemplateBlob(val);
	      else if (key === "blocktemplate_blob") template.setBlockHashingBlob(val);
	      else if (key === "difficulty") template.setDifficulty(BigInteger.parse(val));
	      else if (key === "expected_reward") template.setExpectedReward(val);
	      else if (key === "difficulty") ;  // handled by wide_difficulty
	      else if (key === "difficulty_top64") ;  // handled by wide_difficulty
	      else if (key === "wide_difficulty") template.setDifficulty(GenUtils.reconcile(template.getDifficulty(), MoneroDaemonRpc._prefixedHexToBI(val)));
	      else if (key === "height") template.setHeight(val);
	      else if (key === "prev_hash") template.setPrevHash(val);
	      else if (key === "reserved_offset") template.setReservedOffset(val);
	      else if (key === "status") ;  // handled elsewhere
	      else if (key === "untrusted") ;  // handled elsewhere
	      else if (key === "seed_height") template.setSeedHeight(val);
	      else if (key === "seed_hash") template.setSeedHash(val);
	      else if (key === "next_seed_hash") template.setNextSeedHash(val);
	      else console.log("WARNING: ignoring unexpected field in block template: " + key + ": " + val);
	    }
	    if ("" === template.getNextSeedHash()) template.setNextSeedHash(undefined);
	    return template;
	  }
	  
	  static _convertRpcInfo(rpcInfo) {
	    if (!rpcInfo) return undefined;
	    let info = new MoneroDaemonInfo();
	    for (let key of Object.keys(rpcInfo)) {
	      let val = rpcInfo[key];
	      if (key === "version") info.setVersion(val);
	      else if (key === "alt_blocks_count") info.setNumAltBlocks(val);
	      else if (key === "block_size_limit") info.setBlockSizeLimit(val);
	      else if (key === "block_size_median") info.setBlockSizeMedian(val);
	      else if (key === "block_weight_limit") info.setBlockWeightLimit(val);
	      else if (key === "block_weight_median") info.setBlockWeightMedian(val);
	      else if (key === "bootstrap_daemon_address") { if (val) info.setBootstrapDaemonAddress(val); }
	      else if (key === "difficulty") ;  // handled by wide_difficulty
	      else if (key === "cumulative_difficulty") ; // handled by wide_cumulative_difficulty
	      else if (key === "difficulty_top64") ;  // handled by wide_difficulty
	      else if (key === "cumulative_difficulty_top64") ; // handled by wide_cumulative_difficulty
	      else if (key === "wide_difficulty") info.setDifficulty(GenUtils.reconcile(info.getDifficulty(), MoneroDaemonRpc._prefixedHexToBI(val)));
	      else if (key === "wide_cumulative_difficulty") info.setCumulativeDifficulty(GenUtils.reconcile(info.getCumulativeDifficulty(), MoneroDaemonRpc._prefixedHexToBI(val)));
	      else if (key === "free_space") info.setFreeSpace(BigInteger.parse(val));
	      else if (key === "database_size") info.setDatabaseSize(val);
	      else if (key === "grey_peerlist_size") info.setNumOfflinePeers(val);
	      else if (key === "height") info.setHeight(val);
	      else if (key === "height_without_bootstrap") info.setHeightWithoutBootstrap(val);
	      else if (key === "incoming_connections_count") info.setNumIncomingConnections(val);
	      else if (key === "offline") info.setIsOffline(val);
	      else if (key === "outgoing_connections_count") info.setNumOutgoingConnections(val);
	      else if (key === "rpc_connections_count") info.setNumRpcConnections(val);
	      else if (key === "start_time") info.setStartTimestamp(val);
	      else if (key === "adjusted_time") info.setAdjustedTimestamp(val);
	      else if (key === "status") ;  // handled elsewhere
	      else if (key === "target") info.setTarget(val);
	      else if (key === "target_height") info.setTargetHeight(val);
	      else if (key === "top_block_hash") info.setTopBlockHash(val);
	      else if (key === "tx_count") info.setNumTxs(val);
	      else if (key === "tx_pool_size") info.setNumTxsPool(val);
	      else if (key === "untrusted") ; // handled elsewhere
	      else if (key === "was_bootstrap_ever_used") info.setWasBootstrapEverUsed(val);
	      else if (key === "white_peerlist_size") info.setNumOnlinePeers(val);
	      else if (key === "update_available") info.setUpdateAvailable(val);
	      else if (key === "nettype") GenUtils.safeSet(info, info.getNetworkType, info.setNetworkType, MoneroDaemon.parseNetworkType(val));
	      else if (key === "mainnet") { if (val) GenUtils.safeSet(info, info.getNetworkType, info.setNetworkType, MoneroNetworkType.MAINNET); }
	      else if (key === "testnet") { if (val) GenUtils.safeSet(info, info.getNetworkType, info.setNetworkType, MoneroNetworkType.TESTNET); }
	      else if (key === "stagenet") { if (val) GenUtils.safeSet(info, info.getNetworkType, info.setNetworkType, MoneroNetworkType.STAGENET); }
	      else if (key === "credits") info.setCredits(BigInteger.parse(val));
	      else if (key === "top_block_hash" || key === "top_hash") info.setTopBlockHash(GenUtils.reconcile(info.getTopBlockHash(), "" === val ? undefined : val));
	      else if (key === "busy_syncing") info.setIsBusySyncing(val);
	      else if (key === "synchronized") info.setIsSynchronized(val);
	      else if (key === "restricted") info.setIsRestricted(val);
	      else console.log("WARNING: Ignoring unexpected info field: " + key + ": " + val);
	    }
	    return info;
	  }
	  
	  /**
	   * Initializes sync info from RPC sync info.
	   * 
	   * @param rpcSyncInfo - rpc map to initialize the sync info from
	   * @return {MoneroDaemonSyncInfo} is sync info initialized from the map
	   */
	  static _convertRpcSyncInfo(rpcSyncInfo) {
	    let syncInfo = new MoneroDaemonSyncInfo();
	    for (let key of Object.keys(rpcSyncInfo)) {
	      let val = rpcSyncInfo[key];
	      if (key === "height") syncInfo.setHeight(val);
	      else if (key === "peers") {
	        syncInfo.setPeers([]);
	        let rpcConnections = val;
	        for (let rpcConnection of rpcConnections) {
	          syncInfo.getPeers().push(MoneroDaemonRpc._convertRpcConnection(rpcConnection.info));
	        }
	      }
	      else if (key === "spans") {
	        syncInfo.setSpans([]);
	        let rpcSpans = val;
	        for (let rpcSpan of rpcSpans) {
	          syncInfo.getSpans().push(MoneroDaemonRpc._convertRpcConnectionSpan(rpcSpan));
	        }
	      } else if (key === "status") ;   // handled elsewhere
	      else if (key === "target_height") syncInfo.setTargetHeight(BigInteger.parse(val));
	      else if (key === "next_needed_pruning_seed") syncInfo.setNextNeededPruningSeed(val);
	      else if (key === "overview") {  // this returns [] without pruning
	        let overview;
	        try {
	          overview = JSON.parse(val);
	          if (overview !== undefined && overview.length > 0) console.error("Ignoring non-empty 'overview' field (not implemented): " + overview); // TODO
	        } catch (e) {
	          console.error("Failed to parse 'overview' field: " + overview + ": " + e.message);
	        }
	      }
	      else if (key === "credits") syncInfo.setCredits(BigInteger.parse(val));
	      else if (key === "top_hash") syncInfo.setTopBlockHash("" === val ? undefined : val);
	      else if (key === "untrusted") ;  // handled elsewhere
	      else console.log("WARNING: ignoring unexpected field in sync info: " + key + ": " + val);
	    }
	    return syncInfo;
	  }
	  
	  static _convertRpcHardForkInfo(rpcHardForkInfo) {
	    let info = new MoneroHardForkInfo();
	    for (let key of Object.keys(rpcHardForkInfo)) {
	      let val = rpcHardForkInfo[key];
	      if (key === "earliest_height") info.setEarliestHeight(val);
	      else if (key === "enabled") info.setIsEnabled(val);
	      else if (key === "state") info.setState(val);
	      else if (key === "status") ;     // handled elsewhere
	      else if (key === "untrusted") ;  // handled elsewhere
	      else if (key === "threshold") info.setThreshold(val);
	      else if (key === "version") info.setVersion(val);
	      else if (key === "votes") info.setNumVotes(val);
	      else if (key === "voting") info.setVoting(val);
	      else if (key === "window") info.setWindow(val);
	      else if (key === "credits") info.setCredits(BigInteger.parse(val));
	      else if (key === "top_hash") info.setTopBlockHash("" === val ? undefined : val);
	      else console.log("WARNING: ignoring unexpected field in hard fork info: " + key + ": " + val);
	    }
	    return info;
	  }
	  
	  static _convertRpcConnectionSpan(rpcConnectionSpan) {
	    let span = new MoneroConnectionSpan();
	    for (let key of Object.keys(rpcConnectionSpan)) {
	      let val = rpcConnectionSpan[key];
	      if (key === "connection_id") span.setConnectionId(val);
	      else if (key === "nblocks") span.setNumBlocks(val);
	      else if (key === "rate") span.setRate(val);
	      else if (key === "remote_address") { if (val !== "") span.setRemoteAddress(val); }
	      else if (key === "size") span.setSize(val);
	      else if (key === "speed") span.setSpeed(val);
	      else if (key === "start_block_height") span.setStartHeight(val);
	      else console.log("WARNING: ignoring unexpected field in daemon connection span: " + key + ": " + val);
	    }
	    return span;
	  }
	  
	  static _convertRpcOutputHistogramEntry(rpcEntry) {
	    let entry = new MoneroOutputHistogramEntry();
	    for (let key of Object.keys(rpcEntry)) {
	      let val = rpcEntry[key];
	      if (key === "amount") entry.setAmount(BigInteger.parse(val));
	      else if (key === "total_instances") entry.setNumInstances(val);
	      else if (key === "unlocked_instances") entry.setNumUnlockedInstances(val);
	      else if (key === "recent_instances") entry.setNumRecentInstances(val);
	      else console.log("WARNING: ignoring unexpected field in output histogram: " + key + ": " + val);
	    }
	    return entry;
	  }
	  
	  static _convertRpcSubmitTxResult(rpcResult) {
	    assert(rpcResult);
	    let result = new MoneroSubmitTxResult();
	    for (let key of Object.keys(rpcResult)) {
	      let val = rpcResult[key];
	      if (key === "double_spend") result.setIsDoubleSpend(val);
	      else if (key === "fee_too_low") result.setIsFeeTooLow(val);
	      else if (key === "invalid_input") result.setHasInvalidInput(val);
	      else if (key === "invalid_output") result.setHasInvalidOutput(val);
	      else if (key === "too_few_outputs") result.setHasTooFewOutputs(val);
	      else if (key === "low_mixin") result.setIsMixinTooLow(val);
	      else if (key === "not_relayed") result.setIsRelayed(!val);
	      else if (key === "overspend") result.setIsOverspend(val);
	      else if (key === "reason") result.setReason(val === "" ? undefined : val);
	      else if (key === "too_big") result.setIsTooBig(val);
	      else if (key === "sanity_check_failed") result.setSanityCheckFailed(val);
	      else if (key === "credits") result.setCredits(BigInteger.parse(val));
	      else if (key === "status" || key === "untrusted") ;  // handled elsewhere
	      else if (key === "top_hash") result.setTopBlockHash("" === val ? undefined : val);
	      else console.log("WARNING: ignoring unexpected field in submit tx hex result: " + key + ": " + val);
	    }
	    return result;
	  }
	  
	  static _convertRpcTxPoolStats(rpcStats) {
	    assert(rpcStats);
	    let stats = new MoneroTxPoolStats();
	    for (let key of Object.keys(rpcStats)) {
	      let val = rpcStats[key];
	      if (key === "bytes_max") stats.setBytesMax(val);
	      else if (key === "bytes_med") stats.setBytesMed(val);
	      else if (key === "bytes_min") stats.setBytesMin(val);
	      else if (key === "bytes_total") stats.setBytesTotal(val);
	      else if (key === "histo_98pc") stats.setHisto98pc(val);
	      else if (key === "num_10m") stats.setNum10m(val);
	      else if (key === "num_double_spends") stats.setNumDoubleSpends(val);
	      else if (key === "num_failing") stats.setNumFailing(val);
	      else if (key === "num_not_relayed") stats.setNumNotRelayed(val);
	      else if (key === "oldest") stats.setOldestTimestamp(val);
	      else if (key === "txs_total") stats.setNumTxs(val);
	      else if (key === "fee_total") stats.setFeeTotal(BigInteger.parse(val));
	      else if (key === "histo") throw new MoneroError("Not implemented");
	      else console.log("WARNING: ignoring unexpected field in tx pool stats: " + key + ": " + val);
	    }
	    return stats;
	  }
	  
	  static _convertRpcAltChain(rpcChain) {
	    assert(rpcChain);
	    let chain = new MoneroAltChain();
	    for (let key of Object.keys(rpcChain)) {
	      let val = rpcChain[key];
	      if (key === "block_hash") ;  // using block_hashes instead
	      else if (key === "difficulty") ; // handled by wide_difficulty
	      else if (key === "difficulty_top64") ;  // handled by wide_difficulty
	      else if (key === "wide_difficulty") chain.setDifficulty(GenUtils.reconcile(chain.getDifficulty(), MoneroDaemonRpc._prefixedHexToBI(val)));
	      else if (key === "height") chain.setHeight(val);
	      else if (key === "length") chain.setLength(val);
	      else if (key === "block_hashes") chain.setBlockHashes(val);
	      else if (key === "main_chain_parent_block") chain.setMainChainParentBlockHash(val);
	      else console.log("WARNING: ignoring unexpected field in alternative chain: " + key + ": " + val);
	    }
	    return chain;
	  }
	  
	  static _convertRpcPeer(rpcPeer) {
	    assert(rpcPeer);
	    let peer = new MoneroPeer();
	    for (let key of Object.keys(rpcPeer)) {
	      let val = rpcPeer[key];
	      if (key === "host") peer.setHost(val);
	      else if (key === "id") peer.setId("" + val);  // TODO monero-wallet-rpc: peer id is BigInteger but string in `get_connections`
	      else if (key === "ip") ; // host used instead which is consistently a string
	      else if (key === "last_seen") peer.setLastSeenTimestamp(val);
	      else if (key === "port") peer.setPort(val);
	      else if (key === "rpc_port") peer.setRpcPort(val);
	      else if (key === "pruning_seed") peer.setPruningSeed(val);
	      else if (key === "rpc_credits_per_hash") peer.setRpcCreditsPerHash(BigInteger.parse(val));
	      else console.log("WARNING: ignoring unexpected field in rpc peer: " + key + ": " + val);
	    }
	    return peer;
	  }
	  
	  static _convertRpcConnection(rpcConnection) {
	    let peer = new MoneroPeer();
	    peer.setIsOnline(true);
	    for (let key of Object.keys(rpcConnection)) {
	      let val = rpcConnection[key];
	      if (key === "address") peer.setAddress(val);
	      else if (key === "avg_download") peer.setAvgDownload(val);
	      else if (key === "avg_upload") peer.setAvgUpload(val);
	      else if (key === "connection_id") peer.setId(val);
	      else if (key === "current_download") peer.setCurrentDownload(val);
	      else if (key === "current_upload") peer.setCurrentUpload(val);
	      else if (key === "height") peer.setHeight(val);
	      else if (key === "host") peer.setHost(val);
	      else if (key === "ip") ; // host used instead which is consistently a string
	      else if (key === "incoming") peer.setIsIncoming(val);
	      else if (key === "live_time") peer.setLiveTime(val);
	      else if (key === "local_ip") peer.setIsLocalIp(val);
	      else if (key === "localhost") peer.setIsLocalHost(val);
	      else if (key === "peer_id") peer.setId(val);
	      else if (key === "port") peer.setPort(parseInt(val));
	      else if (key === "rpc_port") peer.setRpcPort(val);
	      else if (key === "recv_count") peer.setNumReceives(val);
	      else if (key === "recv_idle_time") peer.setReceiveIdleTime(val);
	      else if (key === "send_count") peer.setNumSends(val);
	      else if (key === "send_idle_time") peer.setSendIdleTime(val);
	      else if (key === "state") peer.setState(val);
	      else if (key === "support_flags") peer.setNumSupportFlags(val);
	      else if (key === "pruning_seed") peer.setPruningSeed(val);
	      else if (key === "rpc_credits_per_hash") peer.setRpcCreditsPerHash(BigInteger.parse(val));
	      else if (key === "address_type") peer.setType(val);
	      else console.log("WARNING: ignoring unexpected field in peer: " + key + ": " + val);
	    }
	    return peer;
	  }
	  
	  static _convertToRpcBan(ban) {
	    let rpcBan = {};
	    rpcBan.host = ban.getHost();
	    rpcBan.ip = ban.getIp();
	    rpcBan.ban = ban.isBanned();
	    rpcBan.seconds = ban.getSeconds();
	    return rpcBan;
	  }
	  
	  static _convertRpcMiningStatus(rpcStatus) {
	    let status = new MoneroMiningStatus();
	    status.setIsActive(rpcStatus.active);
	    status.setSpeed(rpcStatus.speed);
	    status.setNumThreads(rpcStatus.threads_count);
	    if (rpcStatus.active) {
	      status.setAddress(rpcStatus.address);
	      status.setIsBackground(rpcStatus.is_background_mining_enabled);
	    }
	    return status;
	  }
	  
	  static _convertRpcUpdateCheckResult(rpcResult) {
	    assert(rpcResult);
	    let result = new MoneroDaemonUpdateCheckResult();
	    for (let key of Object.keys(rpcResult)) {
	      let val = rpcResult[key];
	      if (key === "auto_uri") result.setAutoUri(val);
	      else if (key === "hash") result.setHash(val);
	      else if (key === "path") ; // handled elsewhere
	      else if (key === "status") ; // handled elsewhere
	      else if (key === "update") result.setIsUpdateAvailable(val);
	      else if (key === "user_uri") result.setUserUri(val);
	      else if (key === "version") result.setVersion(val);
	      else if (key === "untrusted") ; // handled elsewhere
	      else console.log("WARNING: ignoring unexpected field in rpc check update result: " + key + ": " + val);
	    }
	    if (result.getAutoUri() === "") result.setAutoUri(undefined);
	    if (result.getUserUri() === "") result.setUserUri(undefined);
	    if (result.getVersion() === "") result.setVersion(undefined);
	    if (result.getHash() === "") result.setHash(undefined);
	    return result;
	  }
	  
	  static _convertRpcUpdateDownloadResult(rpcResult) {
	    let result = new MoneroDaemonUpdateDownloadResult(MoneroDaemonRpc._convertRpcUpdateCheckResult(rpcResult));
	    result.setDownloadPath(rpcResult["path"]);
	    if (result.getDownloadPath() === "") result.setDownloadPath(undefined);
	    return result;
	  }

	  /**
	   * Converts a '0x' prefixed hexidecimal string to a BigInteger.
	   * 
	   * @param hex is the '0x' prefixed hexidecimal string to convert
	   * @return BigInteger is the hexicedimal converted to decimal
	   */
	  static _prefixedHexToBI(hex) {
	    assert(hex.substring(0, 2) === "0x");
	    return BigInteger.parse(hex, 16);
	  }
	}

	// static variables
	MoneroDaemonRpc.DEFAULT_ID = "0000000000000000000000000000000000000000000000000000000000000000";  // uninitialized tx or block hash from daemon rpc
	MoneroDaemonRpc.MAX_REQ_SIZE = "3000000";  // max request size when fetching blocks from daemon
	MoneroDaemonRpc.NUM_HEADERS_PER_REQ = "750";  // number of headers to fetch and cache per request

	/**
	 * Implements a MoneroDaemon by proxying requests to a worker.
	 * 
	 * @private
	 */
	class MoneroDaemonRpcProxy extends MoneroDaemon {
	  
	  // --------------------------- STATIC UTILITIES -----------------------------
	  
	  static async connect(config) {
	    let daemonId = GenUtils.getUUID();
	    config = Object.assign({}, config, {proxyToWorker: false});
	    await LibraryUtils.invokeWorker(daemonId, "connectDaemonRpc", [config]);
	    return new MoneroDaemonRpcProxy(daemonId, await LibraryUtils.getWorker());
	  }
	  
	  // ---------------------------- INSTANCE METHODS ----------------------------
	  
	  constructor(daemonId, worker) {
	    super();
	    this.daemonId = daemonId;
	    this.worker = worker;
	    this.wrappedListeners = [];
	  }
	  
	  async getProcess() {
	    return undefined; // proxy does not have access to process
	  }
	  
	  async stopProcess() {
	    if (this.process === undefined) throw new MoneroError("MoneroDaemonRpcProxy instance not created from new process");
	    let listenersCopy = GenUtils.copyArray(this.getListeners());
	    for (let listener of listenersCopy) await this.removeListener(listener);
	    this.process.kill();
	  }
	  
	  async addListener(listener) {
	    let wrappedListener = new DaemonWorkerListener(listener);
	    let listenerId = wrappedListener.getId();
	    LibraryUtils.WORKER_OBJECTS[this.daemonId].callbacks["onBlockHeader_" + listenerId] = [wrappedListener.onBlockHeader, wrappedListener];
	    this.wrappedListeners.push(wrappedListener);
	    return this._invokeWorker("daemonAddListener", [listenerId]);
	  }
	  
	  async removeListener(listener) {
	    for (let i = 0; i < this.wrappedListeners.length; i++) {
	      if (this.wrappedListeners[i].getListener() === listener) {
	        let listenerId = this.wrappedListeners[i].getId();
	        await this._invokeWorker("daemonRemoveListener", [listenerId]);
	        delete LibraryUtils.WORKER_OBJECTS[this.daemonId].callbacks["onBlockHeader_" + listenerId];
	        this.wrappedListeners.splice(i, 1);
	        return;
	      }
	    }
	    throw new MoneroError("Listener is not registered with daemon");
	  }
	  
	  getListeners() {
	    let listeners = [];
	    for (let wrappedListener of this.wrappedListeners) listeners.push(wrappedListener.getListener());
	    return listeners;
	  }
	  
	  async getRpcConnection() {
	    let config = await this._invokeWorker("daemonGetRpcConnection");
	    return new MoneroRpcConnection(config);
	  }
	  
	  async isConnected() {
	    return this._invokeWorker("daemonIsConnected");
	  }
	  
	  async getVersion() {
	    let versionJson = await this._invokeWorker("daemonGetVersion");
	    return new MoneroVersion(versionJson.number, versionJson.isRelease);
	  }
	  
	  async isTrusted() {
	    return this._invokeWorker("daemonIsTrusted");
	  }
	  
	  async getHeight() {
	    return this._invokeWorker("daemonGetHeight");
	  }
	  
	  async getBlockHash(height) {
	    return this._invokeWorker("daemonGetBlockHash", Array.from(arguments));
	  }
	  
	  async getBlockTemplate(walletAddress, reserveSize) {
	    return new MoneroBlockTemplate(await this._invokeWorker("daemonGetBlockTemplate", Array.from(arguments)));
	  }
	  
	  async getLastBlockHeader() {
	    return new MoneroBlockHeader(await this._invokeWorker("daemonGetLastBlockHeader"));
	  }
	  
	  async getBlockHeaderByHash(blockHash) {
	    return new MoneroBlockHeader(await this._invokeWorker("daemonGetBlockHeaderByHash", Array.from(arguments)));
	  }
	  
	  async getBlockHeaderByHeight(height) {
	    return new MoneroBlockHeader(await this._invokeWorker("daemonGetBlockHeaderByHeight", Array.from(arguments)));
	  }
	  
	  async getBlockHeadersByRange(startHeight, endHeight) {
	    let blockHeadersJson = await this._invokeWorker("daemonGetBlockHeadersByRange", Array.from(arguments));
	    let headers = [];
	    for (let blockHeaderJson of blockHeadersJson) headers.push(new MoneroBlockHeader(blockHeaderJson));
	    return headers;
	  }
	  
	  async getBlockByHash(blockHash) {
	    return new MoneroBlock(await this._invokeWorker("daemonGetBlockByHash", Array.from(arguments)));
	  }
	  
	  async getBlocksByHash(blockHashes, startHeight, prune) {
	    let blocksJson = await this._invokeWorker("daemonGetBlocksByHash", Array.from(arguments));
	    let blocks = [];
	    for (let blockJson of blocksJson) blocks.push(new MoneroBlock(blockJson));
	    return blocks;
	  }
	  
	  async getBlockByHeight(height) {
	    return new MoneroBlock(await this._invokeWorker("daemonGetBlockByHeight", Array.from(arguments)));
	  }
	  
	  async getBlocksByHeight(heights) {
	    let blocksJson = await this._invokeWorker("daemonGetBlocksByHeight", Array.from(arguments));
	    let blocks = [];
	    for (let blockJson of blocksJson) blocks.push(new MoneroBlock(blockJson));
	    return blocks;
	  }
	  
	  async getBlocksByRange(startHeight, endHeight) {
	    let blocksJson = await this._invokeWorker("daemonGetBlocksByRange", Array.from(arguments));
	    let blocks = [];
	    for (let blockJson of blocksJson) blocks.push(new MoneroBlock(blockJson));
	    return blocks;
	  }
	  
	  async getBlocksByRangeChunked(startHeight, endHeight, maxChunkSize) {
	    let blocksJson = await this._invokeWorker("daemonGetBlocksByRangeChunked", Array.from(arguments));
	    let blocks = [];
	    for (let blockJson of blocksJson) blocks.push(new MoneroBlock(blockJson));
	    return blocks;
	  }
	  
	  async getBlockHashes(blockHashes, startHeight) {
	    return this._invokeWorker("daemonGetBlockHashes", Array.from(arguments));
	  }
	  
	  async getTxs(txHashes, prune = false) {
	    
	    // deserialize txs from blocks
	    let blocks = [];
	    for (let blockJson of await this._invokeWorker("daemonGetTxs", Array.from(arguments))) {
	      blocks.push(new MoneroBlock(blockJson));
	    }
	    
	    // collect txs
	    let txs = [];
	    for (let block of blocks) {
	      for (let tx of block.getTxs()) {
	        if (!tx.isConfirmed()) tx.setBlock(undefined);
	        txs.push(tx);
	      }
	    }
	    return txs;
	  }
	  
	  async getTxHexes(txHashes, prune = false) {
	    return this._invokeWorker("daemonGetTxHexes", Array.from(arguments));
	  }
	  
	  async getMinerTxSum(height, numBlocks) {
	    return new MoneroMinerTxSum(await this._invokeWorker("daemonGetMinerTxSum", Array.from(arguments)));
	  }
	  
	  async getFeeEstimate(graceBlocks) {
	    return BigInteger.parse(await this._invokeWorker("daemonGetFeeEstimate", Array.from(arguments)));
	  }
	  
	  async submitTxHex(txHex, doNotRelay) {
	    return new MoneroSubmitTxResult(await this._invokeWorker("daemonSubmitTxHex", Array.from(arguments)));
	  }
	  
	  async relayTxsByHash(txHashes) {
	    return this._invokeWorker("daemonRelayTxsByHash", Array.from(arguments));
	  }
	  
	  async getTxPool() {
	    let blockJson = await this._invokeWorker("daemonGetTxPool");
	    let txs = new MoneroBlock(blockJson).getTxs();
	    for (let tx of txs) tx.setBlock(undefined);
	    return txs ? txs : [];
	  }
	  
	  async getTxPoolHashes() {
	    return this._invokeWorker("daemonGetTxPoolHashes", Array.from(arguments));
	  }
	  
	  async getTxPoolBacklog() {
	    throw new MoneroError("Not implemented");
	  }
	  
	  async getTxPoolStats() {
	    return new MoneroTxPoolStats(await this._invokeWorker("daemonGetTxPoolStats"));
	  }
	  
	  async flushTxPool(hashes) {
	    return this._invokeWorker("daemonFlushTxPool", Array.from(arguments));
	  }
	  
	  async getKeyImageSpentStatuses(keyImages) {
	    return this._invokeWorker("daemonGetKeyImageSpentStatuses", Array.from(arguments));
	  }
	  
	  async getOutputs(outputs) {
	    throw new MoneroError("Not implemented");
	  }
	  
	  async getOutputHistogram(amounts, minCount, maxCount, isUnlocked, recentCutoff) {
	    let entries = [];
	    for (let entryJson of await this._invokeWorker("daemonGetOutputHistogram", [amounts, minCount, maxCount, isUnlocked, recentCutoff])) {
	      entries.push(new MoneroOutputHistogramEntry(entryJson));
	    }
	    return entries;
	  }
	  
	  async getOutputDistribution(amounts, cumulative, startHeight, endHeight) {
	    throw new MoneroError("Not implemented");
	  }
	  
	  async getInfo() {
	    return new MoneroDaemonInfo(await this._invokeWorker("daemonGetInfo"));
	  }
	  
	  async getSyncInfo() {
	    return new MoneroDaemonSyncInfo(await this._invokeWorker("daemonGetSyncInfo"));
	  }
	  
	  async getHardForkInfo() {
	    return new MoneroHardForkInfo(await this._invokeWorker("daemonGetHardForkInfo"));
	  }
	  
	  async getAltChains() {
	    let altChains = [];
	    for (let altChainJson of await this._invokeWorker("daemonGetAltChains")) altChains.push(new MoneroAltChain(altChainJson));
	    return altChains;
	  }
	  
	  async getAltBlockHashes() {
	    return this._invokeWorker("daemonGetAltBlockHashes");
	  }
	  
	  async getDownloadLimit() {
	    return this._invokeWorker("daemonGetDownloadLimit");
	  }
	  
	  async setDownloadLimit(limit) {
	    return this._invokeWorker("daemonSetDownloadLimit", Array.from(arguments));
	  }
	  
	  async resetDownloadLimit() {
	    return this._invokeWorker("daemonResetDownloadLimit");
	  }
	  
	  async getUploadLimit() {
	    return this._invokeWorker("daemonGetUploadLimit");
	  }
	  
	  async setUploadLimit(limit) {
	    return this._invokeWorker("daemonSetUploadLimit", Array.from(arguments));
	  }
	  
	  async resetUploadLimit() {
	    return this._invokeWorker("daemonResetUploadLimit");
	  }
	  
	  async getPeers() {
	    let peers = [];
	    for (let peerJson of await this._invokeWorker("daemonGetPeers")) peers.push(new MoneroPeer(peerJson));
	    return peers;
	  }
	  
	  async getKnownPeers() {
	    let peers = [];
	    for (let peerJson of await this._invokeWorker("daemonGetKnownPeers")) peers.push(new MoneroPeer(peerJson));
	    return peers;
	  }
	  
	  async setOutgoingPeerLimit(limit) {
	    return this._invokeWorker("daemonSetIncomingPeerLimit", Array.from(arguments));
	  }
	  
	  async setIncomingPeerLimit(limit) {
	    return this._invokeWorker("daemonSetIncomingPeerLimit", Array.from(arguments));
	  }
	  
	  async getPeerBans() {
	    let bans = [];
	    for (let banJson of await this._invokeWorker("daemonGetPeerBans")) bans.push(new MoneroBan(banJson));
	    return bans;
	  }

	  async setPeerBans(bans) {
	    let bansJson = [];
	    for (let ban of bans) bansJson.push(ban.toJson());
	    return this._invokeWorker("daemonSetPeerBans", [bansJson]);
	  }
	  
	  async startMining(address, numThreads, isBackground, ignoreBattery) {
	    return this._invokeWorker("daemonStartMining", Array.from(arguments));
	  }
	  
	  async stopMining() {
	    await this._invokeWorker("daemonStopMining");
	  }
	  
	  async getMiningStatus() {
	    return new MoneroMiningStatus(await this._invokeWorker("daemonGetMiningStatus"));
	  }
	  
	  async submitBlocks(blockBlobs) {
	    throw new MoneroError("Not implemented");
	  }
	  
	  async checkForUpdate() {
	    throw new MoneroError("Not implemented");
	  }
	  
	  async downloadUpdate(path) {
	    throw new MoneroError("Not implemented");
	  }
	  
	  async stop() {
	    while (this.wrappedListeners.length) await this.removeBlockListener(this.wrappedListeners[0].getListener());
	    return this._invokeWorker("daemonStop");
	  }
	  
	  async waitForNextBlockHeader() {
	    return new MoneroBlockHeader(await this._invokeWorker("daemonWaitForNextBlockHeader"));
	  }
	  
	  // --------------------------- PRIVATE HELPERS ------------------------------
	  
	  // TODO: duplicated with MoneroWalletFullProxy
	  async _invokeWorker(fnName, args) {
	    return LibraryUtils.invokeWorker(this.daemonId, fnName, args);
	  }
	}

	/**
	 * Polls a Monero daemon for updates and notifies listeners as they occur.
	 * 
	 * @class
	 * @ignore
	 */
	class DaemonPoller {
	  
	  constructor(daemon) {
	    let that = this;
	    this._daemon = daemon;
	    this._looper = new TaskLooper(async function() { await that.poll(); });
	  }
	  
	  setIsPolling(isPolling) {
	    this._isPolling = isPolling;
	    if (isPolling) this._looper.start(this._daemon.config.pollInterval);
	    else this._looper.stop();
	  }
	  
	  async poll() {
	    try {
	      
	      // get latest block header
	      let header = await this._daemon.getLastBlockHeader();
	      
	      // save first header for comparison
	      if (!this._lastHeader) {
	        this._lastHeader = await this._daemon.getLastBlockHeader();
	        return;
	      }
	      
	      // compare header to last
	      if (header.getHash() !== this._lastHeader.getHash()) {
	        this._lastHeader = header;
	        for (let listener of this._daemon.getListeners()) {
	          await listener.onBlockHeader(header); // notify listener
	        }
	      }
	    } catch (err) {
	      console.error("Failed to background poll daemon header");
	      console.error(err);
	    }
	  }
	}

	/**
	 * Internal listener to bridge notifications to external listeners.
	 * 
	 * @private
	 */
	class DaemonWorkerListener {
	  
	  constructor(listener) {
	    this._id = GenUtils.getUUID();
	    this._listener = listener;
	  }
	  
	  getId() {
	    return this._id;
	  }
	  
	  getListener() {
	    return this._listener;
	  }
	  
	  async onBlockHeader(headerJson) {
	    return this._listener.onBlockHeader(new MoneroBlockHeader(headerJson));
	  }
	}

	MoneroDaemonRpc_1 = MoneroDaemonRpc;
	return MoneroDaemonRpc_1;
}

var MoneroWalletRpc_1;
var hasRequiredMoneroWalletRpc;

function requireMoneroWalletRpc () {
	if (hasRequiredMoneroWalletRpc) return MoneroWalletRpc_1;
	hasRequiredMoneroWalletRpc = 1;
	const assert = require$$0;
	const BigInteger = biginteger.BigInteger;
	const GenUtils = GenUtils_1;
	const LibraryUtils = requireLibraryUtils();
	const TaskLooper = TaskLooper_1;
	const MoneroAccount = MoneroAccount_1;
	const MoneroAccountTag = MoneroAccountTag_1;
	const MoneroAddressBookEntry = MoneroAddressBookEntry_1;
	const MoneroBlock = MoneroBlock_1;
	const MoneroBlockHeader = MoneroBlockHeader_1;
	const MoneroCheckReserve = MoneroCheckReserve_1;
	const MoneroCheckTx = MoneroCheckTx_1;
	const MoneroDestination = MoneroDestination_1;
	const MoneroError = MoneroError_1;
	const MoneroIncomingTransfer = MoneroIncomingTransfer_1;
	const MoneroIntegratedAddress = MoneroIntegratedAddress_1;
	const MoneroKeyImage = MoneroKeyImage_1;
	const MoneroKeyImageImportResult = MoneroKeyImageImportResult_1;
	const MoneroMultisigInfo = MoneroMultisigInfo_1;
	const MoneroMultisigInitResult = MoneroMultisigInitResult_1;
	const MoneroMultisigSignResult = MoneroMultisigSignResult_1;
	const MoneroOutgoingTransfer = MoneroOutgoingTransfer_1;
	const MoneroOutputQuery = requireMoneroOutputQuery();
	const MoneroOutputWallet = MoneroOutputWallet_1;
	const MoneroRpcConnection = requireMoneroRpcConnection();
	const MoneroRpcError = MoneroRpcError_1;
	const MoneroSubaddress = MoneroSubaddress_1;
	const MoneroSyncResult = MoneroSyncResult_1;
	const MoneroTransferQuery = requireMoneroTransferQuery();
	const MoneroTxConfig = MoneroTxConfig_1;
	const MoneroTxQuery = requireMoneroTxQuery();
	const MoneroTxSet = requireMoneroTxSet();
	const MoneroTxWallet = requireMoneroTxWallet();
	const MoneroUtils = requireMoneroUtils();
	const MoneroVersion = MoneroVersion_1;
	const MoneroWallet = MoneroWallet_1;
	const MoneroWalletConfig = requireMoneroWalletConfig();
	const MoneroWalletListener = MoneroWalletListener_1;
	const MoneroMessageSignatureType = MoneroMessageSignatureType_1;
	const MoneroMessageSignatureResult = MoneroMessageSignatureResult_1;
	const ThreadPool = ThreadPool_1;
	const SslOptions = SslOptions_1;

	/**
	 * Copyright (c) woodser
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in all
	 * copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	 * SOFTWARE.
	 */

	/**
	 * Implements a MoneroWallet as a client of monero-wallet-rpc.
	 * 
	 * @implements {MoneroWallet}
	 * @hideconstructor
	 */
	class MoneroWalletRpc extends MoneroWallet {
	  
	  /**
	   * <p>Construct a wallet RPC client (for internal use).</p>
	   * 
	   * @param {string|object|MoneroRpcConnection|string[]} uriOrConfig - uri of monero-wallet-rpc or JS config object or MoneroRpcConnection or command line parameters to run a monero-wallet-rpc process internally
	   * @param {string} uriOrConfig.uri - uri of monero-wallet-rpc
	   * @param {string} uriOrConfig.username - username to authenticate with monero-wallet-rpc (optional)
	   * @param {string} uriOrConfig.password - password to authenticate with monero-wallet-rpc (optional)
	   * @param {boolean} uriOrConfig.rejectUnauthorized - rejects self-signed certificates if true (default true)
	   * @param {string} username - username to authenticate with monero-wallet-rpc (optional)
	   * @param {string} password - password to authenticate with monero-wallet-rpc (optional)
	   * @param {boolean} rejectUnauthorized - rejects self-signed certificates if true (default true)
	   */
	  constructor(uriOrConfig, username, password, rejectUnauthorized) {
	    super();
	    if (GenUtils.isArray(uriOrConfig)) throw new MoneroError("Array with command parameters is invalid first parameter, use `await monerojs.connectToWalletRpc(...)`");
	    this.config = MoneroWalletRpc._normalizeConfig(uriOrConfig, username, password, rejectUnauthorized);
	    this.rpc = new MoneroRpcConnection(this.config);
	    this.addressCache = {}; // avoid unecessary requests for addresses
	    this.syncPeriodInMs = MoneroWalletRpc.DEFAULT_SYNC_PERIOD_IN_MS;
	    this.listeners = [];
	  }
	  
	  /**
	   * <p>Create a client connected to monero-wallet-rpc (for internal use).</p>
	   * 
	   * @param {string|string[]|object|MoneroRpcConnection} uriOrConfig - uri of monero-wallet-rpc or terminal parameters or JS config object or MoneroRpcConnection
	   * @param {string} uriOrConfig.uri - uri of monero-wallet-rpc
	   * @param {string} uriOrConfig.username - username to authenticate with monero-wallet-rpc (optional)
	   * @param {string} uriOrConfig.password - password to authenticate with monero-wallet-rpc (optional)
	   * @param {boolean} uriOrConfig.rejectUnauthorized - rejects self-signed certificates if true (default true)
	   * @param {string} username - username to authenticate with monero-wallet-rpc (optional)
	   * @param {string} password - password to authenticate with monero-wallet-rpc (optional)
	   * @param {boolean} rejectUnauthorized - rejects self-signed certificates if true (default true)
	   * @return {MoneroWalletRpc} the wallet RPC client
	   */
	  static async _connectToWalletRpc(uriOrConfig, username, password, rejectUnauthorized) {
	    if (GenUtils.isArray(uriOrConfig)) return MoneroWalletRpc._startWalletRpcProcess(uriOrConfig); // handle array as terminal command
	    else return new MoneroWalletRpc(...arguments); // otherwise connect to server
	  }
	  
	  static async _startWalletRpcProcess(cmd) {
	    assert(GenUtils.isArray(cmd), "Must provide string array with command line parameters");
	    
	    // start process
	    this.process = require$$29.spawn(cmd[0], cmd.slice(1), {});
	    this.process.stdout.setEncoding('utf8');
	    this.process.stderr.setEncoding('utf8');
	    
	    // return promise which resolves after starting monero-wallet-rpc
	    let uri;
	    let that = this;
	    let output = "";
	    return new Promise(function(resolve, reject) {
	      
	      // handle stdout
	      that.process.stdout.on('data', function(data) {
	        let line = data.toString();
	        LibraryUtils.log(2, line);
	        output += line + '\n'; // capture output in case of error
	        
	        // extract uri from e.g. "I Binding on 127.0.0.1 (IPv4):38085"
	        let uriLineContains = "Binding on ";
	        let uriLineContainsIdx = line.indexOf(uriLineContains);
	        if (uriLineContainsIdx >= 0) {
	          let host = line.substring(uriLineContainsIdx + uriLineContains.length, line.lastIndexOf(' '));
	          let unformattedLine = line.replace(/\u001b\[.*?m/g, '').trim(); // remove color formatting
	          let port = unformattedLine.substring(unformattedLine.lastIndexOf(':') + 1);
	          let sslIdx = cmd.indexOf("--rpc-ssl");
	          let sslEnabled = sslIdx >= 0 ? "enabled" == cmd[sslIdx + 1].toLowerCase() : false;
	          uri = (sslEnabled ? "https" : "http") + "://" + host + ":" + port;
	        }
	        
	        // read success message
	        if (line.indexOf("Starting wallet RPC server") >= 0) {
	          
	          // get username and password from params
	          let userPassIdx = cmd.indexOf("--rpc-login");
	          let userPass = userPassIdx >= 0 ? cmd[userPassIdx + 1] : undefined;
	          let username = userPass === undefined ? undefined : userPass.substring(0, userPass.indexOf(':'));
	          let password = userPass === undefined ? undefined : userPass.substring(userPass.indexOf(':') + 1);
	          
	          // create client connected to internal process
	          let wallet = new MoneroWalletRpc(uri, username, password);
	          wallet.process = that.process;
	          
	          // resolve promise with client connected to internal process 
	          this.isResolved = true;
	          resolve(wallet);
	        }
	      });
	      
	      // handle stderr
	      that.process.stderr.on('data', function(data) {
	        if (LibraryUtils.getLogLevel() >= 2) console.error(data);
	      });
	      
	      // handle exit
	      that.process.on("exit", function(code) {
	        if (!this.isResolved) reject(new MoneroError("monero-wallet-rpc process terminated with exit code " + code + (output ? ":\n\n" + output : "")));
	      });
	      
	      // handle error
	      that.process.on("error", function(err) {
	        if (err.message.indexOf("ENOENT") >= 0) reject(new MoneroError("monero-wallet-rpc does not exist at path '" + cmd[0] + "'"));
	        if (!this.isResolved) reject(err);
	      });
	      
	      // handle uncaught exception
	      that.process.on("uncaughtException", function(err, origin) {
	        console.error("Uncaught exception in monero-wallet-rpc process: " + err.message);
	        console.error(origin);
	        reject(err);
	      });
	    });
	  }
	  
	  // --------------------------- RPC WALLET METHODS ---------------------------
	  
	  /**
	   * Get the internal process running monero-wallet-rpc.
	   * 
	   * @return the process running monero-wallet-rpc, undefined if not created from new process
	   */
	  getProcess() {
	    return this.process;
	  }
	  
	  /**
	   * Stop the internal process running monero-wallet-rpc, if applicable.
	   */
	  async stopProcess() {
	    if (this.process === undefined) throw new MoneroError("MoneroWalletRpc instance not created from new process");
	    let listenersCopy = GenUtils.copyArray(this.getListeners());
	    for (let listener of listenersCopy) await this.removeListener(listener);
	    return GenUtils.killProcess(this.process);
	  }
	  
	  /**
	   * Get the wallet's RPC connection.
	   * 
	   * @return {MoneroWalletRpc} the wallet's rpc connection
	   */
	  getRpcConnection() {
	    return this.rpc;
	  }
	  
	  /**
	   * <p>Open an existing wallet on the monero-wallet-rpc server.</p>
	   * 
	   * <p>Example:<p>
	   * 
	   * <code>
	   * let wallet = new MoneroWalletRpc("http://localhost:38084", "rpc_user", "abc123");<br>
	   * await wallet.openWallet("mywallet1", "supersecretpassword");<br>
	   * await wallet.openWallet({<br>
	   * &nbsp;&nbsp; path: "mywallet2",<br>
	   * &nbsp;&nbsp; password: "supersecretpassword",<br>
	   * &nbsp;&nbsp; serverUri: "http://locahost:38081",<br>
	   * &nbsp;&nbsp; rejectUnauthorized: false<br>
	   * });<br>
	   * </code>
	   * 
	   * @param {string|object|MoneroWalletConfig} pathOrConfig  - the wallet's name or configuration to open
	   * @param {string} pathOrConfig.path - path of the wallet to create (optional, in-memory wallet if not given)
	   * @param {string} pathOrConfig.password - password of the wallet to create
	   * @param {string} pathOrConfig.serverUri - uri of a daemon to use (optional, monero-wallet-rpc usually started with daemon config)
	   * @param {string} pathOrConfig.serverUsername - username to authenticate with the daemon (optional)
	   * @param {string} pathOrConfig.serverPassword - password to authenticate with the daemon (optional)
	   * @param {boolean} pathOrConfig.rejectUnauthorized - reject self-signed server certificates if true (defaults to true)
	   * @param {MoneroRpcConnection|object} pathOrConfig.server - MoneroRpcConnection or equivalent JS object providing daemon configuration (optional)
	   * @param {string} password is the wallet's password
	   * @return {MoneroWalletRpc} this wallet client
	   */
	  async openWallet(pathOrConfig, password) {
	    
	    // normalize and validate config
	    let config = new MoneroWalletConfig(typeof pathOrConfig === "string" ? {path: pathOrConfig, password: password} : pathOrConfig);
	    // TODO: ensure other fields are uninitialized?
	    
	    // open wallet on rpc server
	    if (!config.getPath()) throw new MoneroError("Must provide name of wallet to open");
	    if (!config.getPassword()) throw new MoneroError("Must provide password of wallet to open");
	    await this.rpc.sendJsonRequest("open_wallet", {filename: config.getPath(), password: config.getPassword()});
	    await this._clear();
	    this.path = config.getPath();
	    
	    // set daemon if provided
	    if (config.getServer()) return this.setDaemonConnection(config.getServer());
	    return this;
	  }
	  
	  /**
	   * <p>Create and open a wallet on the monero-wallet-rpc server.<p>
	   * 
	   * <p>Example:<p>
	   * 
	   * <code>
	   * &sol;&sol; construct client to monero-wallet-rpc<br>
	   * let walletRpc = new MoneroWalletRpc("http://localhost:38084", "rpc_user", "abc123");<br><br>
	   * 
	   * &sol;&sol; create and open wallet on monero-wallet-rpc<br>
	   * await walletRpc.createWallet({<br>
	   * &nbsp;&nbsp; path: "mywallet",<br>
	   * &nbsp;&nbsp; password: "abc123",<br>
	   * &nbsp;&nbsp; mnemonic: "coexist igloo pamphlet lagoon...",<br>
	   * &nbsp;&nbsp; restoreHeight: 1543218l<br>
	   * });
	   *  </code>
	   * 
	   * @param {object|MoneroWalletConfig} config - MoneroWalletConfig or equivalent JS object
	   * @param {string} config.path - path of the wallet to create (optional, in-memory wallet if not given)
	   * @param {string} config.password - password of the wallet to create
	   * @param {string} config.mnemonic - mnemonic of the wallet to create (optional, random wallet created if neither mnemonic nor keys given)
	   * @param {string} config.seedOffset - the offset used to derive a new seed from the given mnemonic to recover a secret wallet from the mnemonic phrase
	   * @param {string} config.primaryAddress - primary address of the wallet to create (only provide if restoring from keys)
	   * @param {string} config.privateViewKey - private view key of the wallet to create (optional)
	   * @param {string} config.privateSpendKey - private spend key of the wallet to create (optional)
	   * @param {number} config.restoreHeight - block height to start scanning from (defaults to 0 unless generating random wallet)
	   * @param {string} config.language - language of the wallet's mnemonic phrase (defaults to "English" or auto-detected)
	   * @param {string} config.serverUri - uri of a daemon to use (optional, monero-wallet-rpc usually started with daemon config)
	   * @param {string} config.serverUsername - username to authenticate with the daemon (optional)
	   * @param {string} config.serverPassword - password to authenticate with the daemon (optional)
	   * @param {boolean} config.rejectUnauthorized - reject self-signed server certificates if true (defaults to true)
	   * @param {MoneroRpcConnection|object} config.server - MoneroRpcConnection or equivalent JS object providing daemon configuration (optional)
	   * @param {boolean} config.saveCurrent - specifies if the current RPC wallet should be saved before being closed (default true)
	   * @return {MoneroWalletRpc} this wallet client
	   */
	  async createWallet(config) {
	    
	    // normalize and validate config
	    if (config === undefined) throw new MoneroError("Must provide config to create wallet");
	    config = config instanceof MoneroWalletConfig ? config : new MoneroWalletConfig(config);
	    if (config.getMnemonic() !== undefined && (config.getPrimaryAddress() !== undefined || config.getPrivateViewKey() !== undefined || config.getPrivateSpendKey() !== undefined)) {
	      throw new MoneroError("Wallet may be initialized with a mnemonic or keys but not both");
	    }
	    if (config.getNetworkType() !== undefined) throw new MoneroError("Cannot provide networkType when creating RPC wallet because server's network type is already set");
	    
	    // create wallet
	    if (config.getMnemonic() !== undefined) {
	      await this._createWalletFromMnemonic(config.getPath(), config.getPassword(), config.getMnemonic(), config.getRestoreHeight(), config.getLanguage(), config.getSeedOffset(), config.getSaveCurrent());
	    } else if (config.getPrivateSpendKey() !== undefined || config.getPrimaryAddress() !== undefined) {
	      if (config.getSeedOffset() !== undefined) throw new MoneroError("Cannot provide seedOffset when creating wallet from keys");
	      await this._createWalletFromKeys(config.getPath(), config.getPassword(), config.getPrimaryAddress(), config.getPrivateViewKey(), config.getPrivateSpendKey(), config.getRestoreHeight(), config.getLanguage(), config.getSaveCurrent());
	    } else {
	      if (config.getSeedOffset() !== undefined) throw new MoneroError("Cannot provide seedOffset when creating random wallet");
	      if (config.getRestoreHeight() !== undefined) throw new MoneroError("Cannot provide restoreHeight when creating random wallet");
	      if (config.getSaveCurrent() === false) throw new MoneroError("Current wallet is saved automatically when creating random wallet");
	      await this._createWalletRandom(config.getPath(), config.getPassword(), config.getLanguage());
	    }
	    
	    // set daemon if provided
	    if (config.getServer()) return this.setDaemonConnection(config.getServer());
	    return this;
	  }
	  
	  /**
	   * Create and open a new wallet with a randomly generated seed on the RPC server.
	   * 
	   * @param {string} name - name of the wallet file to create
	   * @param {string} password - wallet's password
	   * @param {string} language - language for the wallet's mnemonic phrase
	   * @return {MoneroWalletRpc} this wallet client
	   */
	  async _createWalletRandom(name, password, language) {
	    if (!name) throw new MoneroError("Name is not initialized");
	    if (!password) throw new MoneroError("Password is not initialized");
	    if (!language) language = MoneroWallet.DEFAULT_LANGUAGE;
	    let params = { filename: name, password: password, language: language };
	    try {
	      await this.rpc.sendJsonRequest("create_wallet", params);
	    } catch (err) {
	      this._handleCreateWalletError(name, err);
	    }
	    await this._clear();
	    this.path = name;
	    return this;
	  }
	  
	  /**
	   * Create and open a wallet from an existing mnemonic phrase on the RPC server,
	   * closing the currently open wallet if applicable.
	   * 
	   * @param {string} name - name of the wallet to create on the RPC server
	   * @param {string} password - wallet's password
	   * @param {string} mnemonic - mnemonic of the wallet to construct
	   * @param {int} restoreHeight - block height to restore from (default = 0)
	   * @param {string} language - language of the mnemonic in case the old language is invalid
	   * @param {string} seedOffset - offset used to derive a new seed from the given mnemonic to recover a secret wallet from the mnemonic phrase
	   * @param {boolean} saveCurrent - specifies if the current RPC wallet should be saved before being closed
	   * @return {MoneroWalletRpc} this wallet client
	   */
	  async _createWalletFromMnemonic(name, password, mnemonic, restoreHeight, language, seedOffset, saveCurrent) {
	    try {
	      await this.rpc.sendJsonRequest("restore_deterministic_wallet", {
	        filename: name,
	        password: password,
	        seed: mnemonic,
	        seed_offset: seedOffset,
	        restore_height: restoreHeight,
	        language: language,
	        autosave_current: saveCurrent
	      });
	    } catch (err) {
	      this._handleCreateWalletError(name, err);
	    }
	    await this._clear();
	    this.path = name;
	    return this;
	  }
	  
	  /**
	   * Create a wallet on the RPC server from an address, view key, and (optionally) spend key.
	   * 
	   * @param name - name of the wallet to create on the RPC server
	   * @param password - password encrypt the wallet
	   * @param networkType - wallet's network type
	   * @param address - address of the wallet to construct
	   * @param viewKey - view key of the wallet to construct
	   * @param spendKey - spend key of the wallet to construct or null to create a view-only wallet
	   * @param restoreHeight - block height to restore (i.e. scan the chain) from (default = 0)
	   * @param language - wallet and mnemonic's language (default = "English")
	   * @return {MoneroWalletRpc} this wallet client
	   */
	  async _createWalletFromKeys(name, password, address, viewKey, spendKey, restoreHeight, language, saveCurrent) {
	    if (restoreHeight === undefined) restoreHeight = 0;
	    if (language === undefined) language = MoneroWallet.DEFAULT_LANGUAGE;
	    try {
	      await this.rpc.sendJsonRequest("generate_from_keys", {
	        filename: name,
	        password: password,
	        address: address,
	        viewkey: viewKey,
	        spendkey: spendKey,
	        restore_height: restoreHeight,
	        autosave_current: saveCurrent
	      });
	    } catch (err) {
	      this._handleCreateWalletError(name, err);
	    }
	    await this._clear();
	    this.path = name;
	    return this;
	  }
	  
	  _handleCreateWalletError(name, err) {
	    if (err.message === "Cannot create wallet. Already exists.") throw new MoneroRpcError("Wallet already exists: " + name, err.getCode(), err.getRpcMethod(), err.getRpcParams());
	    if (err.message === "Electrum-style word list failed verification") throw new MoneroRpcError("Invalid mnemonic", err.getCode(), err.getRpcMethod(), err.getRpcParams());
	    throw err;
	  }
	  
	  async isViewOnly() {
	    try {
	      await this.rpc.sendJsonRequest("query_key", {key_type: "mnemonic"});
	      return false; // key retrieval succeeds if not view only
	    } catch (e) {
	      if (e.getCode() === -29) return true;  // wallet is view only
	      if (e.getCode() === -1) return false;  // wallet is offline but not view only
	      throw e;
	    }
	  }
	  
	  /**
	   * Set the wallet's daemon connection.
	   * 
	   * @param {string|MoneroRpcConnection} uriOrConnection - the daemon's URI or connection (defaults to offline)
	   * @param {boolean} isTrusted - indicates if the daemon in trusted
	   * @param {SslOptions} sslOptions - custom SSL configuration
	   */
	  async setDaemonConnection(uriOrRpcConnection, isTrusted, sslOptions) {
	    let connection = !uriOrRpcConnection ? undefined : uriOrRpcConnection instanceof MoneroRpcConnection ? uriOrRpcConnection : new MoneroRpcConnection(uriOrRpcConnection);
	    if (!sslOptions) sslOptions = new SslOptions();
	    let params = {};
	    params.address = connection ? connection.getUri() : "bad_uri"; // TODO monero-wallet-rpc: bad daemon uri necessary for offline?
	    params.username = connection ? connection.getUsername() : "";
	    params.password = connection ? connection.getPassword() : "";
	    params.trusted = isTrusted;
	    params.ssl_support = "autodetect";
	    params.ssl_private_key_path = sslOptions.getPrivateKeyPath();
	    params.ssl_certificate_path  = sslOptions.getCertificatePath();
	    params.ssl_ca_file = sslOptions.getCertificateAuthorityFile();
	    params.ssl_allowed_fingerprints = sslOptions.getAllowedFingerprints();
	    params.ssl_allow_any_cert = sslOptions.getAllowAnyCert();
	    await this.rpc.sendJsonRequest("set_daemon", params);
	    this.daemonConnection = connection;
	  }
	  
	  async getDaemonConnection() {
	    return this.daemonConnection;
	  }
	  
	  // -------------------------- COMMON WALLET METHODS -------------------------
	  
	  async addListener(listener) {
	    assert(listener instanceof MoneroWalletListener, "Listener must be instance of MoneroWalletListener");
	    this.listeners.push(listener);
	    this._refreshListening();
	  }
	  
	  async removeListener(listener) {
	    let idx = this.listeners.indexOf(listener);
	    if (idx > -1) this.listeners.splice(idx, 1);
	    else throw new MoneroError("Listener is not registered with wallet");
	    this._refreshListening();
	  }
	  
	  getListeners() {
	    return this.listeners;
	  }
	  
	  async isConnectedToDaemon() {
	    try {
	      await this.checkReserveProof(await this.getPrimaryAddress(), "", ""); // TODO (monero-project): provide better way to know if wallet rpc is connected to daemon
	      throw new MoneroError("check reserve expected to fail");
	    } catch (e) {
	      return e.message.indexOf("Failed to connect to daemon") < 0;
	    }
	  }
	  
	  async getVersion() {
	    let resp = await this.rpc.sendJsonRequest("get_version");
	    return new MoneroVersion(resp.result.version, resp.result.release);
	  }
	  
	  async getPath() {
	    return this.path;
	  }
	  
	  async getMnemonic() {
	    try {
	      let resp = await this.rpc.sendJsonRequest("query_key", { key_type: "mnemonic" });
	      return resp.result.key;
	    } catch (e) {
	      if (e.getCode() === -29) return undefined;  // wallet is view-only
	      throw e;
	    }
	  }
	  
	  async getMnemonicLanguage() {
	    if (await this.getMnemonic() === undefined) return undefined;
	    throw new MoneroError("MoneroWalletRpc.getMnemonicLanguage() not supported");
	  }

	  /**
	   * Get a list of available languages for the wallet's mnemonic phrase.
	   * 
	   * @return {string[]} the available languages for the wallet's mnemonic phrase
	   */
	  async getMnemonicLanguages() {
	    return (await this.rpc.sendJsonRequest("get_languages")).result.languages;
	  }
	  
	  async getPrivateViewKey() {
	    let resp = await this.rpc.sendJsonRequest("query_key", { key_type: "view_key" });
	    return resp.result.key;
	  }
	  
	  async getPrivateSpendKey() {
	    
	    // get private spend key which will throw error if wallet is view-only
	    try {
	      let resp = await this.rpc.sendJsonRequest("query_key", { key_type: "spend_key" });
	      return resp.result.key;
	    } catch (e) {
	      if (e.getCode() === -29 && e.message.indexOf("watch-only") !== -1) return undefined; // return undefined if wallet is view-only
	      throw e;
	    }
	  }
	  
	  async getAddress(accountIdx, subaddressIdx) {
	    let subaddressMap = this.addressCache[accountIdx];
	    if (!subaddressMap) {
	      await this.getSubaddresses(accountIdx, undefined, true);  // cache's all addresses at this account
	      return this.getAddress(accountIdx, subaddressIdx);        // recursive call uses cache
	    }
	    let address = subaddressMap[subaddressIdx];
	    if (!address) {
	      await this.getSubaddresses(accountIdx, undefined, true);  // cache's all addresses at this account
	      return this.addressCache[accountIdx][subaddressIdx];
	    }
	    return address;
	  }
	  
	  // TODO: use cache
	  async getAddressIndex(address) {
	    
	    // fetch result and normalize error if address does not belong to the wallet
	    let resp;
	    try {
	      resp = await this.rpc.sendJsonRequest("get_address_index", {address: address});
	    } catch (e) {
	      if (e.getCode() === -2) throw new MoneroError(e.message);
	      throw e;
	    }
	    
	    // convert rpc response
	    let subaddress = new MoneroSubaddress(address);
	    subaddress.setAccountIndex(resp.result.index.major);
	    subaddress.setIndex(resp.result.index.minor);
	    return subaddress;
	  }
	  
	  async getIntegratedAddress(standardAddress, paymentId) {
	    try {
	      let integratedAddressStr = (await this.rpc.sendJsonRequest("make_integrated_address", {standard_address: standardAddress, payment_id: paymentId})).result.integrated_address;
	      return await this.decodeIntegratedAddress(integratedAddressStr);
	    } catch (e) {
	      if (e.message.includes("Invalid payment ID")) throw new MoneroError("Invalid payment ID: " + paymentId);
	      throw e;
	    }
	  }
	  
	  async decodeIntegratedAddress(integratedAddress) {
	    let resp = await this.rpc.sendJsonRequest("split_integrated_address", {integrated_address: integratedAddress});
	    return new MoneroIntegratedAddress().setStandardAddress(resp.result.standard_address).setPaymentId(resp.result.payment_id).setIntegratedAddress(integratedAddress);
	  }
	  
	  async getHeight() {
	    return (await this.rpc.sendJsonRequest("get_height")).result.height;
	  }
	  
	  async getDaemonHeight() {
	    throw new MoneroError("monero-wallet-rpc does not support getting the chain height");
	  }
	  
	  async getHeightByDate(year, month, day) {
	    throw new MoneroError("monero-wallet-rpc does not support getting a height by date");
	  }
	  
	  async sync(startHeight, onProgress) {
	    assert(onProgress === undefined, "Monero Wallet RPC does not support reporting sync progress");
	    try {
	      let resp = await this.rpc.sendJsonRequest("refresh", {start_height: startHeight});
	      await this._poll();
	      return new MoneroSyncResult(resp.result.blocks_fetched, resp.result.received_money);
	    } catch (err) {
	      if (err.message === "no connection to daemon") throw new MoneroError("Wallet is not connected to daemon");
	      throw err;
	    }
	  }
	  
	  async startSyncing(syncPeriodInMs) {
	    
	    // convert ms to seconds for rpc parameter
	    let syncPeriodInSeconds = Math.round((syncPeriodInMs === undefined ? MoneroWalletRpc.DEFAULT_SYNC_PERIOD_IN_MS : syncPeriodInMs) / 1000);
	    
	    // send rpc request
	    await this.rpc.sendJsonRequest("auto_refresh", {
	      enable: true,
	      period: syncPeriodInSeconds
	    });
	    
	    // update sync period for poller
	    this.syncPeriodInMs = syncPeriodInSeconds * 1000;
	    if (this.walletPoller !== undefined) this.walletPoller.setPeriodInMs(syncPeriodInMs);
	    
	    // poll if listening
	    await this._poll();
	  }
	  
	  async stopSyncing() {
	    return this.rpc.sendJsonRequest("auto_refresh", { enable: false });
	  }
	  
	  async scanTxs(txHashes) {
	    if (!txHashes || !txHashes.length) throw new MoneroError("No tx hashes given to scan");
	    await this.rpc.sendJsonRequest("scan_tx", {txids: txHashes});
	    await this._poll();
	  }
	  
	  async rescanSpent() {
	    await this.rpc.sendJsonRequest("rescan_spent");
	  }
	  
	  async rescanBlockchain() {
	    await this.rpc.sendJsonRequest("rescan_blockchain");
	  }
	  
	  async getBalance(accountIdx, subaddressIdx) {
	    return (await this._getBalances(accountIdx, subaddressIdx))[0];
	  }
	  
	  async getUnlockedBalance(accountIdx, subaddressIdx) {
	    return (await this._getBalances(accountIdx, subaddressIdx))[1];
	  }
	  
	  async getAccounts(includeSubaddresses, tag, skipBalances) {
	    
	    // fetch accounts from rpc
	    let resp = await this.rpc.sendJsonRequest("get_accounts", {tag: tag});
	    
	    // build account objects and fetch subaddresses per account using get_address
	    // TODO monero-wallet-rpc: get_address should support all_accounts so not called once per account
	    let accounts = [];
	    for (let rpcAccount of resp.result.subaddress_accounts) {
	      let account = MoneroWalletRpc._convertRpcAccount(rpcAccount);
	      if (includeSubaddresses) account.setSubaddresses(await this.getSubaddresses(account.getIndex(), undefined, true));
	      accounts.push(account);
	    }
	    
	    // fetch and merge fields from get_balance across all accounts
	    if (includeSubaddresses && !skipBalances) {
	      
	      // these fields are not initialized if subaddress is unused and therefore not returned from `get_balance`
	      for (let account of accounts) {
	        for (let subaddress of account.getSubaddresses()) {
	          subaddress.setBalance(new BigInteger(0));
	          subaddress.setUnlockedBalance(new BigInteger(0));
	          subaddress.setNumUnspentOutputs(0);
	          subaddress.setNumBlocksToUnlock(0);
	        }
	      }
	      
	      // fetch and merge info from get_balance
	      resp = await this.rpc.sendJsonRequest("get_balance", {all_accounts: true});
	      if (resp.result.per_subaddress) {
	        for (let rpcSubaddress of resp.result.per_subaddress) {
	          let subaddress = MoneroWalletRpc._convertRpcSubaddress(rpcSubaddress);
	          
	          // merge info
	          let account = accounts[subaddress.getAccountIndex()];
	          assert.equal(subaddress.getAccountIndex(), account.getIndex(), "RPC accounts are out of order");  // would need to switch lookup to loop
	          let tgtSubaddress = account.getSubaddresses()[subaddress.getIndex()];
	          assert.equal(subaddress.getIndex(), tgtSubaddress.getIndex(), "RPC subaddresses are out of order");
	          if (subaddress.getBalance() !== undefined) tgtSubaddress.setBalance(subaddress.getBalance());
	          if (subaddress.getUnlockedBalance() !== undefined) tgtSubaddress.setUnlockedBalance(subaddress.getUnlockedBalance());
	          if (subaddress.getNumUnspentOutputs() !== undefined) tgtSubaddress.setNumUnspentOutputs(subaddress.getNumUnspentOutputs());
	        }
	      }
	    }
	    
	    // return accounts
	    return accounts;
	  }
	  
	  // TODO: getAccountByIndex(), getAccountByTag()
	  async getAccount(accountIdx, includeSubaddresses, skipBalances) {
	    assert(accountIdx >= 0);
	    for (let account of await this.getAccounts()) {
	      if (account.getIndex() === accountIdx) {
	        if (includeSubaddresses) account.setSubaddresses(await this.getSubaddresses(accountIdx, undefined, skipBalances));
	        return account;
	      }
	    }
	    throw new Exception("Account with index " + accountIdx + " does not exist");
	  }

	  async createAccount(label) {
	    label = label ? label : undefined;
	    let resp = await this.rpc.sendJsonRequest("create_account", {label: label});
	    return new MoneroAccount(resp.result.account_index, resp.result.address, new BigInteger(0), new BigInteger(0));
	  }

	  async getSubaddresses(accountIdx, subaddressIndices, skipBalances) {
	    
	    // fetch subaddresses
	    let params = {};
	    params.account_index = accountIdx;
	    if (subaddressIndices) params.address_index = GenUtils.listify(subaddressIndices);
	    let resp = await this.rpc.sendJsonRequest("get_address", params);
	    
	    // initialize subaddresses
	    let subaddresses = [];
	    for (let rpcSubaddress of resp.result.addresses) {
	      let subaddress = MoneroWalletRpc._convertRpcSubaddress(rpcSubaddress);
	      subaddress.setAccountIndex(accountIdx);
	      subaddresses.push(subaddress);
	    }
	    
	    // fetch and initialize subaddress balances
	    if (!skipBalances) {
	      
	      // these fields are not initialized if subaddress is unused and therefore not returned from `get_balance`
	      for (let subaddress of subaddresses) {
	        subaddress.setBalance(new BigInteger(0));
	        subaddress.setUnlockedBalance(new BigInteger(0));
	        subaddress.setNumUnspentOutputs(0);
	        subaddress.setNumBlocksToUnlock(0);
	      }

	      // fetch and initialize balances
	      resp = await this.rpc.sendJsonRequest("get_balance", params);
	      if (resp.result.per_subaddress) {
	        for (let rpcSubaddress of resp.result.per_subaddress) {
	          let subaddress = MoneroWalletRpc._convertRpcSubaddress(rpcSubaddress);
	          
	          // transfer info to existing subaddress object
	          for (let tgtSubaddress of subaddresses) {
	            if (tgtSubaddress.getIndex() !== subaddress.getIndex()) continue; // skip to subaddress with same index
	            if (subaddress.getBalance() !== undefined) tgtSubaddress.setBalance(subaddress.getBalance());
	            if (subaddress.getUnlockedBalance() !== undefined) tgtSubaddress.setUnlockedBalance(subaddress.getUnlockedBalance());
	            if (subaddress.getNumUnspentOutputs() !== undefined) tgtSubaddress.setNumUnspentOutputs(subaddress.getNumUnspentOutputs());
	            if (subaddress.getNumBlocksToUnlock() !== undefined) tgtSubaddress.setNumBlocksToUnlock(subaddress.getNumBlocksToUnlock());
	          }
	        }
	      }
	    }
	    
	    // cache addresses
	    let subaddressMap = this.addressCache[accountIdx];
	    if (!subaddressMap) {
	      subaddressMap = {};
	      this.addressCache[accountIdx] = subaddressMap;
	    }
	    for (let subaddress of subaddresses) {
	      subaddressMap[subaddress.getIndex()] = subaddress.getAddress();
	    }
	    
	    // return results
	    return subaddresses;
	  }

	  async getSubaddress(accountIdx, subaddressIdx, skipBalances) {
	    assert(accountIdx >= 0);
	    assert(subaddressIdx >= 0);
	    return (await this.getSubaddresses(accountIdx, subaddressIdx, skipBalances))[0];
	  }

	  async createSubaddress(accountIdx, label) {
	    
	    // send request
	    let resp = await this.rpc.sendJsonRequest("create_address", {account_index: accountIdx, label: label});
	    
	    // build subaddress object
	    let subaddress = new MoneroSubaddress();
	    subaddress.setAccountIndex(accountIdx);
	    subaddress.setIndex(resp.result.address_index);
	    subaddress.setAddress(resp.result.address);
	    subaddress.setLabel(label ? label : undefined);
	    subaddress.setBalance(new BigInteger(0));
	    subaddress.setUnlockedBalance(new BigInteger(0));
	    subaddress.setNumUnspentOutputs(0);
	    subaddress.setIsUsed(false);
	    subaddress.setNumBlocksToUnlock(0);
	    return subaddress;
	  }
	  
	  async getTxs(query, missingTxHashes) {
	    
	    // copy query
	    query = MoneroWallet._normalizeTxQuery(query);
	    
	    // temporarily disable transfer and output queries in order to collect all tx information
	    let transferQuery = query.getTransferQuery();
	    let inputQuery = query.getInputQuery();
	    let outputQuery = query.getOutputQuery();
	    query.setTransferQuery(undefined);
	    query.setInputQuery(undefined);
	    query.setOutputQuery(undefined);
	    
	    // fetch all transfers that meet tx query
	    let transfers = await this._getTransfersAux(new MoneroTransferQuery().setTxQuery(MoneroWalletRpc._decontextualize(query.copy())));
	    
	    // collect unique txs from transfers while retaining order
	    let txs = [];
	    let txsSet = new Set();
	    for (let transfer of transfers) {
	      if (!txsSet.has(transfer.getTx())) {
	        txs.push(transfer.getTx());
	        txsSet.add(transfer.getTx());
	      }
	    }
	    
	    // cache types into maps for merging and lookup
	    let txMap = {};
	    let blockMap = {};
	    for (let tx of txs) {
	      MoneroWalletRpc._mergeTx(tx, txMap, blockMap);
	    }
	    
	    // fetch and merge outputs if requested
	    if (query.getIncludeOutputs() || outputQuery) {
	        
	      // fetch outputs
	      let outputQueryAux = (outputQuery ? outputQuery.copy() : new MoneroOutputQuery()).setTxQuery(MoneroWalletRpc._decontextualize(query.copy()));
	      let outputs = await this._getOutputsAux(outputQueryAux);
	      
	      // merge output txs one time while retaining order
	      let outputTxs = [];
	      for (let output of outputs) {
	        if (!outputTxs.includes(output.getTx())) {
	          MoneroWalletRpc._mergeTx(output.getTx(), txMap, blockMap);
	          outputTxs.push(output.getTx());
	        }
	      }
	    }
	    
	    // restore transfer and output queries
	    query.setTransferQuery(transferQuery);
	    query.setInputQuery(inputQuery);
	    query.setOutputQuery(outputQuery);
	    
	    // filter txs that don't meet transfer query
	    let txsQueried = [];
	    for (let tx of txs) {
	      if (query.meetsCriteria(tx)) txsQueried.push(tx);
	      else if (tx.getBlock() !== undefined) tx.getBlock().getTxs().splice(tx.getBlock().getTxs().indexOf(tx), 1);
	    }
	    txs = txsQueried;
	    
	    // collect unfound tx hashes
	    if (query.getHashes()) {
	      let unfoundTxHashes = [];
	      for (let txHash of query.getHashes()) {
	        let found = false;
	        for (let tx of txs) {
	          if (txHash === tx.getHash()) {
	            found = true;
	            break;
	          }
	        }
	        if (!found) unfoundTxHashes.push(txHash);
	      }
	     
	      // if txs not found, collect missing hashes or throw error if no collection given
	      if (missingTxHashes) for (let unfoundTxHash of unfoundTxHashes) missingTxHashes.push(unfoundTxHash);
	      else if (unfoundTxHashes.length > 0) throw new MoneroError("Wallet missing requested tx hashes: " + unfoundTxHashes);
	    }
	    
	    // special case: re-fetch txs if inconsistency caused by needing to make multiple rpc calls
	    for (let tx of txs) {
	      if (tx.isConfirmed() && tx.getBlock() === undefined) {
	        console.error("Inconsistency detected building txs from multiple rpc calls, re-fetching txs");
	        return this.getTxs(query);
	      }
	    }
	    
	    // order txs if tx hashes given then return
	    if (query.getHashes() && query.getHashes().length > 0) {
	      let txsById = new Map();  // store txs in temporary map for sorting
	      for (let tx of txs) txsById.set(tx.getHash(), tx);
	      let orderedTxs = [];
	      for (let hash of query.getHashes()) if (txsById.get(hash)) orderedTxs.push(txsById.get(hash));
	      txs = orderedTxs;
	    }
	    return txs;
	  }
	  
	  async getTransfers(query) {
	    
	    // copy and normalize query up to block
	    query = MoneroWallet._normalizeTransferQuery(query);
	    
	    // get transfers directly if query does not require tx context (other transfers, outputs)
	    if (!MoneroWalletRpc._isContextual(query)) return this._getTransfersAux(query);
	    
	    // otherwise get txs with full models to fulfill query
	    let transfers = [];
	    for (let tx of await this.getTxs(query.getTxQuery())) {
	      for (let transfer of tx.filterTransfers(query)) {
	        transfers.push(transfer);
	      }
	    }
	    
	    return transfers;
	  }
	  
	  async getOutputs(query) {
	    
	    // copy and normalize query up to block
	    query = MoneroWallet._normalizeOutputQuery(query);
	    
	    // get outputs directly if query does not require tx context (other outputs, transfers)
	    if (!MoneroWalletRpc._isContextual(query)) return this._getOutputsAux(query);
	    
	    // otherwise get txs with full models to fulfill query
	    let outputs = [];
	    for (let tx of await this.getTxs(query.getTxQuery())) {
	      for (let output of tx.filterOutputs(query)) {
	        outputs.push(output);
	      }
	    }
	    
	    return outputs;
	  }
	  
	  async exportOutputs(all) {
	    return (await this.rpc.sendJsonRequest("export_outputs", {all: all})).result.outputs_data_hex;
	  }
	  
	  async importOutputs(outputsHex) {
	    let resp = await this.rpc.sendJsonRequest("import_outputs", {outputs_data_hex: outputsHex});
	    return resp.result.num_imported;
	  }
	  
	  async exportKeyImages(all) {
	    return await this._rpcExportKeyImages(all);
	  }
	  
	  async importKeyImages(keyImages) {
	    
	    // convert key images to rpc parameter
	    let rpcKeyImages = keyImages.map(keyImage => ({key_image: keyImage.getHex(), signature: keyImage.getSignature()}));
	    
	    // send request
	    let resp = await this.rpc.sendJsonRequest("import_key_images", {signed_key_images: rpcKeyImages});
	    
	    // build and return result
	    let importResult = new MoneroKeyImageImportResult();
	    importResult.setHeight(resp.result.height);
	    importResult.setSpentAmount(new BigInteger(resp.result.spent));
	    importResult.setUnspentAmount(new BigInteger(resp.result.unspent));
	    return importResult;
	  }
	  
	  async getNewKeyImagesFromLastImport() {
	    return await this._rpcExportKeyImages(false);
	  }
	  
	  async freezeOutput(keyImage) {
	    return this.rpc.sendJsonRequest("freeze", {key_image: keyImage});
	  }
	  
	  async thawOutput(keyImage) {
	    return this.rpc.sendJsonRequest("thaw", {key_image: keyImage});
	  }
	  
	  async isOutputFrozen(keyImage) {
	    let resp = await this.rpc.sendJsonRequest("frozen", {key_image: keyImage});
	    return resp.result.frozen === true;
	  }
	  
	  async createTxs(config) {
	    
	    // validate, copy, and normalize config
	    config = MoneroWallet._normalizeCreateTxsConfig(config);
	    if (config.getCanSplit() === undefined) config.setCanSplit(true);
	    if (config.getRelay() === true && await this.isMultisig()) throw new MoneroError("Cannot relay multisig transaction until co-signed");

	    // determine account and subaddresses to send from
	    let accountIdx = config.getAccountIndex();
	    if (accountIdx === undefined) throw new MoneroError("Must provide the account index to send from");
	    let subaddressIndices = config.getSubaddressIndices() === undefined ? undefined : config.getSubaddressIndices().slice(0); // fetch all or copy given indices
	    
	    // build config parameters
	    let params = {};
	    params.destinations = [];
	    for (let destination of config.getDestinations()) {
	      assert(destination.getAddress(), "Destination address is not defined");
	      assert(destination.getAmount(), "Destination amount is not defined");
	      params.destinations.push({ address: destination.getAddress(), amount: destination.getAmount().toString() });
	    }
	    params.account_index = accountIdx;
	    params.subaddr_indices = subaddressIndices;
	    params.payment_id = config.getPaymentId();
	    params.unlock_time = config.getUnlockHeight();
	    params.do_not_relay = config.getRelay() !== true;
	    assert(config.getPriority() === undefined || config.getPriority() >= 0 && config.getPriority() <= 3);
	    params.priority = config.getPriority();
	    params.get_tx_hex = true;
	    params.get_tx_metadata = true;
	    if (config.getCanSplit()) params.get_tx_keys = true; // param to get tx key(s) depends if split
	    else params.get_tx_key = true;
	    
	    // send request
	    let result;
	    try {
	      let resp = await this.rpc.sendJsonRequest(config.getCanSplit() ? "transfer_split" : "transfer", params);
	      result = resp.result;
	    } catch (err) {
	      if (err.message.indexOf("WALLET_RPC_ERROR_CODE_WRONG_ADDRESS") > -1) throw new MoneroError("Invalid destination address");
	      throw err;
	    }
	    
	    // pre-initialize txs iff present. multisig and view-only wallets will have tx set without transactions
	    let txs;
	    let numTxs = config.getCanSplit() ? (result.fee_list !== undefined ? result.fee_list.length : 0) : (result.fee !== undefined ? 1 : 0);
	    if (numTxs > 0) txs = [];
	    let copyDestinations = numTxs === 1;
	    for (let i = 0; i < numTxs; i++) {
	      let tx = new MoneroTxWallet();
	      MoneroWalletRpc._initSentTxWallet(config, tx, copyDestinations);
	      tx.getOutgoingTransfer().setAccountIndex(accountIdx);
	      if (subaddressIndices !== undefined && subaddressIndices.length === 1) tx.getOutgoingTransfer().setSubaddressIndices(subaddressIndices);
	      txs.push(tx);
	    }
	    
	    // notify of changes
	    if (config.getRelay()) await this._poll();
	    
	    // initialize tx set from rpc response with pre-initialized txs
	    if (config.getCanSplit()) return MoneroWalletRpc._convertRpcSentTxsToTxSet(result, txs).getTxs();
	    else return MoneroWalletRpc._convertRpcTxToTxSet(result, txs === undefined ? undefined : txs[0], true).getTxs();
	  }
	  
	  async sweepOutput(config) {
	    
	    // normalize and validate config
	    config = MoneroWallet._normalizeSweepOutputConfig(config);
	    
	    // build config parameters
	    let params = {};
	    params.address = config.getDestinations()[0].getAddress();
	    params.account_index = config.getAccountIndex();
	    params.subaddr_indices = config.getSubaddressIndices();
	    params.key_image = config.getKeyImage();
	    params.unlock_time = config.getUnlockHeight();
	    params.do_not_relay = config.getRelay() !== true;
	    assert(config.getPriority() === undefined || config.getPriority() >= 0 && config.getPriority() <= 3);
	    params.priority = config.getPriority();
	    params.payment_id = config.getPaymentId();
	    params.get_tx_key = true;
	    params.get_tx_hex = true;
	    params.get_tx_metadata = true;
	    
	    // send request
	    let resp = await this.rpc.sendJsonRequest("sweep_single", params);
	    let result = resp.result;
	    
	    // notify of changes
	    if (config.getRelay()) await this._poll();
	    
	    // build and return tx
	    let tx = MoneroWalletRpc._initSentTxWallet(config, null, true);
	    MoneroWalletRpc._convertRpcTxToTxSet(result, tx, true);
	    tx.getOutgoingTransfer().getDestinations()[0].setAmount(tx.getOutgoingTransfer().getAmount()); // initialize destination amount
	    return tx;
	  }
	  
	  async sweepUnlocked(config) {
	    
	    // validate and normalize config
	    config = MoneroWallet._normalizeSweepUnlockedConfig(config);
	    
	    // determine account and subaddress indices to sweep; default to all with unlocked balance if not specified
	    let indices = new Map();  // maps each account index to subaddress indices to sweep
	    if (config.getAccountIndex() !== undefined) {
	      if (config.getSubaddressIndices() !== undefined) {
	        indices.set(config.getAccountIndex(), config.getSubaddressIndices());
	      } else {
	        let subaddressIndices = [];
	        indices.set(config.getAccountIndex(), subaddressIndices);
	        for (let subaddress of await this.getSubaddresses(config.getAccountIndex())) {
	          if (subaddress.getUnlockedBalance().compare(new BigInteger(0)) > 0) subaddressIndices.push(subaddress.getIndex());
	        }
	      }
	    } else {
	      let accounts = await this.getAccounts(true);
	      for (let account of accounts) {
	        if (account.getUnlockedBalance().compare(new BigInteger(0)) > 0) {
	          let subaddressIndices = [];
	          indices.set(account.getIndex(), subaddressIndices);
	          for (let subaddress of account.getSubaddresses()) {
	            if (subaddress.getUnlockedBalance().compare(new BigInteger(0)) > 0) subaddressIndices.push(subaddress.getIndex());
	          }
	        }
	      }
	    }
	    
	    // sweep from each account and collect resulting tx sets
	    let txs = [];
	    for (let accountIdx of indices.keys()) {
	      
	      // copy and modify the original config
	      let copy = config.copy();
	      copy.setAccountIndex(accountIdx);
	      copy.setSweepEachSubaddress(false);
	      
	      // sweep all subaddresses together  // TODO monero-project: can this reveal outputs belong to the same wallet?
	      if (copy.getSweepEachSubaddress() !== true) {
	        copy.setSubaddressIndices(indices.get(accountIdx));
	        for (let tx of await this._rpcSweepAccount(copy)) txs.push(tx);
	      }
	      
	      // otherwise sweep each subaddress individually
	      else {
	        for (let subaddressIdx of indices.get(accountIdx)) {
	          copy.setSubaddressIndices([subaddressIdx]);
	          for (let tx of await this._rpcSweepAccount(copy)) txs.push(tx);
	        }
	      }
	    }
	    
	    // notify of changes
	    if (config.getRelay()) await this._poll();
	    return txs;
	  }
	  
	  async sweepDust(relay) {
	    if (relay === undefined) relay = false;
	    let resp = await this.rpc.sendJsonRequest("sweep_dust", {do_not_relay: !relay});
	    if (relay) await this._poll();
	    let result = resp.result;
	    let txSet = MoneroWalletRpc._convertRpcSentTxsToTxSet(result);
	    if (txSet.getTxs() === undefined) return [];
	    for (let tx of txSet.getTxs()) {
	      tx.setIsRelayed(!relay);
	      tx.setInTxPool(tx.isRelayed());
	    }
	    return txSet.getTxs();
	  }
	  
	  async relayTxs(txsOrMetadatas) {
	    assert(Array.isArray(txsOrMetadatas), "Must provide an array of txs or their metadata to relay");
	    let txHashes = [];
	    for (let txOrMetadata of txsOrMetadatas) {
	      let metadata = txOrMetadata instanceof MoneroTxWallet ? txOrMetadata.getMetadata() : txOrMetadata;
	      let resp = await this.rpc.sendJsonRequest("relay_tx", { hex: metadata });
	      txHashes.push(resp.result.tx_hash);
	    }
	    await this._poll(); // notify of changes
	    return txHashes;
	  }
	  
	  async describeTxSet(txSet) {
	    let resp = await this.rpc.sendJsonRequest("describe_transfer", {
	      unsigned_txset: txSet.getUnsignedTxHex(),
	      multisig_txset: txSet.getMultisigTxHex()
	    });
	    return MoneroWalletRpc._convertRpcDescribeTransfer(resp.result);
	  }
	  
	  async signTxs(unsignedTxHex) {
	    let resp = await this.rpc.sendJsonRequest("sign_transfer", {
	      unsigned_txset: unsignedTxHex,
	      export_raw: false
	    });
	    await this._poll();
	    return resp.result.signed_txset
	  }
	  
	  async submitTxs(signedTxHex) {
	    let resp = await this.rpc.sendJsonRequest("submit_transfer", {
	      tx_data_hex: signedTxHex
	    });
	    await this._poll();
	    return resp.result.tx_hash_list;
	  }
	  
	  async signMessage(message, signatureType, accountIdx, subaddressIdx) {
	    let resp = await this.rpc.sendJsonRequest("sign", {
	        data: message,
	        signature_type: signatureType === MoneroMessageSignatureType.SIGN_WITH_SPEND_KEY ? "spend" : "view",
	        account_index: accountIdx,
	        address_index: subaddressIdx
	    });
	    return resp.result.signature;
	  }
	  
	  async verifyMessage(message, address, signature) {
	    try {
	      let resp = await this.rpc.sendJsonRequest("verify", {data: message, address: address, signature: signature});
	      let result = new MoneroMessageSignatureResult(
	        resp.result.good,
	        !resp.result.good ? undefined : resp.result.old,
	        !resp.result.good ? undefined : !resp.result.signature_type ? undefined : resp.result.signature_type === "view" ? MoneroMessageSignatureType.SIGN_WITH_VIEW_KEY : MoneroMessageSignatureType.SIGN_WITH_SPEND_KEY,
	        !resp.result.good ? undefined : resp.result.version);
	      return result;
	    } catch (e) {
	      if (e.getCode() === -2) return new MoneroMessageSignatureResult(false);
	      throw e;
	    }
	  }
	  
	  async getTxKey(txHash) {
	    try {
	      return (await this.rpc.sendJsonRequest("get_tx_key", {txid: txHash})).result.tx_key;
	    } catch (e) {
	      if (e instanceof MoneroRpcError && e.getCode() === -8 && e.message.includes("TX ID has invalid format")) e = new MoneroRpcError("TX hash has invalid format", e.getCode(), e.getRpcMethod(), e.getRpcParams());  // normalize error message
	      throw e;
	    }
	  }
	  
	  async checkTxKey(txHash, txKey, address) {
	    try {
	      
	      // send request
	      let resp = await this.rpc.sendJsonRequest("check_tx_key", {txid: txHash, tx_key: txKey, address: address});
	      
	      // interpret result
	      let check = new MoneroCheckTx();
	      check.setIsGood(true);
	      check.setNumConfirmations(resp.result.confirmations);
	      check.setInTxPool(resp.result.in_pool);
	      check.setReceivedAmount(new BigInteger(resp.result.received));
	      return check;
	    } catch (e) {
	      if (e instanceof MoneroRpcError && e.getCode() === -8 && e.message.includes("TX ID has invalid format")) e = new MoneroRpcError("TX hash has invalid format", e.getCode(), e.getRpcMethod(), e.getRpcParams());  // normalize error message
	      throw e;
	    }
	  }
	  
	  async getTxProof(txHash, address, message) {
	    try {
	      let resp = await this.rpc.sendJsonRequest("get_tx_proof", {txid: txHash, address: address, message: message});
	      return resp.result.signature;
	    } catch (e) {
	      if (e instanceof MoneroRpcError && e.getCode() === -8 && e.message.includes("TX ID has invalid format")) e = new MoneroRpcError("TX hash has invalid format", e.getCode(), e.getRpcMethod(), e.getRpcParams());  // normalize error message
	      throw e;
	    }
	  }
	  
	  async checkTxProof(txHash, address, message, signature) {
	    try {
	      
	      // send request
	      let resp = await this.rpc.sendJsonRequest("check_tx_proof", {
	        txid: txHash,
	        address: address,
	        message: message,
	        signature: signature
	      });
	      
	      // interpret response
	      let isGood = resp.result.good;
	      let check = new MoneroCheckTx();
	      check.setIsGood(isGood);
	      if (isGood) {
	        check.setNumConfirmations(resp.result.confirmations);
	        check.setInTxPool(resp.result.in_pool);
	        check.setReceivedAmount(new BigInteger(resp.result.received));
	      }
	      return check;
	    } catch (e) {
	      if (e instanceof MoneroRpcError && e.getCode() === -1 && e.message === "basic_string") e = new MoneroRpcError("Must provide signature to check tx proof", -1);
	      if (e instanceof MoneroRpcError && e.getCode() === -8 && e.message.includes("TX ID has invalid format")) e = new MoneroRpcError("TX hash has invalid format", e.getCode(), e.getRpcMethod(), e.getRpcParams());
	      throw e;
	    }
	  }
	  
	  async getSpendProof(txHash, message) {
	    try {
	      let resp = await this.rpc.sendJsonRequest("get_spend_proof", {txid: txHash, message: message});
	      return resp.result.signature;
	    } catch (e) {
	      if (e instanceof MoneroRpcError && e.getCode() === -8 && e.message.includes("TX ID has invalid format")) e = new MoneroRpcError("TX hash has invalid format", e.getCode(), e.getRpcMethod(), e.getRpcParams());  // normalize error message
	      throw e;
	    }
	  }
	  
	  async checkSpendProof(txHash, message, signature) {
	    try {
	      let resp = await this.rpc.sendJsonRequest("check_spend_proof", {
	        txid: txHash,
	        message: message,
	        signature: signature
	      });
	      return resp.result.good;
	    } catch (e) {
	      if (e instanceof MoneroRpcError && e.getCode() === -8 && e.message.includes("TX ID has invalid format")) e = new MoneroRpcError("TX hash has invalid format", e.getCode(), e.getRpcMethod(), e.getRpcParams());  // normalize error message
	      throw e;
	    }
	  }
	  
	  async getReserveProofWallet(message) {
	    let resp = await this.rpc.sendJsonRequest("get_reserve_proof", {
	      all: true,
	      message: message
	    });
	    return resp.result.signature;
	  }
	  
	  async getReserveProofAccount(accountIdx, amount, message) {
	    let resp = await this.rpc.sendJsonRequest("get_reserve_proof", {
	      account_index: accountIdx,
	      amount: amount.toString(),
	      message: message
	    });
	    return resp.result.signature;
	  }

	  async checkReserveProof(address, message, signature) {
	    
	    // send request
	    let resp = await this.rpc.sendJsonRequest("check_reserve_proof", {
	      address: address,
	      message: message,
	      signature: signature
	    });
	    
	    // interpret results
	    let isGood = resp.result.good;
	    let check = new MoneroCheckReserve();
	    check.setIsGood(isGood);
	    if (isGood) {
	      check.setUnconfirmedSpentAmount(new BigInteger(resp.result.spent));
	      check.setTotalAmount(new BigInteger(resp.result.total));
	    }
	    return check;
	  }
	  
	  async getTxNotes(txHashes) {
	    return (await this.rpc.sendJsonRequest("get_tx_notes", {txids: txHashes})).result.notes;
	  }
	  
	  async setTxNotes(txHashes, notes) {
	    await this.rpc.sendJsonRequest("set_tx_notes", {txids: txHashes, notes: notes});
	  }
	  
	  async getAddressBookEntries(entryIndices) {
	    let resp = await this.rpc.sendJsonRequest("get_address_book", {entries: entryIndices});
	    if (!resp.result.entries) return [];
	    let entries = [];
	    for (let rpcEntry of resp.result.entries) {
	      entries.push(new MoneroAddressBookEntry().setIndex(rpcEntry.index).setAddress(rpcEntry.address).setDescription(rpcEntry.description).setPaymentId(rpcEntry.payment_id));
	    }
	    return entries;
	  }
	  
	  async addAddressBookEntry(address, description) {
	    let resp = await this.rpc.sendJsonRequest("add_address_book", {address: address, description: description});
	    return resp.result.index;
	  }
	  
	  async editAddressBookEntry(index, setAddress, address, setDescription, description) {
	    await this.rpc.sendJsonRequest("edit_address_book", {
	      index: index,
	      set_address: setAddress,
	      address: address,
	      set_description: setDescription,
	      description: description
	    });
	  }
	  
	  async deleteAddressBookEntry(entryIdx) {
	    await this.rpc.sendJsonRequest("delete_address_book", {index: entryIdx});
	  }
	  
	  async tagAccounts(tag, accountIndices) {
	    await this.rpc.sendJsonRequest("tag_accounts", {tag: tag, accounts: accountIndices});
	  }

	  async untagAccounts(accountIndices) {
	    await this.rpc.sendJsonRequest("untag_accounts", {accounts: accountIndices});
	  }

	  async getAccountTags() {
	    let tags = [];
	    let resp = await this.rpc.sendJsonRequest("get_account_tags");
	    if (resp.result.account_tags) {
	      for (let rpcAccountTag of resp.result.account_tags) {
	        tags.push(new MoneroAccountTag(rpcAccountTag.tag ? rpcAccountTag.tag : undefined, rpcAccountTag.label ? rpcAccountTag.label : undefined, rpcAccountTag.accounts));
	      }
	    }
	    return tags;
	  }

	  async setAccountTagLabel(tag, label) {
	    await this.rpc.sendJsonRequest("set_account_tag_description", {tag: tag, description: label});
	  }
	  
	  async getPaymentUri(config) {
	    config = MoneroWallet._normalizeCreateTxsConfig(config);
	    let resp = await this.rpc.sendJsonRequest("make_uri", {
	      address: config.getDestinations()[0].getAddress(),
	      amount: config.getDestinations()[0].getAmount() ? config.getDestinations()[0].getAmount().toString() : undefined,
	      payment_id: config.getPaymentId(),
	      recipient_name: config.getRecipientName(),
	      tx_description: config.getNote()
	    });
	    return resp.result.uri;
	  }
	  
	  async parsePaymentUri(uri) {
	    assert(uri, "Must provide URI to parse");
	    let resp = await this.rpc.sendJsonRequest("parse_uri", {uri: uri});
	    let config = new MoneroTxConfig({address: resp.result.uri.address, amount: new BigInteger(resp.result.uri.amount)});
	    config.setPaymentId(resp.result.uri.payment_id);
	    config.setRecipientName(resp.result.uri.recipient_name);
	    config.setNote(resp.result.uri.tx_description);
	    if ("" === config.getDestinations()[0].getAddress()) config.getDestinations()[0].setAddress(undefined);
	    if ("" === config.getPaymentId()) config.setPaymentId(undefined);
	    if ("" === config.getRecipientName()) config.setRecipientName(undefined);
	    if ("" === config.getNote()) config.setNote(undefined);
	    return config;
	  }
	  
	  async getAttribute(key) {
	    try {
	      let resp = await this.rpc.sendJsonRequest("get_attribute", {key: key});
	      return resp.result.value === "" ? undefined : resp.result.value;
	    } catch (e) {
	      if (e instanceof MoneroRpcError && e.getCode() === -45) return undefined;
	      throw e;
	    }
	  }
	  
	  async setAttribute(key, val) {
	    await this.rpc.sendJsonRequest("set_attribute", {key: key, value: val});
	  }
	  
	  async startMining(numThreads, backgroundMining, ignoreBattery) {
	    await this.rpc.sendJsonRequest("start_mining", {
	      threads_count: numThreads,
	      do_background_mining: backgroundMining,
	      ignore_battery: ignoreBattery
	    });
	  }
	  
	  async stopMining() {
	    await this.rpc.sendJsonRequest("stop_mining");
	  }
	  
	  async isMultisigImportNeeded() {
	    let resp = await this.rpc.sendJsonRequest("get_balance");
	    return resp.result.multisig_import_needed === true;
	  }
	  
	  async getMultisigInfo() {
	    let resp = await this.rpc.sendJsonRequest("is_multisig");
	    let result = resp.result;
	    let info = new MoneroMultisigInfo();
	    info.setIsMultisig(result.multisig);
	    info.setIsReady(result.ready);
	    info.setThreshold(result.threshold);
	    info.setNumParticipants(result.total);
	    return info;
	  }
	  
	  async prepareMultisig() {
	    let resp = await this.rpc.sendJsonRequest("prepare_multisig", {enable_multisig_experimental: true});
	    let result = resp.result;
	    return result.multisig_info;
	  }
	  
	  async makeMultisig(multisigHexes, threshold, password) {
	    let resp = await this.rpc.sendJsonRequest("make_multisig", {
	      multisig_info: multisigHexes,
	      threshold: threshold,
	      password: password
	    });
	    return resp.result.multisig_info;
	  }
	  
	  async exchangeMultisigKeys(multisigHexes, password) {
	    let resp = await this.rpc.sendJsonRequest("exchange_multisig_keys", {multisig_info: multisigHexes, password: password});
	    let msResult = new MoneroMultisigInitResult();
	    msResult.setAddress(resp.result.address);
	    msResult.setMultisigHex(resp.result.multisig_info);
	    if (msResult.getAddress().length === 0) msResult.setAddress(undefined);
	    if (msResult.getMultisigHex().length === 0) msResult.setMultisigHex(undefined);
	    return msResult;
	  }
	  
	  async exportMultisigHex() {
	    let resp = await this.rpc.sendJsonRequest("export_multisig_info");
	    return resp.result.info;
	  }

	  async importMultisigHex(multisigHexes) {
	    if (!GenUtils.isArray(multisigHexes)) throw new MoneroError("Must provide string[] to importMultisigHex()")
	    let resp = await this.rpc.sendJsonRequest("import_multisig_info", {info: multisigHexes});
	    return resp.result.n_outputs;
	  }

	  async signMultisigTxHex(multisigTxHex) {
	    let resp = await this.rpc.sendJsonRequest("sign_multisig", {tx_data_hex: multisigTxHex});
	    let result = resp.result;
	    let signResult = new MoneroMultisigSignResult();
	    signResult.setSignedMultisigTxHex(result.tx_data_hex);
	    signResult.setTxHashes(result.tx_hash_list);
	    return signResult;
	  }

	  async submitMultisigTxHex(signedMultisigTxHex) {
	    let resp = await this.rpc.sendJsonRequest("submit_multisig", {tx_data_hex: signedMultisigTxHex});
	    return resp.result.tx_hash_list;
	  }
	  
	  async changePassword(oldPassword, newPassword) {
	    return this.rpc.sendJsonRequest("change_wallet_password", {old_password: oldPassword, new_password: newPassword});
	  }
	  
	  async save() {
	    await this.rpc.sendJsonRequest("store");
	  }
	  
	  async close(save) {
	    if (save === undefined) save = false;
	    await this._clear();
	    await this.rpc.sendJsonRequest("close_wallet", {autosave_current: save});
	  }
	  
	  async isClosed() {
	    try {
	      await this.getPrimaryAddress();
	    } catch (e) {
	      return e instanceof MoneroRpcError && e.getCode() === -13 && e.message.indexOf("No wallet file") > -1;
	    }
	    return false;
	  }
	  
	  /**
	   * Save and close the current wallet and stop the RPC server.
	   */
	  async stop() {
	    await this._clear();
	    await this.rpc.sendJsonRequest("stop_wallet");
	  }
	  
	  // ----------- ADD JSDOC FOR SUPPORTED DEFAULT IMPLEMENTATIONS --------------
	  
	  async getNumBlocksToUnlock() { return super.getNumBlocksToUnlock(...arguments); }
	  async getTx() { return super.getTx(...arguments); }
	  async getIncomingTransfers() { return super.getIncomingTransfers(...arguments); }
	  async getOutgoingTransfers() { return super.getOutgoingTransfers(...arguments); }
	  async createTx() { return super.createTx(...arguments); }
	  async relayTx() { return super.relayTx(...arguments); }
	  async getTxNote() { return super.getTxNote(...arguments); }
	  async setTxNote() { return super.setTxNote(...arguments); }
	  
	  // -------------------------------- PRIVATE ---------------------------------
	  
	  async _clear() {
	    this.listeners.splice(0, this.listeners.length);
	    this._refreshListening();
	    delete this.addressCache;
	    this.addressCache = {};
	    this.path = undefined;
	  }
	  
	  async _getBalances(accountIdx, subaddressIdx) {
	    if (accountIdx === undefined) {
	      assert.equal(subaddressIdx, undefined, "Must provide account index with subaddress index");
	      let balance = new BigInteger(0);
	      let unlockedBalance = new BigInteger(0);
	      for (let account of await this.getAccounts()) {
	        balance = balance.add(account.getBalance());
	        unlockedBalance = unlockedBalance.add(account.getUnlockedBalance());
	      }
	      return [balance, unlockedBalance];
	    } else {
	      let params = {account_index: accountIdx, address_indices: subaddressIdx === undefined ? undefined : [subaddressIdx]};
	      let resp = await this.rpc.sendJsonRequest("get_balance", params);
	      if (subaddressIdx === undefined) return [new BigInteger(resp.result.balance), new BigInteger(resp.result.unlocked_balance)];
	      else return [new BigInteger(resp.result.per_subaddress[0].balance), new BigInteger(resp.result.per_subaddress[0].unlocked_balance)];
	    }
	  }
	  
	  async _getAccountIndices(getSubaddressIndices) {
	    let indices = new Map();
	    for (let account of await this.getAccounts()) {
	      indices.set(account.getIndex(), getSubaddressIndices ? await this._getSubaddressIndices(account.getIndex()) : undefined);
	    }
	    return indices;
	  }
	  
	  async _getSubaddressIndices(accountIdx) {
	    let subaddressIndices = [];
	    let resp = await this.rpc.sendJsonRequest("get_address", {account_index: accountIdx});
	    for (let address of resp.result.addresses) subaddressIndices.push(address.address_index);
	    return subaddressIndices;
	  }
	  
	  async _getTransfersAux(query) {
	    
	    // check if pool txs explicitly requested without daemon connection
	    let isConnectedToDaemon = await this.isConnectedToDaemon();
	    let txQuery = query.getTxQuery();
	    if (txQuery.inTxPool() !== undefined && txQuery.inTxPool() && !isConnectedToDaemon) {
	      throw new MoneroError("Cannot fetch pool transactions because wallet has no daemon connection");
	    }
	    
	    // build params for get_transfers rpc call
	    let canBeConfirmed = txQuery.isConfirmed() !== false && txQuery.inTxPool() !== true && txQuery.isFailed() !== true && txQuery.isRelayed() !== false;
	    let canBeInTxPool = isConnectedToDaemon && txQuery.isConfirmed() !== true && txQuery.inTxPool() !== false && txQuery.isFailed() !== true && txQuery.isRelayed() !== false && txQuery.getHeight() === undefined && txQuery.getMaxHeight() === undefined && txQuery.isLocked() !== false;
	    let canBeIncoming = query.isIncoming() !== false && query.isOutgoing() !== true && query.hasDestinations() !== true;
	    let canBeOutgoing = query.isOutgoing() !== false && query.isIncoming() !== true;
	    let params = {};
	    params.in = canBeIncoming && canBeConfirmed;
	    params.out = canBeOutgoing && canBeConfirmed;
	    params.pool = canBeIncoming && canBeInTxPool;
	    params.pending = canBeOutgoing && canBeInTxPool;
	    params.failed = txQuery.isFailed() !== false && txQuery.isConfirmed() !== true && txQuery.inTxPool() != true;
	    if (txQuery.getMinHeight() !== undefined) {
	      if (txQuery.getMinHeight() > 0) params.min_height = txQuery.getMinHeight() - 1; // TODO monero-project: wallet2::get_payments() min_height is exclusive, so manually offset to match intended range (issues #5751, #5598)
	      else params.min_height = txQuery.getMinHeight();
	    }
	    if (txQuery.getMaxHeight() !== undefined) params.max_height = txQuery.getMaxHeight();
	    params.filter_by_height = txQuery.getMinHeight() !== undefined || txQuery.getMaxHeight() !== undefined;
	    if (query.getAccountIndex() === undefined) {
	      assert(query.getSubaddressIndex() === undefined && query.getSubaddressIndices() === undefined, "Query specifies a subaddress index but not an account index");
	      params.all_accounts = true;
	    } else {
	      params.account_index = query.getAccountIndex();
	      
	      // set subaddress indices param
	      let subaddressIndices = new Set();
	      if (query.getSubaddressIndex() !== undefined) subaddressIndices.add(query.getSubaddressIndex());
	      if (query.getSubaddressIndices() !== undefined) query.getSubaddressIndices().map(subaddressIdx => subaddressIndices.add(subaddressIdx));
	      if (subaddressIndices.size) params.subaddr_indices = Array.from(subaddressIndices);
	    }
	    
	    // cache unique txs and blocks
	    let txMap = {};
	    let blockMap = {};
	    
	    // build txs using `get_transfers`
	    let resp = await this.rpc.sendJsonRequest("get_transfers", params);
	    for (let key of Object.keys(resp.result)) {
	      for (let rpcTx of resp.result[key]) {
	        //if (rpcTx.txid === query.debugTxId) console.log(rpcTx);
	        let tx = MoneroWalletRpc._convertRpcTxWithTransfer(rpcTx);
	        if (tx.isConfirmed()) assert(tx.getBlock().getTxs().indexOf(tx) > -1);
	        
	        // replace transfer amount with destination sum
	        // TODO monero-wallet-rpc: confirmed tx from/to same account has amount 0 but cached transfers
	        if (tx.getOutgoingTransfer() !== undefined && tx.isRelayed() && !tx.isFailed() &&
	            tx.getOutgoingTransfer().getDestinations() && tx.getOutgoingAmount().compare(new BigInteger(0)) === 0) {
	          let outgoingTransfer = tx.getOutgoingTransfer();
	          let transferTotal = new BigInteger(0);
	          for (let destination of outgoingTransfer.getDestinations()) transferTotal = transferTotal.add(destination.getAmount());
	          tx.getOutgoingTransfer().setAmount(transferTotal);
	        }
	        
	        // merge tx
	        MoneroWalletRpc._mergeTx(tx, txMap, blockMap);
	      }
	    }
	    
	    // sort txs by block height
	    let txs = Object.values(txMap);
	    txs.sort(MoneroWalletRpc._compareTxsByHeight);
	    
	    // filter and return transfers
	    let transfers = [];
	    for (let tx of txs) {
	      
	      // tx is not incoming/outgoing unless already set
	      if (tx.isIncoming() === undefined) tx.setIsIncoming(false);
	      if (tx.isOutgoing() === undefined) tx.setIsOutgoing(false);
	      
	      // sort incoming transfers
	      if (tx.getIncomingTransfers() !== undefined) tx.getIncomingTransfers().sort(MoneroWalletRpc._compareIncomingTransfers);
	      
	      // collect queried transfers, erase if excluded
	      for (let transfer of tx.filterTransfers(query)) {
	        transfers.push(transfer);
	      }
	      
	      // remove txs without requested transfer
	      if (tx.getBlock() !== undefined && tx.getOutgoingTransfer() === undefined && tx.getIncomingTransfers() === undefined) {
	        tx.getBlock().getTxs().splice(tx.getBlock().getTxs().indexOf(tx), 1);
	      }
	    }
	    
	    return transfers;
	  }
	  
	  async _getOutputsAux(query) {
	    
	    // determine account and subaddress indices to be queried
	    let indices = new Map();
	    if (query.getAccountIndex() !== undefined) {
	      let subaddressIndices = new Set();
	      if (query.getSubaddressIndex() !== undefined) subaddressIndices.add(query.getSubaddressIndex());
	      if (query.getSubaddressIndices() !== undefined) query.getSubaddressIndices().map(subaddressIdx => subaddressIndices.add(subaddressIdx));
	      indices.set(query.getAccountIndex(), subaddressIndices.size ? Array.from(subaddressIndices) : undefined);  // undefined will fetch from all subaddresses
	    } else {
	      assert.equal(query.getSubaddressIndex(), undefined, "Query specifies a subaddress index but not an account index");
	      assert(query.getSubaddressIndices() === undefined || query.getSubaddressIndices().length === 0, "Query specifies subaddress indices but not an account index");
	      indices = await this._getAccountIndices();  // fetch all account indices without subaddresses
	    }
	    
	    // cache unique txs and blocks
	    let txMap = {};
	    let blockMap = {};
	    
	    // collect txs with outputs for each indicated account using `incoming_transfers` rpc call
	    let params = {};
	    params.transfer_type = query.isSpent() === true ? "unavailable" : query.isSpent() === false ? "available" : "all";
	    params.verbose = true;
	    for (let accountIdx of indices.keys()) {
	    
	      // send request
	      params.account_index = accountIdx;
	      params.subaddr_indices = indices.get(accountIdx);
	      let resp = await this.rpc.sendJsonRequest("incoming_transfers", params);
	      
	      // convert response to txs with outputs and merge
	      if (resp.result.transfers === undefined) continue;
	      for (let rpcOutput of resp.result.transfers) {
	        let tx = MoneroWalletRpc._convertRpcTxWalletWithOutput(rpcOutput);
	        MoneroWalletRpc._mergeTx(tx, txMap, blockMap);
	      }
	    }
	    
	    // sort txs by block height
	    let txs = Object.values(txMap);
	    txs.sort(MoneroWalletRpc._compareTxsByHeight);
	    
	    // collect queried outputs
	    let outputs = [];
	    for (let tx of txs) {
	      
	      // sort outputs
	      if (tx.getOutputs() !== undefined) tx.getOutputs().sort(MoneroWalletRpc._compareOutputs);
	      
	      // collect queried outputs, erase if excluded
	      for (let output of tx.filterOutputs(query)) outputs.push(output);
	      
	      // remove excluded txs from block
	      if (tx.getOutputs() === undefined && tx.getBlock() !== undefined) {
	        tx.getBlock().getTxs().splice(tx.getBlock().getTxs().indexOf(tx), 1);
	      }
	    }
	    return outputs;
	  }
	  
	  /**
	   * Common method to get key images.
	   * 
	   * @param all - pecifies to get all xor only new images from last import
	   * @return {MoneroKeyImage[]} are the key images
	   */
	  async _rpcExportKeyImages(all) {
	    let resp = await this.rpc.sendJsonRequest("export_key_images", {all: all});
	    if (!resp.result.signed_key_images) return [];
	    return resp.result.signed_key_images.map(rpcImage => new MoneroKeyImage(rpcImage.key_image, rpcImage.signature));
	  }
	  
	  async _rpcSweepAccount(config) {
	    
	    // validate config
	    if (config === undefined) throw new MoneroError("Must provide sweep config");
	    if (config.getAccountIndex() === undefined) throw new MoneroError("Must provide an account index to sweep from");
	    if (config.getDestinations() === undefined || config.getDestinations().length != 1) throw new MoneroError("Must provide exactly one destination to sweep to");
	    if (config.getDestinations()[0].getAddress() === undefined) throw new MoneroError("Must provide destination address to sweep to");
	    if (config.getDestinations()[0].getAmount() !== undefined) throw new MoneroError("Cannot specify amount in sweep config");
	    if (config.getKeyImage() !== undefined) throw new MoneroError("Key image defined; use sweepOutput() to sweep an output by its key image");
	    if (config.getSubaddressIndices() !== undefined && config.getSubaddressIndices().length === 0) throw new MoneroError("Empty list given for subaddresses indices to sweep");
	    if (config.getSweepEachSubaddress()) throw new MoneroError("Cannot sweep each subaddress with RPC `sweep_all`");
	    
	    // sweep from all subaddresses if not otherwise defined
	    if (config.getSubaddressIndices() === undefined) {
	      config.setSubaddressIndices([]);
	      for (let subaddress of await this.getSubaddresses(config.getAccountIndex())) {
	        config.getSubaddressIndices().push(subaddress.getIndex());
	      }
	    }
	    if (config.getSubaddressIndices().length === 0) throw new MoneroError("No subaddresses to sweep from");
	    
	    // common config params
	    let params = {};
	    let relay = config.getRelay() === true;
	    params.account_index = config.getAccountIndex();
	    params.subaddr_indices = config.getSubaddressIndices();
	    params.address = config.getDestinations()[0].getAddress();
	    assert(config.getPriority() === undefined || config.getPriority() >= 0 && config.getPriority() <= 3);
	    params.priority = config.getPriority();
	    params.unlock_time = config.getUnlockHeight();
	    params.payment_id = config.getPaymentId();
	    params.do_not_relay = !relay;
	    params.below_amount = config.getBelowAmount();
	    params.get_tx_keys = true;
	    params.get_tx_hex = true;
	    params.get_tx_metadata = true;
	    
	    // invoke wallet rpc `sweep_all`
	    let resp = await this.rpc.sendJsonRequest("sweep_all", params);
	    let result = resp.result;
	    
	    // initialize txs from response
	    let txSet = MoneroWalletRpc._convertRpcSentTxsToTxSet(result);
	    
	    // initialize remaining known fields
	    for (let tx of txSet.getTxs()) {
	      tx.setIsLocked(true);
	      tx.setIsConfirmed(false);
	      tx.setNumConfirmations(0);
	      tx.setRelay(relay);
	      tx.setInTxPool(relay);
	      tx.setIsRelayed(relay);
	      tx.setIsMinerTx(false);
	      tx.setIsFailed(false);
	      tx.setRingSize(MoneroUtils.RING_SIZE);
	      let transfer = tx.getOutgoingTransfer();
	      transfer.setAccountIndex(config.getAccountIndex());
	      if (config.getSubaddressIndices().length === 1) transfer.setSubaddressIndices(config.getSubaddressIndices());
	      let destination = new MoneroDestination(config.getDestinations()[0].getAddress(), new BigInteger(transfer.getAmount()));
	      transfer.setDestinations([destination]);
	      tx.setOutgoingTransfer(transfer);
	      tx.setPaymentId(config.getPaymentId());
	      if (tx.getUnlockHeight() === undefined) tx.setUnlockHeight(config.getUnlockHeight() === undefined ? 0 : config.getUnlockHeight());
	      if (tx.getRelay()) {
	        if (tx.getLastRelayedTimestamp() === undefined) tx.setLastRelayedTimestamp(+new Date().getTime());  // TODO (monero-wallet-rpc): provide timestamp on response; unconfirmed timestamps vary
	        if (tx.isDoubleSpendSeen() === undefined) tx.setIsDoubleSpend(false);
	      }
	    }
	    return txSet.getTxs();
	  }
	  
	  _refreshListening() {
	    if (this.walletPoller == undefined && this.listeners.length) this.walletPoller = new WalletPoller(this);
	    if (this.walletPoller !== undefined) this.walletPoller.setIsPolling(this.listeners.length > 0);
	  }
	  
	  /**
	   * Poll if listening.
	   */
	  async _poll() {
	    if (this.walletPoller !== undefined && this.walletPoller._isPolling) await this.walletPoller.poll();
	  }
	  
	  // ---------------------------- PRIVATE STATIC ------------------------------
	  
	  static _normalizeConfig(uriOrConfigOrConnection, username, password, rejectUnauthorized) {
	    let config;
	    if (typeof uriOrConfigOrConnection === "string") config = {uri: uriOrConfigOrConnection, username: username, password: password, rejectUnauthorized: rejectUnauthorized};
	    else {
	      if (typeof uriOrConfigOrConnection !== "object") throw new MoneroError("Invalid configuration to create rpc client; must be string, object, or MoneroRpcConnection");
	      if (username || password || rejectUnauthorized) throw new MoneroError("Can provide config object or params or new MoneroDaemonRpc(...) but not both");
	      if (uriOrConfigOrConnection instanceof MoneroRpcConnection) config = Object.assign({}, uriOrConfigOrConnection.getConfig());
	      else config = Object.assign({}, uriOrConfigOrConnection);
	    }
	    if (config.server) {
	      config = Object.assign(config, new MoneroRpcConnection(config.server).getConfig());
	      delete config.server;
	    }
	    return config;
	  }
	  
	  /**
	   * Remove criteria which requires looking up other transfers/outputs to
	   * fulfill query.
	   * 
	   * @param {MoneroTxQuery} query - the query to decontextualize
	   * @return {MoneroTxQuery} a reference to the query for convenience
	   */
	  static _decontextualize(query) {
	    query.setIsIncoming(undefined);
	    query.setIsOutgoing(undefined);
	    query.setTransferQuery(undefined);
	    query.setInputQuery(undefined);
	    query.setOutputQuery(undefined);
	    return query;
	  }
	  
	  static _isContextual(query) {
	    if (!query) return false;
	    if (!query.getTxQuery()) return false;
	    if (query.getTxQuery().isIncoming() !== undefined) return true; // requires getting other transfers
	    if (query.getTxQuery().isOutgoing() !== undefined) return true;
	    if (query instanceof MoneroTransferQuery) {
	      if (query.getTxQuery().getOutputQuery() !== undefined) return true; // requires getting other outputs
	    } else if (query instanceof MoneroOutputQuery) {
	      if (query.getTxQuery().getTransferQuery() !== undefined) return true; // requires getting other transfers
	    } else {
	      throw new MoneroError("query must be tx or transfer query");
	    }
	    return false;
	  }
	  
	  static _convertRpcAccount(rpcAccount) {
	    let account = new MoneroAccount();
	    for (let key of Object.keys(rpcAccount)) {
	      let val = rpcAccount[key];
	      if (key === "account_index") account.setIndex(val);
	      else if (key === "balance") account.setBalance(new BigInteger(val));
	      else if (key === "unlocked_balance") account.setUnlockedBalance(new BigInteger(val));
	      else if (key === "base_address") account.setPrimaryAddress(val);
	      else if (key === "tag") account.setTag(val);
	      else if (key === "label") ; // label belongs to first subaddress
	      else console.log("WARNING: ignoring unexpected account field: " + key + ": " + val);
	    }
	    if ("" === account.getTag()) account.setTag(undefined);
	    return account;
	  }
	  
	  static _convertRpcSubaddress(rpcSubaddress) {
	    let subaddress = new MoneroSubaddress();
	    for (let key of Object.keys(rpcSubaddress)) {
	      let val = rpcSubaddress[key];
	      if (key === "account_index") subaddress.setAccountIndex(val);
	      else if (key === "address_index") subaddress.setIndex(val);
	      else if (key === "address") subaddress.setAddress(val);
	      else if (key === "balance") subaddress.setBalance(new BigInteger(val));
	      else if (key === "unlocked_balance") subaddress.setUnlockedBalance(new BigInteger(val));
	      else if (key === "num_unspent_outputs") subaddress.setNumUnspentOutputs(val);
	      else if (key === "label") { if (val) subaddress.setLabel(val); }
	      else if (key === "used") subaddress.setIsUsed(val);
	      else if (key === "blocks_to_unlock") subaddress.setNumBlocksToUnlock(val);
	      else if (key == "time_to_unlock") ;  // ignoring
	      else console.log("WARNING: ignoring unexpected subaddress field: " + key + ": " + val);
	    }
	    return subaddress;
	  }
	  
	  /**
	   * Initializes a sent transaction.
	   * 
	   * @param {MoneroTxConfig} config - send config
	   * @param {MoneroTxWallet} tx - existing transaction to initialize (optional)
	   * @param {boolean} copyDestinations - copies config destinations if true
	   * @return {MoneroTxWallet} is the initialized send tx
	   */
	  static _initSentTxWallet(config, tx, copyDestinations) {
	    if (!tx) tx = new MoneroTxWallet();
	    let relay = config.getRelay() === true;
	    tx.setIsOutgoing(true);
	    tx.setIsConfirmed(false);
	    tx.setNumConfirmations(0);
	    tx.setInTxPool(relay);
	    tx.setRelay(relay);
	    tx.setIsRelayed(relay);
	    tx.setIsMinerTx(false);
	    tx.setIsFailed(false);
	    tx.setIsLocked(true);
	    tx.setRingSize(MoneroUtils.RING_SIZE);
	    let transfer = new MoneroOutgoingTransfer().setTx(tx);
	    if (config.getSubaddressIndices() && config.getSubaddressIndices().length === 1) transfer.setSubaddressIndices(config.getSubaddressIndices().slice(0)); // we know src subaddress indices iff config specifies 1
	    if (copyDestinations) {
	      let destCopies = [];
	      for (let dest of config.getDestinations()) destCopies.push(dest.copy());
	      transfer.setDestinations(destCopies);
	    }
	    tx.setOutgoingTransfer(transfer);
	    tx.setPaymentId(config.getPaymentId());
	    if (tx.getUnlockHeight() === undefined) tx.setUnlockHeight(config.getUnlockHeight() === undefined ? 0 : config.getUnlockHeight());
	    if (config.getRelay()) {
	      if (tx.getLastRelayedTimestamp() === undefined) tx.setLastRelayedTimestamp(+new Date().getTime());  // TODO (monero-wallet-rpc): provide timestamp on response; unconfirmed timestamps vary
	      if (tx.isDoubleSpendSeen() === undefined) tx.setIsDoubleSpend(false);
	    }
	    return tx;
	  }
	  
	  /**
	   * Initializes a tx set from a RPC map excluding txs.
	   * 
	   * @param rpcMap - map to initialize the tx set from
	   * @return MoneroTxSet - initialized tx set
	   * @return the resulting tx set
	   */
	  static _convertRpcTxSet(rpcMap) {
	    let txSet = new MoneroTxSet();
	    txSet.setMultisigTxHex(rpcMap.multisig_txset);
	    txSet.setUnsignedTxHex(rpcMap.unsigned_txset);
	    txSet.setSignedTxHex(rpcMap.signed_txset);
	    if (txSet.getMultisigTxHex() !== undefined && txSet.getMultisigTxHex().length === 0) txSet.setMultisigTxHex(undefined);
	    if (txSet.getUnsignedTxHex() !== undefined && txSet.getUnsignedTxHex().length === 0) txSet.setUnsignedTxHex(undefined);
	    if (txSet.getSignedTxHex() !== undefined && txSet.getSignedTxHex().length === 0) txSet.setSignedTxHex(undefined);
	    return txSet;
	  }
	  
	  /**
	   * Initializes a MoneroTxSet from from a list of rpc txs.
	   * 
	   * @param rpcTxs - rpc txs to initialize the set from
	   * @param txs - existing txs to further initialize (optional)
	   * @return the converted tx set
	   */
	  static _convertRpcSentTxsToTxSet(rpcTxs, txs) {
	    
	    // build shared tx set
	    let txSet = MoneroWalletRpc._convertRpcTxSet(rpcTxs);
	    
	    // get number of txs
	    let numTxs = rpcTxs.fee_list ? rpcTxs.fee_list.length : 0;
	    
	    // done if rpc response contains no txs
	    if (numTxs === 0) {
	      assert.equal(txs, undefined);
	      return txSet;
	    }
	    
	    // pre-initialize txs if none given
	    if (txs) txSet.setTxs(txs);
	    else {
	      txs = [];
	      for (let i = 0; i < numTxs; i++) txs.push(new MoneroTxWallet());
	    }
	    for (let tx of txs) {
	      tx.setTxSet(txSet);
	      tx.setIsOutgoing(true);
	    }
	    txSet.setTxs(txs);
	    
	    // initialize txs from rpc lists
	    for (let key of Object.keys(rpcTxs)) {
	      let val = rpcTxs[key];
	      if (key === "tx_hash_list") for (let i = 0; i < val.length; i++) txs[i].setHash(val[i]);
	      else if (key === "tx_key_list") for (let i = 0; i < val.length; i++) txs[i].setKey(val[i]);
	      else if (key === "tx_blob_list") for (let i = 0; i < val.length; i++) txs[i].setFullHex(val[i]);
	      else if (key === "tx_metadata_list") for (let i = 0; i < val.length; i++) txs[i].setMetadata(val[i]);
	      else if (key === "fee_list") for (let i = 0; i < val.length; i++) txs[i].setFee(new BigInteger(val[i]));
	      else if (key === "weight_list") for (let i = 0; i < val.length; i++) txs[i].setWeight(val[i]);
	      else if (key === "amount_list") {
	        for (let i = 0; i < val.length; i++) {
	          if (txs[i].getOutgoingTransfer() !== undefined) txs[i].getOutgoingTransfer().setAmount(new BigInteger(val[i]));
	          else txs[i].setOutgoingTransfer(new MoneroOutgoingTransfer().setTx(txs[i]).setAmount(new BigInteger(val[i])));
	        }
	      }
	      else if (key === "multisig_txset" || key === "unsigned_txset" || key === "signed_txset") ; // handled elsewhere
	      else if (key === "spent_key_images_list") {
	        let inputKeyImagesList = val;
	        for (let i = 0; i < inputKeyImagesList.length; i++) {
	          GenUtils.assertTrue(txs[i].getInputs() === undefined);
	          txs[i].setInputs([]);
	          for (let inputKeyImage of inputKeyImagesList[i]["key_images"]) {
	            txs[i].getInputs().push(new MoneroOutputWallet().setKeyImage(new MoneroKeyImage().setHex(inputKeyImage)).setTx(txs[i]));
	          }
	        }
	      }
	      else console.log("WARNING: ignoring unexpected transaction field: " + key + ": " + val);
	    }
	    
	    return txSet;
	  }
	  
	  /**
	   * Converts a rpc tx with a transfer to a tx set with a tx and transfer.
	   * 
	   * @param rpcTx - rpc tx to build from
	   * @param tx - existing tx to continue initializing (optional)
	   * @param isOutgoing - specifies if the tx is outgoing if true, incoming if false, or decodes from type if undefined
	   * @returns the initialized tx set with a tx
	   */
	  static _convertRpcTxToTxSet(rpcTx, tx, isOutgoing) {
	    let txSet = MoneroWalletRpc._convertRpcTxSet(rpcTx);
	    txSet.setTxs([MoneroWalletRpc._convertRpcTxWithTransfer(rpcTx, tx, isOutgoing).setTxSet(txSet)]);
	    return txSet;
	  }
	  
	  /**
	   * Builds a MoneroTxWallet from a RPC tx.
	   * 
	   * @param rpcTx - rpc tx to build from
	   * @param tx - existing tx to continue initializing (optional)
	   * @param isOutgoing - specifies if the tx is outgoing if true, incoming if false, or decodes from type if undefined
	   * @returns {MoneroTxWallet} is the initialized tx
	   */
	  static _convertRpcTxWithTransfer(rpcTx, tx, isOutgoing) {  // TODO: change everything to safe set
	        
	    // initialize tx to return
	    if (!tx) tx = new MoneroTxWallet();
	    
	    // initialize tx state from rpc type
	    if (rpcTx.type !== undefined) isOutgoing = MoneroWalletRpc._decodeRpcType(rpcTx.type, tx);
	    else assert.equal(typeof isOutgoing, "boolean", "Must indicate if tx is outgoing (true) xor incoming (false) since unknown");
	    
	    // TODO: safe set
	    // initialize remaining fields  TODO: seems this should be part of common function with DaemonRpc._convertRpcTx
	    let header;
	    let transfer;
	    for (let key of Object.keys(rpcTx)) {
	      let val = rpcTx[key];
	      if (key === "txid") tx.setHash(val);
	      else if (key === "tx_hash") tx.setHash(val);
	      else if (key === "fee") tx.setFee(new BigInteger(val));
	      else if (key === "note") { if (val) tx.setNote(val); }
	      else if (key === "tx_key") tx.setKey(val);
	      else if (key === "type") ; // type already handled
	      else if (key === "tx_size") tx.setSize(val);
	      else if (key === "unlock_time") tx.setUnlockHeight(val);
	      else if (key === "weight") tx.setWeight(val);
	      else if (key === "locked") tx.setIsLocked(val);
	      else if (key === "tx_blob") tx.setFullHex(val);
	      else if (key === "tx_metadata") tx.setMetadata(val);
	      else if (key === "double_spend_seen") tx.setIsDoubleSpend(val);
	      else if (key === "block_height" || key === "height") {
	        if (tx.isConfirmed()) {
	          if (!header) header = new MoneroBlockHeader();
	          header.setHeight(val);
	        }
	      }
	      else if (key === "timestamp") {
	        if (tx.isConfirmed()) {
	          if (!header) header = new MoneroBlockHeader();
	          header.setTimestamp(val);
	        }
	      }
	      else if (key === "confirmations") tx.setNumConfirmations(val);
	      else if (key === "suggested_confirmations_threshold") {
	        if (transfer === undefined) transfer = (isOutgoing ? new MoneroOutgoingTransfer() : new MoneroIncomingTransfer()).setTx(tx);
	        if (!isOutgoing) transfer.setNumSuggestedConfirmations(val);
	      }
	      else if (key === "amount") {
	        if (transfer === undefined) transfer = (isOutgoing ? new MoneroOutgoingTransfer() : new MoneroIncomingTransfer()).setTx(tx);
	        transfer.setAmount(new BigInteger(val));
	      }
	      else if (key === "amounts") ;  // ignoring, amounts sum to amount
	      else if (key === "address") {
	        if (!isOutgoing) {
	          if (!transfer) transfer = new MoneroIncomingTransfer().setTx(tx);
	          transfer.setAddress(val);
	        }
	      }
	      else if (key === "payment_id") {
	        if ("" !== val && MoneroTxWallet.DEFAULT_PAYMENT_ID !== val) tx.setPaymentId(val);  // default is undefined
	      }
	      else if (key === "subaddr_index") assert(rpcTx.subaddr_indices);  // handled by subaddr_indices
	      else if (key === "subaddr_indices") {
	        if (!transfer) transfer = (isOutgoing ? new MoneroOutgoingTransfer() : new MoneroIncomingTransfer()).setTx(tx);
	        let rpcIndices = val;
	        transfer.setAccountIndex(rpcIndices[0].major);
	        if (isOutgoing) {
	          let subaddressIndices = [];
	          for (let rpcIndex of rpcIndices) subaddressIndices.push(rpcIndex.minor);
	          transfer.setSubaddressIndices(subaddressIndices);
	        } else {
	          assert.equal(rpcIndices.length, 1);
	          transfer.setSubaddressIndex(rpcIndices[0].minor);
	        }
	      }
	      else if (key === "destinations" || key == "recipients") {
	        assert(isOutgoing);
	        let destinations = [];
	        for (let rpcDestination of val) {
	          let destination = new MoneroDestination();
	          destinations.push(destination);
	          for (let destinationKey of Object.keys(rpcDestination)) {
	            if (destinationKey === "address") destination.setAddress(rpcDestination[destinationKey]);
	            else if (destinationKey === "amount") destination.setAmount(new BigInteger(rpcDestination[destinationKey]));
	            else throw new MoneroError("Unrecognized transaction destination field: " + destinationKey);
	          }
	        }
	        if (transfer === undefined) transfer = new MoneroOutgoingTransfer({tx: tx});
	        transfer.setDestinations(destinations);
	      }
	      else if (key === "multisig_txset" && val !== undefined) ; // handled elsewhere; this method only builds a tx wallet
	      else if (key === "unsigned_txset" && val !== undefined) ; // handled elsewhere; this method only builds a tx wallet
	      else if (key === "amount_in") tx.setInputSum(new BigInteger(val));
	      else if (key === "amount_out") tx.setOutputSum(new BigInteger(val));
	      else if (key === "change_address") tx.setChangeAddress(val === "" ? undefined : val);
	      else if (key === "change_amount") tx.setChangeAmount(new BigInteger(val));
	      else if (key === "dummy_outputs") tx.setNumDummyOutputs(val);
	      else if (key === "extra") tx.setExtraHex(val);
	      else if (key === "ring_size") tx.setRingSize(val);
	      else if (key === "spent_key_images") {
	        let inputKeyImages = val.key_images;
	        GenUtils.assertTrue(tx.getInputs() === undefined);
	        tx.setInputs([]);
	        for (let inputKeyImage of inputKeyImages) {
	          tx.getInputs().push(new MoneroOutputWallet().setKeyImage(new MoneroKeyImage().setHex(inputKeyImage)).setTx(tx));
	        }
	      }
	      else console.log("WARNING: ignoring unexpected transaction field: " + key + ": " + val);
	    }
	    
	    // link block and tx
	    if (header) tx.setBlock(new MoneroBlock(header).setTxs([tx]));
	    
	    // initialize final fields
	    if (transfer) {
	      if (tx.isConfirmed() === undefined) tx.setIsConfirmed(false);
	      if (!transfer.getTx().isConfirmed()) tx.setNumConfirmations(0);
	      if (isOutgoing) {
	        tx.setIsOutgoing(true);
	        if (tx.getOutgoingTransfer()) tx.getOutgoingTransfer().merge(transfer);
	        else tx.setOutgoingTransfer(transfer);
	      } else {
	        tx.setIsIncoming(true);
	        tx.setIncomingTransfers([transfer]);
	      }
	    }
	    
	    // return initialized transaction
	    return tx;
	  }
	  
	  static _convertRpcTxWalletWithOutput(rpcOutput) {
	    
	    // initialize tx
	    let tx = new MoneroTxWallet();
	    tx.setIsConfirmed(true);
	    tx.setIsRelayed(true);
	    tx.setIsFailed(false);
	    
	    // initialize output
	    let output = new MoneroOutputWallet({tx: tx});
	    for (let key of Object.keys(rpcOutput)) {
	      let val = rpcOutput[key];
	      if (key === "amount") output.setAmount(new BigInteger(val));
	      else if (key === "spent") output.setIsSpent(val);
	      else if (key === "key_image") { if ("" !== val) output.setKeyImage(new MoneroKeyImage(val)); }
	      else if (key === "global_index") output.setIndex(val);
	      else if (key === "tx_hash") tx.setHash(val);
	      else if (key === "unlocked") tx.setIsLocked(!val);
	      else if (key === "frozen") output.setIsFrozen(val);
	      else if (key === "pubkey") output.setStealthPublicKey(val);
	      else if (key === "subaddr_index") {
	        output.setAccountIndex(val.major);
	        output.setSubaddressIndex(val.minor);
	      }
	      else if (key === "block_height") tx.setBlock(new MoneroBlock().setHeight(val).setTxs([tx]));
	      else console.log("WARNING: ignoring unexpected transaction field: " + key + ": " + val);
	    }
	    
	    // initialize tx with output
	    tx.setOutputs([output]);
	    return tx;
	  }
	  
	  static _convertRpcDescribeTransfer(rpcDescribeTransferResult) {
	    let txSet = new MoneroTxSet();
	    for (let key of Object.keys(rpcDescribeTransferResult)) {
	      let val = rpcDescribeTransferResult[key];
	      if (key === "desc") {
	        txSet.setTxs([]);
	        for (let txMap of val) {
	          let tx = MoneroWalletRpc._convertRpcTxWithTransfer(txMap, undefined, true);
	          tx.setTxSet(txSet);
	          txSet.getTxs().push(tx);
	        }
	      }
	      else if (key === "summary") ; // TODO: support tx set summary fields?
	      else console.log("WARNING: ignoring unexpected descdribe transfer field: " + key + ": " + val);
	    }
	    return txSet;
	  }
	  
	  /**
	   * Decodes a "type" from monero-wallet-rpc to initialize type and state
	   * fields in the given transaction.
	   * 
	   * TODO: these should be safe set
	   * 
	   * @param rpcType is the type to decode
	   * @param tx is the transaction to decode known fields to
	   * @return {boolean} true if the rpc type indicates outgoing xor incoming
	   */
	  static _decodeRpcType(rpcType, tx) {
	    let isOutgoing;
	    if (rpcType === "in") {
	      isOutgoing = false;
	      tx.setIsConfirmed(true);
	      tx.setInTxPool(false);
	      tx.setIsRelayed(true);
	      tx.setRelay(true);
	      tx.setIsFailed(false);
	      tx.setIsMinerTx(false);
	    } else if (rpcType === "out") {
	      isOutgoing = true;
	      tx.setIsConfirmed(true);
	      tx.setInTxPool(false);
	      tx.setIsRelayed(true);
	      tx.setRelay(true);
	      tx.setIsFailed(false);
	      tx.setIsMinerTx(false);
	    } else if (rpcType === "pool") {
	      isOutgoing = false;
	      tx.setIsConfirmed(false);
	      tx.setInTxPool(true);
	      tx.setIsRelayed(true);
	      tx.setRelay(true);
	      tx.setIsFailed(false);
	      tx.setIsMinerTx(false);  // TODO: but could it be?
	    } else if (rpcType === "pending") {
	      isOutgoing = true;
	      tx.setIsConfirmed(false);
	      tx.setInTxPool(true);
	      tx.setIsRelayed(true);
	      tx.setRelay(true);
	      tx.setIsFailed(false);
	      tx.setIsMinerTx(false);
	    } else if (rpcType === "block") {
	      isOutgoing = false;
	      tx.setIsConfirmed(true);
	      tx.setInTxPool(false);
	      tx.setIsRelayed(true);
	      tx.setRelay(true);
	      tx.setIsFailed(false);
	      tx.setIsMinerTx(true);
	    } else if (rpcType === "failed") {
	      isOutgoing = true;
	      tx.setIsConfirmed(false);
	      tx.setInTxPool(false);
	      tx.setIsRelayed(true);
	      tx.setRelay(true);
	      tx.setIsFailed(true);
	      tx.setIsMinerTx(false);
	    } else {
	      throw new MoneroError("Unrecognized transfer type: " + rpcType);
	    }
	    return isOutgoing;
	  }
	  
	  /**
	   * Merges a transaction into a unique set of transactions.
	   *
	   * @param {MoneroTxWallet} tx - the transaction to merge into the existing txs
	   * @param {Object} txMap - maps tx hashes to txs
	   * @param {Object} blockMap - maps block heights to blocks
	   */
	  static _mergeTx(tx, txMap, blockMap) {
	    assert(tx.getHash() !== undefined);
	    
	    // merge tx
	    let aTx = txMap[tx.getHash()];
	    if (aTx === undefined) txMap[tx.getHash()] = tx; // cache new tx
	    else aTx.merge(tx); // merge with existing tx
	    
	    // merge tx's block if confirmed
	    if (tx.getHeight() !== undefined) {
	      let aBlock = blockMap[tx.getHeight()];
	      if (aBlock === undefined) blockMap[tx.getHeight()] = tx.getBlock(); // cache new block
	      else aBlock.merge(tx.getBlock()); // merge with existing block
	    }
	  }
	  
	  /**
	   * Compares two transactions by their height.
	   */
	  static _compareTxsByHeight(tx1, tx2) {
	    if (tx1.getHeight() === undefined && tx2.getHeight() === undefined) return 0; // both unconfirmed
	    else if (tx1.getHeight() === undefined) return 1;   // tx1 is unconfirmed
	    else if (tx2.getHeight() === undefined) return -1;  // tx2 is unconfirmed
	    let diff = tx1.getHeight() - tx2.getHeight();
	    if (diff !== 0) return diff;
	    return tx1.getBlock().getTxs().indexOf(tx1) - tx2.getBlock().getTxs().indexOf(tx2); // txs are in the same block so retain their original order
	  }
	  
	  /**
	   * Compares two transfers by ascending account and subaddress indices.
	   */
	  static _compareIncomingTransfers(t1, t2) {
	    if (t1.getAccountIndex() < t2.getAccountIndex()) return -1;
	    else if (t1.getAccountIndex() === t2.getAccountIndex()) return t1.getSubaddressIndex() - t2.getSubaddressIndex();
	    return 1;
	  }
	  
	  /**
	   * Compares two outputs by ascending account and subaddress indices.
	   */
	  static _compareOutputs(o1, o2) {
	    
	    // compare by height
	    let heightComparison = MoneroWalletRpc._compareTxsByHeight(o1.getTx(), o2.getTx());
	    if (heightComparison !== 0) return heightComparison;
	    
	    // compare by account index, subaddress index, output index, then key image hex
	    let compare = o1.getAccountIndex() - o2.getAccountIndex();
	    if (compare !== 0) return compare;
	    compare = o1.getSubaddressIndex() - o2.getSubaddressIndex();
	    if (compare !== 0) return compare;
	    compare = o1.getIndex() - o2.getIndex();
	    if (compare !== 0) return compare;
	    return o1.getKeyImage().getHex().localeCompare(o2.getKeyImage().getHex());
	  }
	}

	/**
	 * Polls monero-wallet-rpc to provide listener notifications.
	 * 
	 * @class
	 * @ignore
	 */
	class WalletPoller {
	  
	  constructor(wallet) {
	    let that = this;
	    this._wallet = wallet;
	    this._looper = new TaskLooper(async function() { await that.poll(); });
	    this._prevLockedTxs = [];
	    this._prevUnconfirmedNotifications = new Set(); // tx hashes of previous notifications
	    this._prevConfirmedNotifications = new Set(); // tx hashes of previously confirmed but not yet unlocked notifications
	    this._threadPool = new ThreadPool(1); // synchronize polls
	    this._numPolling = 0;
	  }
	  
	  setIsPolling(isPolling) {
	    this._isPolling = isPolling;
	    if (isPolling) this._looper.start(this._wallet.syncPeriodInMs);
	    else this._looper.stop();
	  }
	  
	  setPeriodInMs(periodInMs) {
	    this._looper.setPeriodInMs(periodInMs);
	  }
	  
	  async poll() {
	    
	    // synchronize polls
	    let that = this;
	    return this._threadPool.submit(async function() {
	      try {
	        
	        // skip if next poll is already queued
	        if (that._numPolling > 1) return;
	        that._numPolling++;
	        
	        // skip if wallet is closed
	        if (await that._wallet.isClosed()) return;
	        
	        // take initial snapshot
	        if (that._prevHeight === undefined) {
	          that._prevHeight = await that._wallet.getHeight();
	          that._prevLockedTxs = await that._wallet.getTxs(new MoneroTxQuery().setIsLocked(true));
	          that._prevBalances = await that._wallet._getBalances();
	          that._numPolling--;
	          return;
	        }
	        
	        // announce height changes
	        let height = await that._wallet.getHeight();
	        if (that._prevHeight !== height) {
	          for (let i = that._prevHeight; i < height; i++) await that._onNewBlock(i);
	          that._prevHeight = height;
	        }
	        
	        // get locked txs for comparison to previous
	        let minHeight = Math.max(0, height - 70); // only monitor recent txs
	        let lockedTxs = await that._wallet.getTxs(new MoneroTxQuery().setIsLocked(true).setMinHeight(minHeight).setIncludeOutputs(true));
	        
	        // collect hashes of txs no longer locked
	        let noLongerLockedHashes = [];
	        for (let prevLockedTx of that._prevLockedTxs) {
	          if (that._getTx(lockedTxs, prevLockedTx.getHash()) === undefined) {
	            noLongerLockedHashes.push(prevLockedTx.getHash());
	          }
	        }
	        
	        // save locked txs for next comparison
	        that._prevLockedTxs = lockedTxs;
	        
	        // fetch txs which are no longer locked
	        let unlockedTxs = noLongerLockedHashes.length === 0 ? [] : await that._wallet.getTxs(new MoneroTxQuery().setIsLocked(false).setMinHeight(minHeight).setHashes(noLongerLockedHashes).setIncludeOutputs(true), []); // ignore missing tx hashes which could be removed due to re-org
	         
	        // announce new unconfirmed and confirmed outputs
	        for (let lockedTx of lockedTxs) {
	          let searchSet = lockedTx.isConfirmed() ? that._prevConfirmedNotifications : that._prevUnconfirmedNotifications;
	          let unannounced = !searchSet.has(lockedTx.getHash());
	          searchSet.add(lockedTx.getHash());
	          if (unannounced) await that._notifyOutputs(lockedTx);
	        }
	        
	        // announce new unlocked outputs
	        for (let unlockedTx of unlockedTxs) {
	          that._prevUnconfirmedNotifications.delete(unlockedTx.getHash());
	          that._prevConfirmedNotifications.delete(unlockedTx.getHash());
	          await that._notifyOutputs(unlockedTx);
	        }
	        
	        // announce balance changes
	        await that._checkForChangedBalances();
	        that._numPolling--;
	      } catch (err) {
	        that._numPolling--;
	        console.error("Failed to background poll " + await that._wallet.getPath());
	        console.error(err);
	      }
	    });
	  }
	  
	  async _onNewBlock(height) {
	    for (let listener of this._wallet.getListeners()) await listener.onNewBlock(height);
	  }
	  
	  async _notifyOutputs(tx) {
	  
	    // notify spent outputs // TODO (monero-project): monero-wallet-rpc does not allow scrape of tx inputs so providing one input with outgoing amount
	    if (tx.getOutgoingTransfer() !== undefined) {
	      assert(tx.getInputs() === undefined);
	      let output = new MoneroOutputWallet()
	          .setAmount(tx.getOutgoingTransfer().getAmount().add(tx.getFee()))
	          .setAccountIndex(tx.getOutgoingTransfer().getAccountIndex())
	          .setSubaddressIndex(tx.getOutgoingTransfer().getSubaddressIndices().length === 1 ? tx.getOutgoingTransfer().getSubaddressIndices()[0] : undefined) // initialize if transfer sourced from single subaddress
	          .setTx(tx);
	      tx.setInputs([output]);
	      for (let listener of this._wallet.getListeners()) await listener.onOutputSpent(output);
	    }
	    
	    // notify received outputs
	    if (tx.getIncomingTransfers() !== undefined) {
	      if (tx.getOutputs() !== undefined && tx.getOutputs().length > 0) { // TODO (monero-project): outputs only returned for confirmed txs
	        for (let output of tx.getOutputs()) {
	          for (let listener of this._wallet.getListeners()) await listener.onOutputReceived(output);
	        }
	      } else { // TODO (monero-project): monero-wallet-rpc does not allow scrape of unconfirmed received outputs so using incoming transfer values
	        let outputs = [];
	        for (let transfer of tx.getIncomingTransfers()) {
	          outputs.push(new MoneroOutputWallet()
	              .setAccountIndex(transfer.getAccountIndex())
	              .setSubaddressIndex(transfer.getSubaddressIndex())
	              .setAmount(transfer.getAmount())
	              .setTx(tx));
	        }
	        tx.setOutputs(outputs);
	        for (let listener of this._wallet.getListeners()) {
	          for (let output of tx.getOutputs()) await listener.onOutputReceived(output);
	        }
	      }
	    }
	  }
	  
	  _getTx(txs, txHash) {
	    for (let tx of txs) if (txHash === tx.getHash()) return tx;
	    return undefined;
	  }
	  
	  async _checkForChangedBalances() {
	    let balances = await this._wallet._getBalances();
	    if (balances[0].compare(this._prevBalances[0]) !== 0 || balances[1].compare(this._prevBalances[1]) !== 0) {
	      this._prevBalances = balances;
	      for (let listener of await this._wallet.getListeners()) await listener.onBalancesChanged(balances[0], balances[1]);
	      return true;
	    }
	    return false;
	  }
	}

	MoneroWalletRpc.DEFAULT_SYNC_PERIOD_IN_MS = 20000; // default period between syncs in ms (defined by DEFAULT_AUTO_REFRESH_PERIOD in wallet_rpc_server.cpp)

	MoneroWalletRpc_1 = MoneroWalletRpc;
	return MoneroWalletRpc_1;
}

var MoneroWalletKeys_1;
var hasRequiredMoneroWalletKeys;

function requireMoneroWalletKeys () {
	if (hasRequiredMoneroWalletKeys) return MoneroWalletKeys_1;
	hasRequiredMoneroWalletKeys = 1;
	const assert = require$$0;
	const LibraryUtils = requireLibraryUtils();
	const MoneroError = MoneroError_1;
	const MoneroNetworkType = MoneroNetworkType_1;
	const MoneroSubaddress = MoneroSubaddress_1;
	requireMoneroUtils();
	const MoneroVersion = MoneroVersion_1;
	const MoneroWallet = MoneroWallet_1;
	const MoneroWalletConfig = requireMoneroWalletConfig();

	/**
	 * Implements a MoneroWallet which only manages keys using WebAssembly.
	 * 
	 * @implements {MoneroWallet}
	 * @hideconstructor
	 */
	class MoneroWalletKeys extends MoneroWallet {
	  
	  // --------------------------- STATIC UTILITIES -----------------------------
	  
	  /**
	   * <p>Create a wallet using WebAssembly bindings to monero-project.</p>
	   * 
	   * <p>Example:</p>
	   * 
	   * <code>
	   * let wallet = await MoneroWalletKeys.createWallet({<br>
	   * &nbsp;&nbsp; password: "abc123",<br>
	   * &nbsp;&nbsp; networkType: MoneroNetworkType.STAGENET,<br>
	   * &nbsp;&nbsp; mnemonic: "coexist igloo pamphlet lagoon..."<br>
	   * });
	   * </code>
	   * 
	   * @param {MoneroWalletConfig|object} config - MoneroWalletConfig or equivalent config object
	   * @param {string|number} config.networkType - network type of the wallet to create (one of "mainnet", "testnet", "stagenet" or MoneroNetworkType.MAINNET|TESTNET|STAGENET)
	   * @param {string} config.mnemonic - mnemonic of the wallet to create (optional, random wallet created if neither mnemonic nor keys given)
	   * @param {string} config.seedOffset - the offset used to derive a new seed from the given mnemonic to recover a secret wallet from the mnemonic phrase
	   * @param {string} config.primaryAddress - primary address of the wallet to create (only provide if restoring from keys)
	   * @param {string} config.privateViewKey - private view key of the wallet to create (optional)
	   * @param {string} config.privateSpendKey - private spend key of the wallet to create (optional)
	   * @param {string} config.language - language of the wallet's mnemonic phrase (defaults to "English" or auto-detected)
	   * @return {MoneroWalletKeys} the created wallet
	   */
	  static async createWallet(config) {
	    
	    // normalize and validate config
	    if (config === undefined) throw new MoneroError("Must provide config to create wallet");
	    config = config instanceof MoneroWalletConfig ? config : new MoneroWalletConfig(config);
	    if (config.getMnemonic() !== undefined && (config.getPrimaryAddress() !== undefined || config.getPrivateViewKey() !== undefined || config.getPrivateSpendKey() !== undefined)) {
	      throw new MoneroError("Wallet may be initialized with a mnemonic or keys but not both");
	    }
	    if (config.getNetworkType() === undefined) throw new MoneroError("Must provide a networkType: 'mainnet', 'testnet' or 'stagenet'");
	    if (config.getSaveCurrent() === true) throw new MoneroError("Cannot save current wallet when creating keys-only wallet");
	    
	    // create wallet
	    if (config.getMnemonic() !== undefined) {
	      if (config.getLanguage() !== undefined) throw new MoneroError("Cannot provide language when creating wallet from mnemonic");
	      return MoneroWalletKeys._createWalletFromMnemonic(config.getNetworkType(), config.getMnemonic(), config.getSeedOffset());
	    } else if (config.getPrivateSpendKey() !== undefined || config.getPrimaryAddress() !== undefined) {
	      if (config.getSeedOffset() !== undefined) throw new MoneroError("Cannot provide seedOffset when creating wallet from keys");
	      return MoneroWalletKeys._createWalletFromKeys(config.getNetworkType(), config.getPrimaryAddress(), config.getPrivateViewKey(), config.getPrivateSpendKey(), config.getLanguage());
	    } else {
	      if (config.getSeedOffset() !== undefined) throw new MoneroError("Cannot provide seedOffset when creating random wallet");
	      if (config.getRestoreHeight() !== undefined) throw new MoneroError("Cannot provide restoreHeight when creating random wallet");
	      return MoneroWalletKeys._createWalletRandom(config.getNetworkType(), config.getLanguage());
	    }
	  }
	  
	  static async _createWalletRandom(networkType, language) {

	    // validate and sanitize params
	    MoneroNetworkType.validate(networkType);
	    if (language === undefined) language = "English";
	    
	    // load wasm module
	    let module = await LibraryUtils.loadKeysModule();
	    
	    // queue call to wasm module
	    return module.queueTask(async function() {
	      return new Promise(function(resolve, reject) {
	        
	        // define callback for wasm
	        let callbackFn = async function(cppAddress) {
	          if (typeof cppAddress === "string") reject(new MoneroError(cppAddress));
	          else resolve(new MoneroWalletKeys(cppAddress));
	        };
	        
	        // create wallet in wasm and invoke callback when done
	        module.create_keys_wallet_random(networkType, language, callbackFn);
	      });
	    });
	  }
	  
	  static async _createWalletFromMnemonic(networkType, mnemonic, seedOffset) {
	    
	    // validate and sanitize params
	    MoneroNetworkType.validate(networkType);
	    if (mnemonic === undefined) throw Error("Must define mnemonic phrase to create wallet from");
	    if (seedOffset === undefined) seedOffset = "";
	    
	    // load wasm module
	    let module = await LibraryUtils.loadKeysModule();
	    
	    // queue call to wasm module
	    return module.queueTask(async function() {
	      return new Promise(function(resolve, reject) {
	        
	        // define callback for wasm
	        let callbackFn = async function(cppAddress) {
	          if (typeof cppAddress === "string") reject(new MoneroError(cppAddress));
	          else resolve(new MoneroWalletKeys(cppAddress));
	        };
	        
	        // create wallet in wasm and invoke callback when done
	        module.create_keys_wallet_from_mnemonic(networkType, mnemonic, seedOffset, callbackFn);
	      });
	    });
	  }
	  
	  static async _createWalletFromKeys(networkType, address, privateViewKey, privateSpendKey, language) {
	    
	    // validate and sanitize params
	    MoneroNetworkType.validate(networkType);
	    if (address === undefined) address = "";
	    if (privateViewKey === undefined) privateViewKey = "";
	    if (privateSpendKey === undefined) privateSpendKey = "";
	    if (language === undefined) language = "English";
	    
	    // load wasm module
	    let module = await LibraryUtils.loadKeysModule();
	    
	    // queue call to wasm module
	    return module.queueTask(async function() {
	      return new Promise(function(resolve, reject) {
	        
	        // define callback for wasm
	        let callbackFn = async function(cppAddress) {
	          if (typeof cppAddress === "string") reject(new MoneroError(cppAddress));
	          else resolve(new MoneroWalletKeys(cppAddress));
	        };
	        
	        // create wallet in wasm and invoke callback when done
	        module.create_keys_wallet_from_keys(networkType, address, privateViewKey, privateSpendKey, language, callbackFn);
	      });
	    });
	  }
	  
	  static async getMnemonicLanguages() {
	    let module = await LibraryUtils.loadKeysModule();
	    return module.queueTask(async function() {
	      return JSON.parse(module.get_keys_wallet_mnemonic_languages()).languages;
	    });
	  }
	  
	  // --------------------------- INSTANCE METHODS -----------------------------
	  
	  /**
	   * Internal constructor which is given the memory address of a C++ wallet
	   * instance.
	   * 
	   * This method should not be called externally but should be called through
	   * static wallet creation utilities in this class.
	   * 
	   * @param {int} cppAddress - address of the wallet instance in C++
	   */
	  constructor(cppAddress) {
	    super();
	    this._cppAddress = cppAddress;
	    this._module = LibraryUtils.getWasmModule();
	    if (!this._module.create_full_wallet) throw new MoneroError("WASM module not loaded - create wallet instance using static utilities");  // static utilites pre-load wasm module
	  }
	  
	  async addListener(listener) {
	    throw new MoneroError("MoneroWalletKeys does not support adding listeners");
	  }
	  
	  async removeListener(listener) {
	    throw new MoneroError("MoneroWalletKeys does not support removing listeners");
	  }
	  
	  async isViewOnly() {
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      return that._module.is_view_only(that._cppAddress);
	    });
	  }
	  
	  async isConnectedToDaemon() {
	    return false;
	  }
	  
	  async getVersion() {
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      let versionStr = that._module.get_version(that._cppAddress);
	      let versionJson = JSON.parse(versionStr);
	      return new MoneroVersion(versionJson.number, versionJson.isRelease);
	    });
	  }
	  
	  /**
	   * @ignore
	   */
	  getPath() {
	    this._assertNotClosed();
	    throw new MoneroError("MoneroWalletKeys does not support a persisted path");
	  }
	  
	  async getMnemonic() {
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      let mnemonic = that._module.get_mnemonic(that._cppAddress);
	      return mnemonic ? mnemonic : undefined;
	    });
	  }
	  
	  async getMnemonicLanguage() {
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      let mnemonicLanguage = that._module.get_mnemonic_language(that._cppAddress);
	      return mnemonicLanguage ? mnemonicLanguage : undefined;
	    });
	  }
	  
	  async getPrivateSpendKey() {
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      let privateSpendKey = that._module.get_private_spend_key(that._cppAddress);
	      return privateSpendKey ? privateSpendKey : undefined;
	    });
	  }
	  
	  async getPrivateViewKey() {
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      return that._module.get_private_view_key(that._cppAddress);
	    });
	  }
	  
	  async getPublicViewKey() {
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      return that._module.get_public_view_key(that._cppAddress);
	    });
	  }
	  
	  async getPublicSpendKey() {
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      return that._module.get_public_spend_key(that._cppAddress);
	    });
	  }
	  
	  async getAddress(accountIdx, subaddressIdx) {
	    this._assertNotClosed();
	    assert(typeof accountIdx === "number");
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      return that._module.get_address(that._cppAddress, accountIdx, subaddressIdx);
	    });
	  }
	  
	  async getAddressIndex(address) {
	    this._assertNotClosed();
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      let resp = that._module.get_address_index(that._cppAddress, address);
	      if (resp.charAt(0) !== '{') throw new MoneroError(resp);
	      return new MoneroSubaddress(JSON.parse(resp));
	    });
	  }
	  
	  getAccounts() {
	    this._assertNotClosed();
	    throw new MoneroError("MoneroWalletKeys does not support getting an enumerable set of accounts; query specific accounts");
	  }
	  
	  // getIntegratedAddress(paymentId)  // TODO
	  // decodeIntegratedAddress
	  
	  async close(save) {
	    if (this._isClosed) return; // closing a closed wallet has no effect
	    
	    // save wallet if requested
	    if (save) await this.save();
	    
	    // queue task to use wasm module
	    let that = this;
	    return that._module.queueTask(async function() {
	      return new Promise(function(resolve, reject) {
	        if (that._isClosed) {
	          resolve();
	          return;
	        }
	        
	        // define callback for wasm
	        let callbackFn = async function() {
	          delete that._cppAddress;
	          that._isClosed = true;
	          resolve();
	        };
	        
	        // close wallet in wasm and invoke callback when done
	        that._module.close(that._cppAddress, false, callbackFn);  // saving handled external to webassembly
	      });
	    });
	  }
	  
	  async isClosed() {
	    return this._isClosed;
	  }
	  
	  // ----------- ADD JSDOC FOR SUPPORTED DEFAULT IMPLEMENTATIONS --------------
	  
	  async getPrimaryAddress() { return super.getPrimaryAddress(...arguments); }
	  async getSubaddress() { return super.getSubaddress(...arguments); }
	  
	  // ----------------------------- PRIVATE HELPERS ----------------------------
	  
	  _assertNotClosed() {
	    if (this._isClosed) throw new MoneroError("Wallet is closed");
	  }
	}

	MoneroWalletKeys_1 = MoneroWalletKeys;
	return MoneroWalletKeys_1;
}

var MoneroWalletFull_1;
var hasRequiredMoneroWalletFull;

function requireMoneroWalletFull () {
	if (hasRequiredMoneroWalletFull) return MoneroWalletFull_1;
	hasRequiredMoneroWalletFull = 1;
	const assert = require$$0;
	const BigInteger = biginteger.BigInteger;
	const GenUtils = GenUtils_1;
	const LibraryUtils = requireLibraryUtils();
	const TaskLooper = TaskLooper_1;
	const MoneroAccount = MoneroAccount_1;
	const MoneroAddressBookEntry = MoneroAddressBookEntry_1;
	const MoneroBlock = MoneroBlock_1;
	const MoneroCheckTx = MoneroCheckTx_1;
	const MoneroCheckReserve = MoneroCheckReserve_1;
	const MoneroDaemonRpc = requireMoneroDaemonRpc();
	const MoneroError = MoneroError_1;
	const MoneroIntegratedAddress = MoneroIntegratedAddress_1;
	const MoneroKeyImage = MoneroKeyImage_1;
	const MoneroKeyImageImportResult = MoneroKeyImageImportResult_1;
	const MoneroMultisigInfo = MoneroMultisigInfo_1;
	const MoneroMultisigInitResult = MoneroMultisigInitResult_1;
	const MoneroMultisigSignResult = MoneroMultisigSignResult_1;
	const MoneroNetworkType = MoneroNetworkType_1;
	const MoneroOutputWallet = MoneroOutputWallet_1;
	const MoneroRpcConnection = requireMoneroRpcConnection();
	const MoneroSubaddress = MoneroSubaddress_1;
	const MoneroSyncResult = MoneroSyncResult_1;
	const MoneroTxConfig = MoneroTxConfig_1;
	const MoneroTxSet = requireMoneroTxSet();
	const MoneroTxWallet = requireMoneroTxWallet();
	const MoneroWallet = MoneroWallet_1;
	const MoneroWalletConfig = requireMoneroWalletConfig();
	const MoneroWalletKeys = requireMoneroWalletKeys();
	const MoneroWalletListener = MoneroWalletListener_1;
	const MoneroMessageSignatureType = MoneroMessageSignatureType_1;
	const MoneroMessageSignatureResult = MoneroMessageSignatureResult_1;

	/**
	 * Implements a Monero wallet using fully client-side WebAssembly bindings to monero-project's wallet2 in C++.
	 * 
	 * @extends {MoneroWalletKeys}
	 * @implements {MoneroWallet}
	 * @hideconstructor
	 */
	class MoneroWalletFull extends MoneroWalletKeys {
	  
	  // --------------------------- STATIC UTILITIES -----------------------------
	  
	  /**
	   * Check if a wallet exists at a given path.
	   * 
	   * @param {string} path - path of the wallet on the file system
	   * @param {fs} - Node.js compatible file system to use (optional, defaults to disk if nodejs)
	   * @return {boolean} true if a wallet exists at the given path, false otherwise
	   */
	  static walletExists(path, fs) {
	    assert(path, "Must provide a path to look for a wallet");
	    if (!fs) fs = MoneroWalletFull._getFs();
	    if (!fs) throw new MoneroError("Must provide file system to check if wallet exists");
	    let exists = fs.existsSync(path + ".keys");
	    LibraryUtils.log(1, "Wallet exists at " + path + ": " + exists);
	    return exists;
	  }
	  
	  /**
	   * <p>Open an existing wallet using WebAssembly bindings to wallet2.h.</p>
	   * 
	   * <p>Examples:<p>
	   * 
	   * <code>
	   * let wallet1 = await MoneroWalletFull.openWallet(<br>
	   * &nbsp;&nbsp; "./wallets/wallet1",<br>
	   * &nbsp;&nbsp; "supersecretpassword",<br>
	   * &nbsp;&nbsp; MoneroNetworkType.STAGENET,<br>
	   * &nbsp;&nbsp; "http://localhost:38081" // daemon uri<br>
	   * );<br><br>
	   * 
	   * let wallet2 = await MoneroWalletFull.openWallet({<br>
	   * &nbsp;&nbsp; path: "./wallets/wallet2",<br>
	   * &nbsp;&nbsp; password: "supersecretpassword",<br>
	   * &nbsp;&nbsp; networkType: MoneroNetworkType.STAGENET,<br>
	   * &nbsp;&nbsp; serverUri: "http://localhost:38081", // daemon configuration<br>
	   * &nbsp;&nbsp; serverUsername: "superuser",<br>
	   * &nbsp;&nbsp; serverPassword: "abctesting123"<br>
	   * });
	   * </code>
	   * 
	   * @param {MoneroWalletConfig|object|string} configOrPath - MoneroWalletConfig or equivalent config object or a path to a wallet to open
	   * @param {string} configOrPath.path - path of the wallet to open (optional if 'keysData' provided)
	   * @param {string} configOrPath.password - password of the wallet to open
	   * @param {string|number} configOrPath.networkType - network type of the wallet to open (one of "mainnet", "testnet", "stagenet" or MoneroNetworkType.MAINNET|TESTNET|STAGENET)
	   * @param {Uint8Array} configOrPath.keysData - wallet keys data to open (optional if path provided)
	   * @param {Uint8Array} configOrPath.cacheData - wallet cache data to open (optional)
	   * @param {string} configOrPath.serverUri - uri of the wallet's daemon (optional)
	   * @param {string} configOrPath.serverUsername - username to authenticate with the daemon (optional)
	   * @param {string} configOrPath.serverPassword - password to authenticate with the daemon (optional)
	   * @param {boolean} configOrPath.rejectUnauthorized - reject self-signed server certificates if true (default true)
	   * @param {MoneroRpcConnection|object} configOrPath.server - MoneroRpcConnection or equivalent JS object configuring the daemon connection (optional)
	   * @param {boolean} configOrPath.proxyToWorker - proxies wallet operations to a worker in order to not block the main thread (default true)
	   * @param {fs} configOrPath.fs - Node.js compatible file system to use (defaults to disk or in-memory FS if browser)
	   * @param {string} password - password of the wallet to open
	   * @param {string|number} networkType - network type of the wallet to open
	   * @param {string|MoneroRpcConnection} daemonUriOrConnection - daemon URI or MoneroRpcConnection
	   * @param {boolean} proxyToWorker - proxies wallet operations to a worker in order to not block the main thread (default true)
	   * @param {fs} fs - Node.js compatible file system to use (defaults to disk or in-memory FS if browser)
	   * @return {MoneroWalletFull} the opened wallet
	   */
	  static async openWallet(configOrPath, password, networkType, daemonUriOrConnection, proxyToWorker, fs) {

	    // normalize and validate config
	    let config;
	    if (typeof configOrPath === "object") {
	      config = configOrPath instanceof MoneroWalletConfig ? configOrPath : new MoneroWalletConfig(configOrPath);
	      if (password !== undefined || networkType !== undefined || daemonUriOrConnection !== undefined || proxyToWorker !== undefined || fs !== undefined) throw new MoneroError("Can specify config object or params but not both when opening WASM wallet")
	    } else {
	      config = new MoneroWalletConfig().setPath(configOrPath).setPassword(password).setNetworkType(networkType).setProxyToWorker(proxyToWorker).setFs(fs);
	      if (typeof daemonUriOrConnection === "object") config.setServer(daemonUriOrConnection);
	      else config.setServerUri(daemonUriOrConnection);
	    }
	    if (config.getProxyToWorker() === undefined) config.setProxyToWorker(true);
	    if (config.getMnemonic() !== undefined) throw new MoneroError("Cannot specify mnemonic when opening wallet");
	    if (config.getSeedOffset() !== undefined) throw new MoneroError("Cannot specify seed offset when opening wallet");
	    if (config.getPrimaryAddress() !== undefined) throw new MoneroError("Cannot specify primary address when opening wallet");
	    if (config.getPrivateViewKey() !== undefined) throw new MoneroError("Cannot specify private view key when opening wallet");
	    if (config.getPrivateSpendKey() !== undefined) throw new MoneroError("Cannot specify private spend key when opening wallet");
	    if (config.getRestoreHeight() !== undefined) throw new MoneroError("Cannot specify restore height when opening wallet");
	    if (config.getLanguage() !== undefined) throw new MoneroError("Cannot specify language when opening wallet");
	    if (config.getSaveCurrent() === true) throw new MoneroError("Cannot save current wallet when opening JNI wallet");
	    
	    // read wallet data from disk if not provided
	    if (!config.getKeysData()) {
	      let fs = config.getFs() ? config.getFs() : MoneroWalletFull._getFs();
	      if (!fs) throw new MoneroError("Must provide file system to read wallet data from");
	      if (!this.walletExists(config.getPath(), fs)) throw new MoneroError("Wallet does not exist at path: " + config.getPath());
	      config.setKeysData(fs.readFileSync(config.getPath() + ".keys"));
	      config.setCacheData(fs.existsSync(config.getPath()) ? fs.readFileSync(config.getPath()) : "");
	    }
	    
	    // open wallet from data
	    return MoneroWalletFull._openWalletData(config.getPath(), config.getPassword(), config.getNetworkType(), config.getKeysData(), config.getCacheData(), config.getServer(), config.getProxyToWorker(), config.getFs());
	  }
	  
	  /**
	   * <p>Create a wallet using WebAssembly bindings to wallet2.h.<p>
	   * 
	   * <p>Example:</p>
	   * 
	   * <code>
	   * let wallet = await MoneroWalletFull.createWallet({<br>
	   * &nbsp;&nbsp; path: "./test_wallets/wallet1", // leave blank for in-memory wallet<br>
	   * &nbsp;&nbsp; password: "supersecretpassword",<br>
	   * &nbsp;&nbsp; networkType: MoneroNetworkType.STAGENET,<br>
	   * &nbsp;&nbsp; mnemonic: "coexist igloo pamphlet lagoon...",<br>
	   * &nbsp;&nbsp; restoreHeight: 1543218,<br>
	   * &nbsp;&nbsp; server: new MoneroRpcConnection("http://localhost:38081", "daemon_user", "daemon_password_123"),<br>
	   * });
	   * </code>
	   * 
	   * @param {object|MoneroWalletConfig} config - MoneroWalletConfig or equivalent config object
	   * @param {string} config.path - path of the wallet to create (optional, in-memory wallet if not given)
	   * @param {string} config.password - password of the wallet to create
	   * @param {string|number} config.networkType - network type of the wallet to create (one of "mainnet", "testnet", "stagenet" or MoneroNetworkType.MAINNET|TESTNET|STAGENET)
	   * @param {string} config.mnemonic - mnemonic of the wallet to create (optional, random wallet created if neither mnemonic nor keys given)
	   * @param {string} config.seedOffset - the offset used to derive a new seed from the given mnemonic to recover a secret wallet from the mnemonic phrase
	   * @param {string} config.primaryAddress - primary address of the wallet to create (only provide if restoring from keys)
	   * @param {string} config.privateViewKey - private view key of the wallet to create (optional)
	   * @param {string} config.privateSpendKey - private spend key of the wallet to create (optional)
	   * @param {number} config.restoreHeight - block height to start scanning from (defaults to 0 unless generating random wallet)
	   * @param {string} config.language - language of the wallet's mnemonic phrase (defaults to "English" or auto-detected)
	   * @param {number} config.accountLookahead -  number of accounts to scan (optional)
	   * @param {number} config.subaddressLookahead - number of subaddresses to scan per account (optional)
	   * @param {string} config.serverUri - uri of the wallet's daemon (optional)
	   * @param {string} config.serverUsername - username to authenticate with the daemon (optional)
	   * @param {string} config.serverPassword - password to authenticate with the daemon (optional)
	   * @param {boolean} config.rejectUnauthorized - reject self-signed server certificates if true (defaults to true)
	   * @param {MoneroRpcConnection|object} config.server - MoneroRpcConnection or equivalent JS object providing daemon configuration (optional)
	   * @param {boolean} config.proxyToWorker - proxies wallet operations to a worker in order to not block the main thread (default true)
	   * @param {fs} config.fs - Node.js compatible file system to use (defaults to disk or in-memory FS if browser)
	   * @return {MoneroWalletFull} the created wallet
	   */
	  static async createWallet(config) {
	    
	    // normalize and validate config
	    if (config === undefined) throw new MoneroError("Must provide config to create wallet");
	    config = config instanceof MoneroWalletConfig ? config : new MoneroWalletConfig(config);
	    if (config.getMnemonic() !== undefined && (config.getPrimaryAddress() !== undefined || config.getPrivateViewKey() !== undefined || config.getPrivateSpendKey() !== undefined)) {
	      throw new MoneroError("Wallet may be initialized with a mnemonic or keys but not both");
	    } // TODO: factor this much out to common
	    if (config.getNetworkType() === undefined) throw new MoneroError("Must provide a networkType: 'mainnet', 'testnet' or 'stagenet'");
	    MoneroNetworkType.validate(config.getNetworkType());
	    if (config.getSaveCurrent() === true) throw new MoneroError("Cannot save current wallet when creating full WASM wallet");
	    if (config.getPath() === undefined) config.setPath("");
	    if (config.getPath() && MoneroWalletFull.walletExists(config.getPath(), config.getFs())) throw new MoneroError("Wallet already exists: " + config.getPath());
	    if (!config.getPassword()) throw new MoneroError("Must provide a password to create the wallet with");
	    
	    // create wallet
	    if (config.getMnemonic() !== undefined) {
	      if (config.getLanguage() !== undefined) throw new MoneroError("Cannot provide language when creating wallet from mnemonic");
	      return MoneroWalletFull._createWalletFromMnemonic(config);
	    } else if (config.getPrivateSpendKey() !== undefined || config.getPrimaryAddress() !== undefined) {
	      if (config.getSeedOffset() !== undefined) throw new MoneroError("Cannot provide seedOffset when creating wallet from keys");
	      return MoneroWalletFull._createWalletFromKeys(config);
	    } else {
	      if (config.getSeedOffset() !== undefined) throw new MoneroError("Cannot provide seedOffset when creating random wallet");
	      if (config.getRestoreHeight() !== undefined) throw new MoneroError("Cannot provide restoreHeight when creating random wallet");
	      return MoneroWalletFull._createWalletRandom(config);
	    }
	  }
	  
	  static async _createWalletFromMnemonic(config) {
	    if (config.getProxyToWorker() === undefined) config.setProxyToWorker(true);
	    if (config.getProxyToWorker()) return MoneroWalletFullProxy._createWallet(config);
	    
	    // validate and normalize params
	    let daemonConnection = config.getServer();
	    let rejectUnauthorized = daemonConnection ? daemonConnection.getRejectUnauthorized() : true;
	    if (config.getRestoreHeight() === undefined) config.setRestoreHeight(0);
	    if (config.getSeedOffset() === undefined) config.setSeedOffset("");
	    
	    // load full wasm module
	    let module = await LibraryUtils.loadFullModule();
	    
	    // create wallet in queue
	    let wallet = await module.queueTask(async function() {
	      return new Promise(function(resolve, reject) {
	        
	        // register fn informing if unauthorized reqs should be rejected
	        let rejectUnauthorizedFnId = GenUtils.getUUID();
	        LibraryUtils.setRejectUnauthorizedFn(rejectUnauthorizedFnId, function() { return rejectUnauthorized });
	        
	        // define callback for wasm
	        let callbackFn = async function(cppAddress) {
	          if (typeof cppAddress === "string") reject(new MoneroError(cppAddress));
	          else resolve(new MoneroWalletFull(cppAddress, config.getPath(), config.getPassword(), config.getFs(), config.getRejectUnauthorized(), rejectUnauthorizedFnId));
	        };
	        
	        // create wallet in wasm and invoke callback when done
	        module.create_full_wallet(JSON.stringify(config.toJson()), rejectUnauthorizedFnId, callbackFn);
	      });
	    });
	    
	    // save wallet
	    if (config.getPath()) await wallet.save();
	    return wallet;
	  }
	  
	  static async _createWalletFromKeys(config) {
	    if (config.getProxyToWorker() === undefined) config.setProxyToWorker(true);
	    if (config.getProxyToWorker()) return MoneroWalletFullProxy._createWallet(config);
	    
	    // validate and normalize params
	    MoneroNetworkType.validate(config.getNetworkType());
	    if (config.getPrimaryAddress() === undefined) config.setPrimaryAddress("");
	    if (config.getPrivateViewKey() === undefined) config.setPrivateViewKey("");
	    if (config.getPrivateSpendKey() === undefined) config.setPrivateSpendKey("");
	    let daemonConnection = config.getServer();
	    let rejectUnauthorized = daemonConnection ? daemonConnection.getRejectUnauthorized() : true;
	    if (config.getRestoreHeight() === undefined) config.setRestoreHeight(0);
	    if (config.getLanguage() === undefined) config.setLanguage("English");
	    
	    // load full wasm module
	    let module = await LibraryUtils.loadFullModule();
	    
	    // create wallet in queue
	    let wallet = await module.queueTask(async function() {
	      return new Promise(function(resolve, reject) {
	        
	        // register fn informing if unauthorized reqs should be rejected
	        let rejectUnauthorizedFnId = GenUtils.getUUID();
	        LibraryUtils.setRejectUnauthorizedFn(rejectUnauthorizedFnId, function() { return rejectUnauthorized });
	        
	        // define callback for wasm
	        let callbackFn = async function(cppAddress) {
	          if (typeof cppAddress === "string") reject(new MoneroError(cppAddress));
	          else resolve(new MoneroWalletFull(cppAddress, config.getPath(), config.getPassword(), config.getFs(), config.getRejectUnauthorized(), rejectUnauthorizedFnId));
	        };
	        
	        // create wallet in wasm and invoke callback when done
	        module.create_full_wallet(JSON.stringify(config.toJson()), rejectUnauthorizedFnId, callbackFn);
	      });
	    });
	    
	    // save wallet
	    if (config.getPath()) await wallet.save();
	    return wallet;
	  }
	  
	  static async _createWalletRandom(config) {
	    if (config.getProxyToWorker() === undefined) config.setProxyToWorker(true);
	    if (config.getProxyToWorker()) return MoneroWalletFullProxy._createWallet(config);
	    
	    // validate and normalize params
	    if (config.getLanguage() === undefined) config.setLanguage("English");
	    let daemonConnection = config.getServer();
	    let rejectUnauthorized = daemonConnection ? daemonConnection.getRejectUnauthorized() : true;
	    
	    // load wasm module
	    let module = await LibraryUtils.loadFullModule();
	    
	    // create wallet in queue
	    let wallet = await module.queueTask(async function() {
	      return new Promise(function(resolve, reject) {
	        
	        // register fn informing if unauthorized reqs should be rejected
	        let rejectUnauthorizedFnId = GenUtils.getUUID();
	        LibraryUtils.setRejectUnauthorizedFn(rejectUnauthorizedFnId, function() { return rejectUnauthorized });
	      
	        // define callback for wasm
	        let callbackFn = async function(cppAddress) {
	          if (typeof cppAddress === "string") reject(new MoneroError(cppAddress));
	          else resolve(new MoneroWalletFull(cppAddress, config.getPath(), config.getPassword(), config.getFs(), config.getRejectUnauthorized(), rejectUnauthorizedFnId));
	        };
	        
	        // create wallet in wasm and invoke callback when done
	        module.create_full_wallet(JSON.stringify(config.toJson()), rejectUnauthorizedFnId, callbackFn);
	      });
	    });
	    
	    // save wallet
	    if (config.getPath()) await wallet.save();
	    return wallet;
	  }
	  
	  static async getMnemonicLanguages() {
	    let module = await LibraryUtils.loadFullModule();
	    return module.queueTask(async function() {
	      return JSON.parse(module.get_keys_wallet_mnemonic_languages()).languages;
	    });
	  }
	  
	  // --------------------------- INSTANCE METHODS -----------------------------
	  
	  /**
	   * Internal constructor which is given the memory address of a C++ wallet
	   * instance.
	   * 
	   * This method should not be called externally but should be called through
	   * static wallet creation utilities in this class.
	   * 
	   * @param {int} cppAddress - address of the wallet instance in C++
	   * @param {string} path - path of the wallet instance
	   * @param {string} password - password of the wallet instance
	   * @param {FileSystem} fs - node.js-compatible file system to read/write wallet files
	   * @param {boolean} rejectUnauthorized - specifies if unauthorized requests (e.g. self-signed certificates) should be rejected
	   * @param {string} rejectUnauthorizedFnId - unique identifier for http_client_wasm to query rejectUnauthorized
	   */
	  constructor(cppAddress, path, password, fs, rejectUnauthorized, rejectUnauthorizedFnId) {
	    super(cppAddress);
	    this._path = path;
	    this._password = password;
	    this._listeners = [];
	    this._fs = fs ? fs : (path ? MoneroWalletFull._getFs() : undefined);
	    this._isClosed = false;
	    this._fullListener = new WalletFullListener(this); // receives notifications from wasm c++
	    this._fullListenerHandle = 0;                      // memory address of the wallet listener in c++
	    this._rejectUnauthorized = rejectUnauthorized;
	    this._rejectUnauthorizedConfigId = rejectUnauthorizedFnId;
	    this._syncPeriodInMs = MoneroWalletFull.DEFAULT_SYNC_PERIOD_IN_MS;
	    let that = this;
	    LibraryUtils.setRejectUnauthorizedFn(rejectUnauthorizedFnId, function() { return that._rejectUnauthorized }); // register fn informing if unauthorized reqs should be rejected
	  }
	  
	  // ------------ WALLET METHODS SPECIFIC TO WASM IMPLEMENTATION --------------
	  
	  /**
	   * Get the maximum height of the peers the wallet's daemon is connected to.
	   *
	   * @return {number} the maximum height of the peers the wallet's daemon is connected to
	   */
	  async getDaemonMaxPeerHeight() {
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      return new Promise(function(resolve, reject) {
	      
	        // define callback for wasm
	        let callbackFn = function(resp) {
	          resolve(resp);
	        };
	        
	        // call wasm and invoke callback when done
	        that._module.get_daemon_max_peer_height(that._cppAddress, callbackFn);
	      });
	    });
	  }
	  
	  /**
	   * Indicates if the wallet's daemon is synced with the network.
	   * 
	   * @return {boolean} true if the daemon is synced with the network, false otherwise
	   */
	  async isDaemonSynced() {
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      return new Promise(function(resolve, reject) {
	      
	        // define callback for wasm
	        let callbackFn = function(resp) {
	          resolve(resp);
	        };
	        
	        // call wasm and invoke callback when done
	        that._module.is_daemon_synced(that._cppAddress, callbackFn);
	      });
	    });
	  }
	  
	  /**
	   * Indicates if the wallet is synced with the daemon.
	   * 
	   * @return {boolean} true if the wallet is synced with the daemon, false otherwise
	   */
	  async isSynced() {
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      return new Promise(function(resolve, reject) {
	      
	        // define callback for wasm
	        let callbackFn = function(resp) {
	          resolve(resp);
	        };
	        
	        // call wasm and invoke callback when done
	        that._module.is_synced(that._cppAddress, callbackFn);
	      });
	    });
	  }
	  
	  /**
	   * Get the wallet's network type (mainnet, testnet, or stagenet).
	   * 
	   * @return {MoneroNetworkType} the wallet's network type
	   */
	  async getNetworkType() {
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      return that._module.get_network_type(that._cppAddress);
	    });
	  }
	  
	  /**
	   * Get the height of the first block that the wallet scans.
	   * 
	   * @return {number} the height of the first block that the wallet scans
	   */
	  async getSyncHeight() {
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      return that._module.get_sync_height(that._cppAddress);
	    });
	  }
	  
	  /**
	   * Set the height of the first block that the wallet scans.
	   * 
	   * @param {number} syncHeight - height of the first block that the wallet scans
	   */
	  async setSyncHeight(syncHeight) {
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      return that._module.set_sync_height(that._cppAddress, syncHeight);
	    });
	  }
	  
	  /**
	   * Move the wallet from its current path to the given path.
	   * 
	   * @param {string} path - the wallet's destination path
	   */
	  async moveTo(path) {
	    return MoneroWalletFull._moveTo(path, this);
	  }
	  
	  // -------------------------- COMMON WALLET METHODS -------------------------
	  
	  async addListener(listener) {
	    this._assertNotClosed();
	    assert(listener instanceof MoneroWalletListener, "Listener must be instance of MoneroWalletListener");
	    this._listeners.push(listener);
	    await this._refreshListening();
	  }
	  
	  async removeListener(listener) {
	    this._assertNotClosed();
	    let idx = this._listeners.indexOf(listener);
	    if (idx > -1) this._listeners.splice(idx, 1);
	    else throw new MoneroError("Listener is not registered with wallet");
	    await this._refreshListening();
	  }
	  
	  getListeners() {
	    this._assertNotClosed();
	    return this._listeners;
	  }
	  
	  async setDaemonConnection(uriOrRpcConnection) {
	    this._assertNotClosed();
	    
	    // normalize connection
	    let connection = !uriOrRpcConnection ? undefined : uriOrRpcConnection instanceof MoneroRpcConnection ? uriOrRpcConnection : new MoneroRpcConnection(uriOrRpcConnection);
	    let uri = connection && connection.getUri() ? connection.getUri() : "";
	    let username = connection && connection.getUsername() ? connection.getUsername() : "";
	    let password = connection && connection.getPassword() ? connection.getPassword() : "";
	    let rejectUnauthorized = connection ? connection.getRejectUnauthorized() : undefined;
	    this._rejectUnauthorized = rejectUnauthorized;  // persist locally
	    
	    // set connection in queue
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      return new Promise(function(resolve, reject) {
	      
	        // define callback for wasm
	        let callbackFn = function(resp) { resolve(); };
	        
	        // call wasm and invoke callback when done
	        that._module.set_daemon_connection(that._cppAddress, uri, username, password, callbackFn);
	      });
	    });
	  }
	  
	  async getDaemonConnection() {
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      return new Promise(function(resolve, reject) {
	        let connectionContainerStr = that._module.get_daemon_connection(that._cppAddress);
	        if (!connectionContainerStr) resolve();
	        else {
	          let jsonConnection = JSON.parse(connectionContainerStr);
	          resolve(new MoneroRpcConnection(jsonConnection.uri, jsonConnection.username, jsonConnection.password, that._rejectUnauthorized));
	        }
	      });
	    });
	  }
	  
	  async isConnectedToDaemon() {
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      return new Promise(function(resolve, reject) {
	      
	        // define callback for wasm
	        let callbackFn = function(resp) {
	          resolve(resp);
	        };
	        
	        // call wasm and invoke callback when done
	        that._module.is_connected_to_daemon(that._cppAddress, callbackFn);
	      });
	    });
	  }
	  
	  async getVersion() {
	    this._assertNotClosed();
	    throw new MoneroError("Not implemented");
	  }
	  
	  async getPath() {
	    this._assertNotClosed();
	    return this._path;
	  }
	  
	  async getIntegratedAddress(standardAddress, paymentId) {
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      try {
	        let result = that._module.get_integrated_address(that._cppAddress, standardAddress ? standardAddress : "", paymentId ? paymentId : "");
	        if (result.charAt(0) !== "{") throw new MoneroError(result);
	        return new MoneroIntegratedAddress(JSON.parse(result));
	      } catch (err) {
	        if (err.message.includes("Invalid payment ID")) throw new MoneroError("Invalid payment ID: " + paymentId);
	        throw new MoneroError(err.message);
	      }
	    });
	  }
	  
	  async decodeIntegratedAddress(integratedAddress) {
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      try {
	        let result = that._module.decode_integrated_address(that._cppAddress, integratedAddress);
	        if (result.charAt(0) !== "{") throw new MoneroError(result);
	        return new MoneroIntegratedAddress(JSON.parse(result));
	      } catch (err) {
	        throw new MoneroError(err.message);
	      }
	    });
	  }
	  
	  async getHeight() {
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      return new Promise(function(resolve, reject) {
	        
	        // define callback for wasm
	        let callbackFn = function(resp) {
	          resolve(resp);
	        };
	        
	        // call wasm and invoke callback when done
	        that._module.get_height(that._cppAddress, callbackFn);
	      });
	    });
	  }
	  
	  async getDaemonHeight() {
	    this._assertNotClosed();
	    if (!(await this.isConnectedToDaemon())) throw new MoneroError("Wallet is not connected to daemon");
	    
	    // schedule task
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      return new Promise(function(resolve, reject) {
	        
	        // define callback for wasm
	        let callbackFn = function(resp) {
	          resolve(resp);
	        };
	        
	        // call wasm and invoke callback when done
	        that._module.get_daemon_height(that._cppAddress, callbackFn);
	      });
	    });
	  }
	  
	  async getHeightByDate(year, month, day) {
	    this._assertNotClosed();
	    if (!(await this.isConnectedToDaemon())) throw new MoneroError("Wallet is not connected to daemon");
	    
	    // schedule task
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      return new Promise(function(resolve, reject) {
	        
	        // define callback for wasm
	        let callbackFn = function(resp) {
	          if (typeof resp === "string") reject(new MoneroError(resp));
	          else resolve(resp);
	        };
	        
	        // call wasm and invoke callback when done
	        that._module.get_height_by_date(that._cppAddress, year, month, day, callbackFn);
	      });
	    });
	  }
	  
	  /**
	   * Synchronize the wallet with the daemon as a one-time synchronous process.
	   * 
	   * @param {MoneroWalletListener|number} listenerOrStartHeight - listener xor start height (defaults to no sync listener, the last synced block)
	   * @param {number} startHeight - startHeight if not given in first arg (defaults to last synced block)
	   * @param {bool} allowConcurrentCalls - allow other wallet methods to be processed simultaneously during sync (default false)<br><br><b>WARNING</b>: enabling this option will crash wallet execution if another call makes a simultaneous network request. TODO: possible to sync wasm network requests in http_client_wasm.cpp? 
	   */
	  async sync(listenerOrStartHeight, startHeight, allowConcurrentCalls) {
	    this._assertNotClosed();
	    if (!(await this.isConnectedToDaemon())) throw new MoneroError("Wallet is not connected to daemon");
	    
	    // normalize params
	    startHeight = listenerOrStartHeight === undefined || listenerOrStartHeight instanceof MoneroWalletListener ? startHeight : listenerOrStartHeight;
	    let listener = listenerOrStartHeight instanceof MoneroWalletListener ? listenerOrStartHeight : undefined;
	    if (startHeight === undefined) startHeight = Math.max(await this.getHeight(), await this.getSyncHeight());
	    
	    // register listener if given
	    if (listener) await this.addListener(listener);
	    
	    // sync wallet
	    let err;
	    let result;
	    try {
	      let that = this;
	      result = await (allowConcurrentCalls ? syncWasm() : that._module.queueTask(async function() { return syncWasm(); }));
	      function syncWasm() {
	        that._assertNotClosed();
	        return new Promise(function(resolve, reject) {
	        
	          // define callback for wasm
	          let callbackFn = async function(resp) {
	            if (resp.charAt(0) !== "{") reject(new MoneroError(resp));
	            else {
	              let respJson = JSON.parse(resp);
	              resolve(new MoneroSyncResult(respJson.numBlocksFetched, respJson.receivedMoney));
	            }
	          };
	          
	          // sync wallet in wasm and invoke callback when done
	          that._module.sync(that._cppAddress, startHeight, callbackFn);
	        });
	      }
	    } catch (e) {
	      err = e;
	    }
	    
	    // unregister listener
	    if (listener) await this.removeListener(listener);
	    
	    // throw error or return
	    if (err) throw err;
	    return result;
	  }
	  
	  async startSyncing(syncPeriodInMs) {
	    this._assertNotClosed();
	    if (!(await this.isConnectedToDaemon())) throw new MoneroError("Wallet is not connected to daemon");
	    this._syncPeriodInMs = syncPeriodInMs === undefined ? MoneroWalletFull.DEFAULT_SYNC_PERIOD_IN_MS : syncPeriodInMs;
	    let that = this;
	    if (!this._syncLooper) this._syncLooper = new TaskLooper(async function() { await that._backgroundSync(); });
	    this._syncLooper.start(this._syncPeriodInMs);
	  }
	    
	  async stopSyncing() {
	    this._assertNotClosed();
	    if (this._syncLooper) this._syncLooper.stop();
	    this._module.stop_syncing(this._cppAddress); // task is not queued so wallet stops immediately
	  }
	  
	  async scanTxs(txHashes) {
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      return new Promise(function(resolve, reject) {
	        let callbackFn = function(err) {
	          if (err) reject(new MoneroError(msg));
	          else resolve();
	        }; 
	        that._module.scan_txs(that._cppAddress, JSON.stringify({txHashes: txHashes}), callbackFn);
	      });
	    });
	  }
	  
	  async rescanSpent() {
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      return new Promise(function(resolve, reject) {
	        let callbackFn = function() { resolve(); };
	        that._module.rescan_spent(that._cppAddress, callbackFn);
	      });
	    });
	  }
	  
	  async rescanBlockchain() {
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      return new Promise(function(resolve, reject) {
	        let callbackFn = function() { resolve(); };
	        that._module.rescan_blockchain(that._cppAddress, callbackFn);
	      });
	    });
	  }
	  
	  async getBalance(accountIdx, subaddressIdx) {
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      
	      // get balance encoded in json string
	      let balanceStr;
	      if (accountIdx === undefined) {
	        assert(subaddressIdx === undefined, "Subaddress index must be undefined if account index is undefined");
	        balanceStr = that._module.get_balance_wallet(that._cppAddress);
	      } else if (subaddressIdx === undefined) {
	        balanceStr = that._module.get_balance_account(that._cppAddress, accountIdx);
	      } else {
	        balanceStr = that._module.get_balance_subaddress(that._cppAddress, accountIdx, subaddressIdx);
	      }
	      
	      // parse json string to BigInteger
	      return BigInteger.parse(JSON.parse(GenUtils.stringifyBIs(balanceStr)).balance);
	    });
	  }
	  
	  async getUnlockedBalance(accountIdx, subaddressIdx) {
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      
	      // get balance encoded in json string
	      let unlockedBalanceStr;
	      if (accountIdx === undefined) {
	        assert(subaddressIdx === undefined, "Subaddress index must be undefined if account index is undefined");
	        unlockedBalanceStr = that._module.get_unlocked_balance_wallet(that._cppAddress);
	      } else if (subaddressIdx === undefined) {
	        unlockedBalanceStr = that._module.get_unlocked_balance_account(that._cppAddress, accountIdx);
	      } else {
	        unlockedBalanceStr = that._module.get_unlocked_balance_subaddress(that._cppAddress, accountIdx, subaddressIdx);
	      }
	      
	      // parse json string to BigInteger
	      return BigInteger.parse(JSON.parse(GenUtils.stringifyBIs(unlockedBalanceStr)).unlockedBalance);
	    });
	  }
	  
	  async getAccounts(includeSubaddresses, tag) {
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      let accountsStr = that._module.get_accounts(that._cppAddress, includeSubaddresses ? true : false, tag ? tag : "");
	      let accounts = [];
	      for (let accountJson of JSON.parse(GenUtils.stringifyBIs(accountsStr)).accounts) {
	        accounts.push(MoneroWalletFull._sanitizeAccount(new MoneroAccount(accountJson)));
	      }
	      return accounts;
	    });
	  }
	  
	  async getAccount(accountIdx, includeSubaddresses) {
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      let accountStr = that._module.get_account(that._cppAddress, accountIdx, includeSubaddresses ? true : false);
	      let accountJson = JSON.parse(GenUtils.stringifyBIs(accountStr));
	      return MoneroWalletFull._sanitizeAccount(new MoneroAccount(accountJson));
	    });

	  }
	  
	  async createAccount(label) {
	    if (label === undefined) label = "";
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      let accountStr = that._module.create_account(that._cppAddress, label);
	      let accountJson = JSON.parse(GenUtils.stringifyBIs(accountStr));
	      return MoneroWalletFull._sanitizeAccount(new MoneroAccount(accountJson));
	    });
	  }
	  
	  async getSubaddresses(accountIdx, subaddressIndices) {
	    let args = {accountIdx: accountIdx, subaddressIndices: subaddressIndices === undefined ? [] : GenUtils.listify(subaddressIndices)};
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      let subaddressesJson = JSON.parse(GenUtils.stringifyBIs(that._module.get_subaddresses(that._cppAddress, JSON.stringify(args)))).subaddresses;
	      let subaddresses = [];
	      for (let subaddressJson of subaddressesJson) subaddresses.push(MoneroWalletFull._sanitizeSubaddress(new MoneroSubaddress(subaddressJson)));
	      return subaddresses;
	    });
	  }
	  
	  async createSubaddress(accountIdx, label) {
	    if (label === undefined) label = "";
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      let subaddressStr = that._module.create_subaddress(that._cppAddress, accountIdx, label);
	      let subaddressJson = JSON.parse(GenUtils.stringifyBIs(subaddressStr));
	      return MoneroWalletFull._sanitizeSubaddress(new MoneroSubaddress(subaddressJson));
	    });
	  }
	  
	  async getTxs(query, missingTxHashes) {
	    this._assertNotClosed();
	    
	    // copy and normalize query up to block
	    query = MoneroWallet._normalizeTxQuery(query);
	    
	    // schedule task
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      return new Promise(function(resolve, reject) {
	        
	        // define callback for wasm
	        let callbackFn = function(blocksJsonStr) {
	            
	          // check for error
	          if (blocksJsonStr.charAt(0) !== "{") {
	            reject(new MoneroError(blocksJsonStr));
	            return;
	          }
	          
	          // resolve with deserialized txs
	          try {
	            resolve(MoneroWalletFull._deserializeTxs(query, blocksJsonStr, missingTxHashes));
	          } catch (err) {
	            reject(err);
	          }
	        };
	        
	        // call wasm and invoke callback when done
	        that._module.get_txs(that._cppAddress, JSON.stringify(query.getBlock().toJson()), callbackFn);
	      });
	    });
	  }
	  
	  async getTransfers(query) {
	    this._assertNotClosed();
	    
	    // copy and normalize query up to block
	    query = MoneroWallet._normalizeTransferQuery(query);
	    
	    // return promise which resolves on callback
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      return new Promise(function(resolve, reject) {
	        
	        // define callback for wasm
	        let callbackFn = function(blocksJsonStr) {
	            
	          // check for error
	          if (blocksJsonStr.charAt(0) !== "{") {
	            reject(new MoneroError(blocksJsonStr));
	            return;
	          }
	           
	          // resolve with deserialized transfers 
	          try {
	            resolve(MoneroWalletFull._deserializeTransfers(query, blocksJsonStr));
	          } catch (err) {
	            reject(err);
	          }
	        };
	        
	        // call wasm and invoke callback when done
	        that._module.get_transfers(that._cppAddress, JSON.stringify(query.getTxQuery().getBlock().toJson()), callbackFn);
	      });
	    });
	  }
	  
	  async getOutputs(query) {
	    this._assertNotClosed();
	    
	    // copy and normalize query up to block
	    query = MoneroWallet._normalizeOutputQuery(query);
	    
	    // return promise which resolves on callback
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      return new Promise(function(resolve, reject) {
	        
	        // define callback for wasm
	        let callbackFn = function(blocksJsonStr) {
	          
	          // check for error
	          if (blocksJsonStr.charAt(0) !== "{") {
	            reject(new MoneroError(blocksJsonStr));
	            return;
	          }
	          
	          // resolve with deserialized outputs
	          try {
	            resolve(MoneroWalletFull._deserializeOutputs(query, blocksJsonStr));
	          } catch (err) {
	            reject(err);
	          }
	        };
	        
	        // call wasm and invoke callback when done
	        that._module.get_outputs(that._cppAddress, JSON.stringify(query.getTxQuery().getBlock().toJson()), callbackFn);
	      });
	    });
	  }
	  
	  async exportOutputs(all) {
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      return new Promise(function(resolve, reject) {
	        that._module.export_outputs(that._cppAddress, all, function(outputsHex) { resolve(outputsHex); });
	      });
	    });
	  }
	  
	  async importOutputs(outputsHex) {
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      return new Promise(function(resolve, reject) {
	        that._module.import_outputs(that._cppAddress, outputsHex, function(numImported) { resolve(numImported); });
	      });
	    });
	  }
	  
	  async exportKeyImages(all) {
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      return new Promise(function(resolve, reject) {
	        let callback = function(keyImagesStr) {
	          let keyImages = [];
	          for (let keyImageJson of JSON.parse(GenUtils.stringifyBIs(keyImagesStr)).keyImages) keyImages.push(new MoneroKeyImage(keyImageJson));
	          resolve(keyImages);
	        };
	        that._module.export_key_images(that._cppAddress, all, callback);
	      });
	    });
	  }
	  
	  async importKeyImages(keyImages) {
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      return new Promise(function(resolve, reject) {
	        let callback = function(keyImageImportResultStr) {
	          resolve(new MoneroKeyImageImportResult(JSON.parse(GenUtils.stringifyBIs(keyImageImportResultStr))));
	        };
	        that._module.import_key_images(that._cppAddress, JSON.stringify({keyImages: keyImages.map(keyImage => keyImage.toJson())}), callback);
	      });
	    });
	  }
	  
	  async getNewKeyImagesFromLastImport() {
	    this._assertNotClosed();
	    throw new MoneroError("Not implemented");
	  }
	  
	  async freezeOutput(keyImage) {
	    if (!keyImage) throw new MoneroError("Must specify key image to freeze");
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      return new Promise(function(resolve, reject) {
	        let callbackFn = function() { resolve(); };
	        that._module.freeze_output(that._cppAddress, keyImage, callbackFn);
	      });
	    });
	  }
	  
	  async thawOutput(keyImage) {
	    if (!keyImage) throw new MoneroError("Must specify key image to thaw");
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      return new Promise(function(resolve, reject) {
	        let callbackFn = function() { resolve(); };
	        that._module.thaw_output(that._cppAddress, keyImage, callbackFn);
	      });
	    });
	  }
	  
	  async isOutputFrozen(keyImage) {
	    if (!keyImage) throw new MoneroError("Must specify key image to check if frozen");
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      return new Promise(function(resolve, reject) {
	        let callbackFn = function(result) { resolve(result); };
	        that._module.is_output_frozen(that._cppAddress, keyImage, callbackFn);
	      });
	    });
	  }
	  
	  async createTxs(config) {
	    this._assertNotClosed();
	    
	    // validate, copy, and normalize config
	    config = MoneroWallet._normalizeCreateTxsConfig(config);
	    if (config.getCanSplit() === undefined) config.setCanSplit(true);
	    
	    // return promise which resolves on callback
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      return new Promise(function(resolve, reject) {
	        
	        // define callback for wasm
	        let callbackFn = function(txSetJsonStr) {
	          if (txSetJsonStr.charAt(0) !== '{') reject(new MoneroError(txSetJsonStr)); // json expected, else error
	          else resolve(new MoneroTxSet(JSON.parse(GenUtils.stringifyBIs(txSetJsonStr))).getTxs());
	        };
	        
	        // create txs in wasm and invoke callback when done
	        that._module.create_txs(that._cppAddress, JSON.stringify(config.toJson()), callbackFn);
	      });
	    });
	  }
	  
	  async sweepOutput(config) {
	    this._assertNotClosed();
	    
	    // normalize and validate config
	    config = MoneroWallet._normalizeSweepOutputConfig(config);
	    
	    // return promise which resolves on callback
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      return new Promise(function(resolve, reject) {
	        
	        // define callback for wasm
	        let callbackFn = function(txSetJsonStr) {
	          if (txSetJsonStr.charAt(0) !== '{') reject(new MoneroError(txSetJsonStr)); // json expected, else error
	          else resolve(new MoneroTxSet(JSON.parse(GenUtils.stringifyBIs(txSetJsonStr))).getTxs()[0]);
	        };
	        
	        // sweep output in wasm and invoke callback when done
	        that._module.sweep_output(that._cppAddress, JSON.stringify(config.toJson()), callbackFn);
	      });
	    });
	  }

	  async sweepUnlocked(config) {
	    this._assertNotClosed();
	    
	    // validate and normalize config
	    config = MoneroWallet._normalizeSweepUnlockedConfig(config);
	    
	    // return promise which resolves on callback
	    let that = this;
	    return that._module.queueTask(async function() { // TODO: could factor this pattern out, invoked with module params and callback handler
	      that._assertNotClosed();
	      return new Promise(function(resolve, reject) {
	        
	        // define callback for wasm
	        let callbackFn = function(txSetsJson) {
	          if (txSetsJson.charAt(0) !== '{') reject(new MoneroError(txSetsJson)); // json expected, else error
	          else {
	            let txSets = [];
	            for (let txSetJson of JSON.parse(GenUtils.stringifyBIs(txSetsJson)).txSets) txSets.push(new MoneroTxSet(txSetJson));
	            let txs = [];
	            for (let txSet of txSets) for (let tx of txSet.getTxs()) txs.push(tx);
	            resolve(txs);
	          }
	        };
	        
	        // sweep unlocked in wasm and invoke callback when done
	        that._module.sweep_unlocked(that._cppAddress, JSON.stringify(config.toJson()), callbackFn);
	      });
	    });
	  }
	  
	  async sweepDust(relay) {
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      return new Promise(function(resolve, reject) {
	        
	        // define callback for wasm
	        let callbackFn = function(txSetJsonStr) {
	          if (txSetJsonStr.charAt(0) !== '{') reject(new MoneroError(txSetJsonStr)); // json expected, else error
	          else {
	            let txSet = new MoneroTxSet(JSON.parse(GenUtils.stringifyBIs(txSetJsonStr)));
	            if (txSet.getTxs() === undefined) txSet.setTxs([]);
	            resolve(txSet.getTxs());
	          }
	        };
	        
	        // call wasm and invoke callback when done
	        that._module.sweep_dust(that._cppAddress, relay, callbackFn);
	      });
	    });
	  }
	  
	  async relayTxs(txsOrMetadatas) {
	    this._assertNotClosed();
	    assert(Array.isArray(txsOrMetadatas), "Must provide an array of txs or their metadata to relay");
	    let txMetadatas = [];
	    for (let txOrMetadata of txsOrMetadatas) txMetadatas.push(txOrMetadata instanceof MoneroTxWallet ? txOrMetadata.getMetadata() : txOrMetadata);
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      return new Promise(function(resolve, reject) {
	        let callback = function(txHashesJson) {
	          if (txHashesJson.charAt(0) !== "{") reject(new MoneroError(txHashesJson));
	          else resolve(JSON.parse(txHashesJson).txHashes);
	        };
	        that._module.relay_txs(that._cppAddress, JSON.stringify({txMetadatas: txMetadatas}), callback);
	      });
	    });
	  }
	  
	  async describeTxSet(txSet) {
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      txSet = new MoneroTxSet()
	              .setUnsignedTxHex(txSet.getUnsignedTxHex())
	              .setSignedTxHex(txSet.getSignedTxHex())
	              .setMultisigTxHex(txSet.getMultisigTxHex());
	      try { return new MoneroTxSet(JSON.parse(GenUtils.stringifyBIs(that._module.describe_tx_set(that._cppAddress, JSON.stringify(txSet.toJson()))))); }
	      catch (err) { throw new MoneroError(that._module.get_exception_message(err)); }
	    });
	  }
	  
	  async signTxs(unsignedTxHex) {
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      try { return that._module.sign_txs(that._cppAddress, unsignedTxHex); }
	      catch (err) { throw new MoneroError(that._module.get_exception_message(err)); }
	    });
	  }
	  
	  async submitTxs(signedTxHex) {
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      return new Promise(function(resolve, reject) {
	        let callbackFn = function(resp) {
	          if (resp.charAt(0) !== "{") reject(new MoneroError(resp));
	          else resolve(JSON.parse(resp).txHashes);
	        };
	        that._module.submit_txs(that._cppAddress, signedTxHex, callbackFn);
	      });
	    });
	  }
	  
	  async signMessage(message, signatureType, accountIdx, subaddressIdx) {
	    
	    // assign defaults
	    signatureType = signatureType || MoneroMessageSignatureType.SIGN_WITH_SPEND_KEY;
	    accountIdx = accountIdx || 0;
	    subaddressIdx = subaddressIdx || 0;
	    
	    // queue task to sign message
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      try { return that._module.sign_message(that._cppAddress, message, signatureType === MoneroMessageSignatureType.SIGN_WITH_SPEND_KEY ? 0 : 1, accountIdx, subaddressIdx); }
	      catch (err) { throw new MoneroError(that._module.get_exception_message(err)); }
	    });
	  }
	  
	  async verifyMessage(message, address, signature) {
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      let resultJson;
	      try {
	        resultJson = JSON.parse(that._module.verify_message(that._cppAddress, message, address, signature));
	      } catch (err) {
	        resultJson = {isGood: false};
	      }
	      let result = new MoneroMessageSignatureResult(
	        resultJson.isGood,
	        !resultJson.isGood ? undefined : resultJson.isOld,
	        !resultJson.isGood ? undefined : resultJson.signatureType === "spend" ? MoneroMessageSignatureType.SIGN_WITH_SPEND_KEY : MoneroMessageSignatureType.SIGN_WITH_VIEW_KEY,
	        !resultJson.isGood ? undefined : resultJson.version);
	      return result;
	    });
	  }
	  
	  async getTxKey(txHash) {
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      try { return that._module.get_tx_key(that._cppAddress, txHash); }
	      catch (err) { throw new MoneroError(that._module.get_exception_message(err)); }
	    });
	  }
	  
	  async checkTxKey(txHash, txKey, address) {
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed(); 
	      return new Promise(function(resolve, reject) {
	        that._module.check_tx_key(that._cppAddress, txHash, txKey, address, function(respJsonStr) {
	          if (respJsonStr.charAt(0) !== "{") reject(new MoneroError(respJsonStr));
	          else resolve(new MoneroCheckTx(JSON.parse(GenUtils.stringifyBIs(respJsonStr))));
	        });
	      });
	    });
	  }
	  
	  async getTxProof(txHash, address, message) {
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      return new Promise(function(resolve, reject) {
	        that._module.get_tx_proof(that._cppAddress, txHash || "", address || "", message || "", function(signature) {
	          let errorKey = "error: ";
	          if (signature.indexOf(errorKey) === 0) reject(new MoneroError(signature.substring(errorKey.length)));
	          else resolve(signature);
	        });
	      });
	    });
	  }
	  
	  async checkTxProof(txHash, address, message, signature) {
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed(); 
	      return new Promise(function(resolve, reject) {
	        that._module.check_tx_proof(that._cppAddress, txHash || "", address || "", message || "", signature || "", function(respJsonStr) {
	          if (respJsonStr.charAt(0) !== "{") reject(new MoneroError(respJsonStr));
	          else resolve(new MoneroCheckTx(JSON.parse(GenUtils.stringifyBIs(respJsonStr))));
	        });
	      });
	    });
	  }
	  
	  async getSpendProof(txHash, message) {
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      return new Promise(function(resolve, reject) {
	        that._module.get_spend_proof(that._cppAddress, txHash || "", message || "", function(signature) {
	          let errorKey = "error: ";
	          if (signature.indexOf(errorKey) === 0) reject(new MoneroError(signature.substring(errorKey.length)));
	          else resolve(signature);
	        });
	      });
	    });
	  }
	  
	  async checkSpendProof(txHash, message, signature) {
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed(); 
	      return new Promise(function(resolve, reject) {
	        that._module.check_spend_proof(that._cppAddress, txHash || "", message || "", signature || "", function(resp) {
	          typeof resp === "string" ? reject(new MoneroError(resp)) : resolve(resp);
	        });
	      });
	    });
	  }
	  
	  async getReserveProofWallet(message) {
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      return new Promise(function(resolve, reject) {
	        that._module.get_reserve_proof_wallet(that._cppAddress, message, function(signature) {
	          let errorKey = "error: ";
	          if (signature.indexOf(errorKey) === 0) reject(new MoneroError(signature.substring(errorKey.length), -1));
	          else resolve(signature);
	        });
	      });
	    });
	  }
	  
	  async getReserveProofAccount(accountIdx, amount, message) {
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      return new Promise(function(resolve, reject) {
	        that._module.get_reserve_proof_account(that._cppAddress, accountIdx, amount.toString(), message, function(signature) {
	          let errorKey = "error: ";
	          if (signature.indexOf(errorKey) === 0) reject(new MoneroError(signature.substring(errorKey.length), -1));
	          else resolve(signature);
	        });
	      });
	    });
	  }

	  async checkReserveProof(address, message, signature) {
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed(); 
	      return new Promise(function(resolve, reject) {
	        that._module.check_reserve_proof(that._cppAddress, address, message, signature, function(respJsonStr) {
	          if (respJsonStr.charAt(0) !== "{") reject(new MoneroError(respJsonStr, -1));
	          else resolve(new MoneroCheckReserve(JSON.parse(GenUtils.stringifyBIs(respJsonStr))));
	        });
	      });
	    });
	  }
	  
	  async getTxNotes(txHashes) {
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      try { return JSON.parse(that._module.get_tx_notes(that._cppAddress, JSON.stringify({txHashes: txHashes}))).txNotes; }
	      catch (err) { throw new MoneroError(that._module.get_exception_message(err)); }
	    });
	  }
	  
	  async setTxNotes(txHashes, notes) {
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      try { that._module.set_tx_notes(that._cppAddress, JSON.stringify({txHashes: txHashes, txNotes: notes})); }
	      catch (err) { throw new MoneroError(that._module.get_exception_message(err)); }
	    });
	  }
	  
	  async getAddressBookEntries(entryIndices) {
	    if (!entryIndices) entryIndices = [];
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      let entries = [];
	      for (let entryJson of JSON.parse(that._module.get_address_book_entries(that._cppAddress, JSON.stringify({entryIndices: entryIndices}))).entries) {
	        entries.push(new MoneroAddressBookEntry(entryJson));
	      }
	      return entries;
	    });
	  }
	  
	  async addAddressBookEntry(address, description) {
	    if (!address) address = "";
	    if (!description) description = "";
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      return that._module.add_address_book_entry(that._cppAddress, address, description);
	    });
	  }
	  
	  async editAddressBookEntry(index, setAddress, address, setDescription, description) {
	    if (!setAddress) setAddress = false;
	    if (!address) address = "";
	    if (!setDescription) setDescription = false;
	    if (!description) description = "";
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      that._module.edit_address_book_entry(that._cppAddress, index, setAddress, address, setDescription, description);
	    });
	  }
	  
	  async deleteAddressBookEntry(entryIdx) {
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      that._module.delete_address_book_entry(that._cppAddress, entryIdx);
	    });
	  }
	  
	  async tagAccounts(tag, accountIndices) {
	    if (!tag) tag = "";
	    if (!accountIndices) accountIndices = [];
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      that._module.tag_accounts(that._cppAddress, JSON.stringify({tag: tag, accountIndices: accountIndices}));
	    });
	  }

	  async untagAccounts(accountIndices) {
	    if (!accountIndices) accountIndices = [];
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      that._module.tag_accounts(that._cppAddress, JSON.stringify({accountIndices: accountIndices}));
	    });
	  }
	  
	  async getAccountTags() {
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      let accountTags = [];
	      for (let accountTagJson of JSON.parse(that._module.get_account_tags(that._cppAddress)).accountTags) accountTags.push(new MoneroAccountTag(accountTagJson));
	      return accountTags;
	    });
	  }

	  async setAccountTagLabel(tag, label) {
	    if (!tag) tag = "";
	    if (!llabel) label = "";
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      that._module.set_account_tag_label(that._cppAddress, tag, label);
	    });
	  }
	  
	  async getPaymentUri(config) {
	    config = MoneroWallet._normalizeCreateTxsConfig(config);
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      try {
	        return that._module.get_payment_uri(that._cppAddress, JSON.stringify(config.toJson()));
	      } catch (err) {
	        throw new MoneroError("Cannot make URI from supplied parameters");
	      }
	    });
	  }
	  
	  async parsePaymentUri(uri) {
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      try {
	        return new MoneroTxConfig(JSON.parse(GenUtils.stringifyBIs(that._module.parse_payment_uri(that._cppAddress, uri))), true); // relax validation for unquoted big integers
	      } catch (err) {
	        throw new MoneroError(err.message);
	      }
	    });
	  }
	  
	  async getAttribute(key) {
	    this._assertNotClosed();
	    assert(typeof key === "string", "Attribute key must be a string");
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      let value = that._module.get_attribute(that._cppAddress, key);
	      return value === "" ? null : value;
	    });
	  }
	  
	  async setAttribute(key, val) {
	    this._assertNotClosed();
	    assert(typeof key === "string", "Attribute key must be a string");
	    assert(typeof val === "string", "Attribute value must be a string");
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      that._module.set_attribute(that._cppAddress, key, val);
	    });
	  }
	  
	  async startMining(numThreads, backgroundMining, ignoreBattery) {
	    this._assertNotClosed();
	    let daemon = new MoneroDaemonRpc(Object.assign((await this.getDaemonConnection()).getConfig(), {proxyToWorker: false}));
	    await daemon.startMining(await this.getPrimaryAddress(), numThreads, backgroundMining, ignoreBattery);
	  }
	  
	  async stopMining() {
	    this._assertNotClosed();
	    let daemon = new MoneroDaemonRpc(Object.assign((await this.getDaemonConnection()).getConfig(), {proxyToWorker: false}));
	    await daemon.stopMining();
	  }
	  
	  async isMultisigImportNeeded() {
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      return that._module.is_multisig_import_needed(that._cppAddress);
	    });
	  }
	  
	  async isMultisig() {
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      return that._module.is_multisig(that._cppAddress);
	    });
	  }
	  
	  async getMultisigInfo() {
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      return new MoneroMultisigInfo(JSON.parse(that._module.get_multisig_info(that._cppAddress)));
	    });
	  }
	  
	  async prepareMultisig() {
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      return that._module.prepare_multisig(that._cppAddress);
	    });
	  }
	  
	  async makeMultisig(multisigHexes, threshold, password) {
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      return new Promise(function(resolve, reject) {
	        that._module.make_multisig(that._cppAddress, JSON.stringify({multisigHexes: multisigHexes, threshold: threshold, password: password}), (resp) => {
	          let errorKey = "error: ";
	          if (resp.indexOf(errorKey) === 0) reject(new MoneroError(resp.substring(errorKey.length)));
	          else resolve(resp);
	        });
	      });
	    });
	  }
	  
	  async exchangeMultisigKeys(multisigHexes, password) {
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      return new Promise(function(resolve, reject) {
	        that._module.exchange_multisig_keys(that._cppAddress, JSON.stringify({multisigHexes: multisigHexes, password: password}), (resp) => {
	          let errorKey = "error: ";
	          if (resp.indexOf(errorKey) === 0) reject(new MoneroError(resp.substring(errorKey.length)));
	          else resolve(new MoneroMultisigInitResult(JSON.parse(resp)));
	        });
	      });
	    });
	  }
	  
	  async exportMultisigHex() {
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      return that._module.export_multisig_hex(that._cppAddress);
	    });
	  }
	  
	  async importMultisigHex(multisigHexes) {
	    if (!GenUtils.isArray(multisigHexes)) throw new MoneroError("Must provide string[] to importMultisigHex()")
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      return new Promise(function(resolve, reject) {
	        let callbackFn = function(resp) {
	          if (typeof resp === "string") reject(new MoneroError(resp));
	          else resolve(resp);
	        };
	        that._module.import_multisig_hex(that._cppAddress, JSON.stringify({multisigHexes: multisigHexes}), callbackFn);
	      });
	    });
	  }
	  
	  async signMultisigTxHex(multisigTxHex) {
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      return new Promise(function(resolve, reject) {
	        let callbackFn = async function(resp) {
	          if (resp.charAt(0) !== "{") reject(new MoneroError(resp));
	          else resolve(new MoneroMultisigSignResult(JSON.parse(resp)));
	        };
	        that._module.sign_multisig_tx_hex(that._cppAddress, multisigTxHex, callbackFn);
	      });
	    });
	  }
	  
	  async submitMultisigTxHex(signedMultisigTxHex) {
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      return new Promise(function(resolve, reject) {
	        let callbackFn = function(resp) { resolve(JSON.parse(resp).txHashes); };
	        that._module.submit_multisig_tx_hex(that._cppAddress, signedMultisigTxHex, callbackFn);
	      });
	    });
	  }
	  
	  /**
	   * Get the wallet's keys and cache data.
	   * 
	   * @return {DataView[]} is the keys and cache data respectively
	   */
	  async getData() {
	    this._assertNotClosed();
	    
	    // queue call to wasm module
	    let viewOnly = await this.isViewOnly();
	    let that = this;
	    return that._module.queueTask(async function() {
	      that._assertNotClosed();
	      
	      // store views in array
	      let views = [];
	      
	      // malloc cache buffer and get buffer location in c++ heap
	      let cacheBufferLoc = JSON.parse(that._module.get_cache_file_buffer(that._cppAddress, that._password));
	      
	      // read binary data from heap to DataView
	      let view = new DataView(new ArrayBuffer(cacheBufferLoc.length));
	      for (let i = 0; i < cacheBufferLoc.length; i++) {
	        view.setInt8(i, that._module.HEAPU8[cacheBufferLoc.pointer / Uint8Array.BYTES_PER_ELEMENT + i]);
	      }
	      
	      // free binary on heap
	      that._module._free(cacheBufferLoc.pointer);
	      
	      // write cache file
	      views.push(Buffer.from(view.buffer));
	      
	      // malloc keys buffer and get buffer location in c++ heap
	      let keysBufferLoc = JSON.parse(that._module.get_keys_file_buffer(that._cppAddress, that._password, viewOnly));
	      
	      // read binary data from heap to DataView
	      view = new DataView(new ArrayBuffer(keysBufferLoc.length));
	      for (let i = 0; i < keysBufferLoc.length; i++) {
	        view.setInt8(i, that._module.HEAPU8[keysBufferLoc.pointer / Uint8Array.BYTES_PER_ELEMENT + i]);
	      }
	      
	      // free binary on heap
	      that._module._free(keysBufferLoc.pointer);
	      
	      // prepend keys file
	      views.unshift(Buffer.from(view.buffer));
	      return views;
	    });
	  }
	  
	  async changePassword(oldPassword, newPassword) {
	    if (oldPassword !== this._password) throw new MoneroError("Invalid original password."); // wallet2 verify_password loads from disk so verify password here
	    let that = this;
	    await that._module.queueTask(async function() {
	      that._assertNotClosed();
	      return new Promise(function(resolve, reject) {
	        that._module.change_wallet_password(that._cppAddress, oldPassword, newPassword, async function(errMsg) {
	          if (errMsg) reject(new MoneroError(errMsg));
	          else resolve();
	        });
	      });
	    });
	    this._password = newPassword;
	    if (this._path) await this.save(); // auto save
	  }
	  
	  async save() {
	    return MoneroWalletFull._save(this);
	  }
	  
	  async close(save) {
	    if (this._isClosed) return; // no effect if closed
	    await this._refreshListening();
	    await this.stopSyncing();
	    await super.close(save);
	    delete this._path;
	    delete this._password;
	    delete this._listeners;
	    delete this._fullListener;
	    LibraryUtils.setRejectUnauthorizedFn(this._rejectUnauthorizedConfigId, undefined); // unregister fn informing if unauthorized reqs should be rejected
	  }
	  
	  // ----------- ADD JSDOC FOR SUPPORTED DEFAULT IMPLEMENTATIONS --------------
	  
	  async getNumBlocksToUnlock() { return super.getNumBlocksToUnlock(...arguments); }
	  async getTx() { return super.getTx(...arguments); }
	  async getIncomingTransfers() { return super.getIncomingTransfers(...arguments); }
	  async getOutgoingTransfers() { return super.getOutgoingTransfers(...arguments); }
	  async createTx() { return super.createTx(...arguments); }
	  async relayTx() { return super.relayTx(...arguments); }
	  async getTxNote() { return super.getTxNote(...arguments); }
	  async setTxNote() { return super.setTxNote(...arguments); }
	  
	  // ---------------------------- PRIVATE HELPERS ----------------------------
	  
	  static _getFs() {
	    if (!MoneroWalletFull.FS) MoneroWalletFull.FS = GenUtils.isBrowser() ? undefined : require$$1$1;
	    return MoneroWalletFull.FS;
	  }
	  
	  static async _openWalletData(path, password, networkType, keysData, cacheData, daemonUriOrConnection, proxyToWorker, fs) {
	    if (proxyToWorker) return MoneroWalletFullProxy.openWalletData(path, password, networkType, keysData, cacheData, daemonUriOrConnection, fs);
	    
	    // validate and normalize parameters
	    assert(password, "Must provide a password to open the wallet");
	    if (networkType === undefined) throw new MoneroError("Must provide the wallet's network type");
	    MoneroNetworkType.validate(networkType);
	    let daemonConnection = typeof daemonUriOrConnection === "string" ? new MoneroRpcConnection(daemonUriOrConnection) : daemonUriOrConnection;
	    let daemonUri = daemonConnection && daemonConnection.getUri() ? daemonConnection.getUri() : "";
	    let daemonUsername = daemonConnection && daemonConnection.getUsername() ? daemonConnection.getUsername() : "";
	    let daemonPassword = daemonConnection && daemonConnection.getPassword() ? daemonConnection.getPassword() : "";
	    let rejectUnauthorized = daemonConnection ? daemonConnection.getRejectUnauthorized() : true;
	    
	    // load wasm module
	    let module = await LibraryUtils.loadFullModule();
	    
	    // open wallet in queue
	    return module.queueTask(async function() {
	      return new Promise(function(resolve, reject) {
	        
	        // register fn informing if unauthorized reqs should be rejected
	        let rejectUnauthorizedFnId = GenUtils.getUUID();
	        LibraryUtils.setRejectUnauthorizedFn(rejectUnauthorizedFnId, function() { return rejectUnauthorized });
	      
	        // define callback for wasm
	        let callbackFn = async function(cppAddress) {
	          if (typeof cppAddress === "string") reject(new MoneroError(cppAddress));
	          else resolve(new MoneroWalletFull(cppAddress, path, password, fs, rejectUnauthorized, rejectUnauthorizedFnId));
	        };
	        
	        // create wallet in wasm and invoke callback when done
	        module.open_wallet_full(password, networkType, keysData, cacheData, daemonUri, daemonUsername, daemonPassword, rejectUnauthorizedFnId, callbackFn);
	      });
	    });
	  }
	  
	  async _backgroundSync() {
	    let label = this._path ? this._path : (this._browserMainPath ? this._browserMainPath : "in-memory wallet"); // label for log
	    LibraryUtils.log(1, "Background synchronizing " + label);
	    try { await this.sync(); }
	    catch (err) { if (!this._isClosed) console.error("Failed to background synchronize " + label + ": " + err.message); }
	  }
	  
	  async _refreshListening() {
	    let isEnabled = this._listeners.length > 0;
	    let that = this;
	    if (that._fullListenerHandle === 0 && !isEnabled || that._fullListenerHandle > 0 && isEnabled) return; // no difference
	    return that._module.queueTask(async function() {
	      return new Promise(function(resolve, reject) {
	        that._module.set_listener(
	            that._cppAddress,
	            that._fullListenerHandle,
	            newListenerHandle => {
	              if (typeof newListenerHandle === "string") reject(new MoneroError(newListenerHandle));
	              else {
	                that._fullListenerHandle = newListenerHandle;
	                resolve();
	              }
	            },
	            isEnabled ? async function(height, startHeight, endHeight, percentDone, message) { await that._fullListener.onSyncProgress(height, startHeight, endHeight, percentDone, message); } : undefined,
	            isEnabled ? async function(height) { await that._fullListener.onNewBlock(height); } : undefined,
	            isEnabled ? async function(newBalanceStr, newUnlockedBalanceStr) { await that._fullListener.onBalancesChanged(newBalanceStr, newUnlockedBalanceStr); } : undefined,
	            isEnabled ? async function(height, txHash, amountStr, accountIdx, subaddressIdx, version, unlockHeight, isLocked) { await that._fullListener.onOutputReceived(height, txHash, amountStr, accountIdx, subaddressIdx, version, unlockHeight, isLocked); } : undefined,
	            isEnabled ? async function(height, txHash, amountStr, accountIdxStr, subaddressIdxStr, version, unlockHeight, isLocked) { await that._fullListener.onOutputSpent(height, txHash, amountStr, accountIdxStr, subaddressIdxStr, version, unlockHeight, isLocked); } : undefined,
	        );
	      });
	    });
	  }
	  
	  static _sanitizeBlock(block) {
	    for (let tx of block.getTxs()) MoneroWalletFull._sanitizeTxWallet(tx);
	    return block;
	  }
	  
	  static _sanitizeTxWallet(tx) {
	    assert(tx instanceof MoneroTxWallet);
	    return tx;
	  }
	  
	  static _sanitizeAccount(account) {
	    if (account.getSubaddresses()) {
	      for (let subaddress of account.getSubaddresses()) MoneroWalletFull._sanitizeSubaddress(subaddress);
	    }
	    return account;
	  }
	  
	  static _sanitizeSubaddress(subaddress) {
	    if (subaddress.getLabel() === "") subaddress.setLabel(undefined);
	    return subaddress
	  }
	  
	  static _deserializeBlocks(blocksJsonStr) {
	    let blocksJson = JSON.parse(GenUtils.stringifyBIs(blocksJsonStr));
	    let deserializedBlocks = {};
	    deserializedBlocks.blocks = [];
	    deserializedBlocks.missingTxHashes = [];
	    if (blocksJson.blocks) for (let blockJson of blocksJson.blocks) deserializedBlocks.blocks.push(MoneroWalletFull._sanitizeBlock(new MoneroBlock(blockJson, MoneroBlock.DeserializationType.TX_WALLET)));
	    if (blocksJson.missingTxHashes) for (let missingTxHash of blocksJson.missingTxHashes) deserializedBlocks.missingTxHashes.push(missingTxHash);
	    return deserializedBlocks;
	  }
	  
	  static _deserializeTxs(query, blocksJsonStr, missingTxHashes) {
	    
	    // deserialize blocks
	    let deserializedBlocks = MoneroWalletFull._deserializeBlocks(blocksJsonStr);
	    if (missingTxHashes === undefined && deserializedBlocks.missingTxHashes.length > 0) throw new MoneroError("Wallet missing requested tx hashes: " + deserializedBlocks.missingTxHashes);
	    for (let missingTxHash of deserializedBlocks.missingTxHashes) missingTxHashes.push(missingTxHash);
	    let blocks = deserializedBlocks.blocks;
	    
	    // collect txs
	    let txs = [];
	    for (let block of blocks) {
	      MoneroWalletFull._sanitizeBlock(block);
	      for (let tx of block.getTxs()) {
	        if (block.getHeight() === undefined) tx.setBlock(undefined); // dereference placeholder block for unconfirmed txs
	        txs.push(tx);
	      }
	    }
	    
	    // re-sort txs which is lost over wasm serialization  // TODO: confirm that order is lost
	    if (query.getHashes() !== undefined) {
	      let txMap = new Map();
	      for (let tx of txs) txMap[tx.getHash()] = tx;
	      let txsSorted = [];
	      for (let txHash of query.getHashes()) if (txMap[txHash] !== undefined) txsSorted.push(txMap[txHash]);
	      txs = txsSorted;
	    }
	    
	    return txs;
	  }
	  
	  static _deserializeTransfers(query, blocksJsonStr) {
	    
	    // deserialize blocks
	    let deserializedBlocks = MoneroWalletFull._deserializeBlocks(blocksJsonStr);
	    if (deserializedBlocks.missingTxHashes.length > 0) throw new MoneroError("Wallet missing requested tx hashes: " + deserializedBlocks.missingTxHashes);
	    let blocks = deserializedBlocks.blocks;
	    
	    // collect transfers
	    let transfers = [];
	    for (let block of blocks) {
	      for (let tx of block.getTxs()) {
	        if (block.getHeight() === undefined) tx.setBlock(undefined); // dereference placeholder block for unconfirmed txs
	        if (tx.getOutgoingTransfer() !== undefined) transfers.push(tx.getOutgoingTransfer());
	        if (tx.getIncomingTransfers() !== undefined) {
	          for (let transfer of tx.getIncomingTransfers()) transfers.push(transfer);
	        }
	      }
	    }
	    
	    return transfers;
	  }
	  
	  static _deserializeOutputs(query, blocksJsonStr) {
	    
	    // deserialize blocks
	    let deserializedBlocks = MoneroWalletFull._deserializeBlocks(blocksJsonStr);
	    if (deserializedBlocks.missingTxHashes.length > 0) throw new MoneroError("Wallet missing requested tx hashes: " + deserializedBlocks.missingTxHashes);
	    let blocks = deserializedBlocks.blocks;
	    
	    // collect outputs
	    let outputs = [];
	    for (let block of blocks) {
	      for (let tx of block.getTxs()) {
	        for (let output of tx.getOutputs()) outputs.push(output);
	      }
	    }
	    
	    return outputs;
	  }
	  
	  /**
	   * Set the path of the wallet on the browser main thread if run as a worker.
	   * 
	   * @param {string} browserMainPath - path of the wallet on the browser main thread
	   */
	  _setBrowserMainPath(browserMainPath) {
	    this._browserMainPath = browserMainPath;
	  }
	  
	  static async _moveTo(path, wallet) {
	    if (await wallet.isClosed()) throw new MoneroError("Wallet is closed");
	    if (!path) throw new MoneroError("Must provide path of destination wallet");
	    
	    // save and return if same path
	    const Path = require$$0$1;
	    if (Path.normalize(wallet._path) === Path.normalize(path)) {
	      await wallet.save();
	      return;
	    }
	    
	    // create destination directory if it doesn't exist
	    let walletDir = Path.dirname(path);
	    if (!wallet._fs.existsSync(walletDir)) {
	      try { wallet._fs.mkdirSync(walletDir); }
	      catch (err) { throw new MoneroError("Destination path " + path + " does not exist and cannot be created: " + err.message); }
	    }
	    
	    // write wallet files
	    let data = await wallet.getData();
	    wallet._fs.writeFileSync(path + ".keys", data[0], "binary");
	    wallet._fs.writeFileSync(path, data[1], "binary");
	    wallet._fs.writeFileSync(path + ".address.txt", await wallet.getPrimaryAddress());
	    let oldPath = wallet._path;
	    wallet._path = path;
	    
	    // delete old wallet files
	    if (oldPath) {
	      wallet._fs.unlinkSync(oldPath + ".address.txt");
	      wallet._fs.unlinkSync(oldPath + ".keys");
	      wallet._fs.unlinkSync(oldPath);
	    }
	  }
	  
	  static async _save(wallet) {
	    if (await wallet.isClosed()) throw new MoneroError("Wallet is closed");
	        
	    // path must be set
	    let path = await wallet.getPath();
	    if (!path) throw new MoneroError("Cannot save wallet because path is not set");
	    
	    // write wallet files to *.new
	    let pathNew = path + ".new";
	    let data = await wallet.getData();
	    wallet._fs.writeFileSync(pathNew + ".keys", data[0], "binary");
	    wallet._fs.writeFileSync(pathNew, data[1], "binary");
	    wallet._fs.writeFileSync(pathNew + ".address.txt", await wallet.getPrimaryAddress());
	    
	    // replace old wallet files with new
	    wallet._fs.renameSync(pathNew + ".keys", path + ".keys");
	    wallet._fs.renameSync(pathNew, path, path + ".keys");
	    wallet._fs.renameSync(pathNew + ".address.txt", path + ".address.txt", path + ".keys");
	  }
	}

	/**
	 * Implements a MoneroWallet by proxying requests to a worker which runs a full wallet.
	 * 
	 * TODO: sort these methods according to master sort in MoneroWallet.js
	 * TODO: probably only allow one listener to worker then propogate to registered listeners for performance
	 * TODO: ability to recycle worker for use in another wallet
	 * TODO: using LibraryUtils.WORKER_OBJECTS directly breaks encapsulation
	 * 
	 * @private
	 */
	class MoneroWalletFullProxy extends MoneroWallet {
	  
	  // -------------------------- WALLET STATIC UTILS ---------------------------
	  
	  static async openWalletData(path, password, networkType, keysData, cacheData, daemonUriOrConnection, fs) {
	    let walletId = GenUtils.getUUID();
	    let daemonUriOrConfig = daemonUriOrConnection instanceof MoneroRpcConnection ? daemonUriOrConnection.getConfig() : daemonUriOrConnection;
	    await LibraryUtils.invokeWorker(walletId, "openWalletData", [path, password, networkType, keysData, cacheData, daemonUriOrConfig]);
	    let wallet = new MoneroWalletFullProxy(walletId, await LibraryUtils.getWorker(), path, fs);
	    if (path) await wallet.save();
	    return wallet;
	  }
	  
	  static async _createWallet(config) {
	    if (config.getPath() && MoneroWalletFull.walletExists(config.getPath(), config.getFs())) throw new MoneroError("Wallet already exists: " + path);
	    let walletId = GenUtils.getUUID();
	    await LibraryUtils.invokeWorker(walletId, "_createWallet", [config.toJson()]);
	    let wallet = new MoneroWalletFullProxy(walletId, await LibraryUtils.getWorker(), config.getPath(), config.getFs());
	    if (config.getPath()) await wallet.save();
	    return wallet;
	  }
	  
	  // --------------------------- INSTANCE METHODS ----------------------------
	  
	  /**
	   * Internal constructor which is given a worker to communicate with via messages.
	   * 
	   * This method should not be called externally but should be called through
	   * static wallet creation utilities in this class.
	   * 
	   * @param {string} walletId - identifies the wallet with the worker
	   * @param {Worker} worker - worker to communicate with via messages
	   */
	  constructor(walletId, worker, path, fs) {
	    super();
	    this._walletId = walletId;
	    this._worker = worker;
	    this._path = path;
	    this._fs = fs ? fs : (path ? MoneroWalletFull._getFs() : undefined);
	    this._wrappedListeners = [];
	  }
	  
	  async isViewOnly() {
	    return this._invokeWorker("isViewOnly");
	  }
	  
	  async getNetworkType() {
	    return this._invokeWorker("getNetworkType");
	  }
	  
	  async getVersion() {
	    throw new MoneroError("Not implemented");
	  }
	  
	  getPath() {
	    return this._path;
	  }
	  
	  async getMnemonic() {
	    return this._invokeWorker("getMnemonic");
	  }
	  
	  async getMnemonicLanguage() {
	    return this._invokeWorker("getMnemonicLanguage");
	  }
	  
	  async getMnemonicLanguages() {
	    return this._invokeWorker("getMnemonicLanguages");
	  }
	  
	  async getPrivateSpendKey() {
	    return this._invokeWorker("getPrivateSpendKey");
	  }
	  
	  async getPrivateViewKey() {
	    return this._invokeWorker("getPrivateViewKey");
	  }
	  
	  async getPublicViewKey() {
	    return this._invokeWorker("getPublicViewKey");
	  }
	  
	  async getPublicSpendKey() {
	    return this._invokeWorker("getPublicSpendKey");
	  }
	  
	  async getAddress(accountIdx, subaddressIdx) {
	    return this._invokeWorker("getAddress", Array.from(arguments));
	  }
	  
	  async getAddressIndex(address) {
	    let subaddressJson = await this._invokeWorker("getAddressIndex", Array.from(arguments));
	    return MoneroWalletFull._sanitizeSubaddress(new MoneroSubaddress(subaddressJson));
	  }
	  
	  async getIntegratedAddress(standardAddress, paymentId) {
	    return new MoneroIntegratedAddress(await this._invokeWorker("getIntegratedAddress", Array.from(arguments)));
	  }
	  
	  async decodeIntegratedAddress(integratedAddress) {
	    return new MoneroIntegratedAddress(await this._invokeWorker("decodeIntegratedAddress", Array.from(arguments)));
	  }
	  
	  async setDaemonConnection(uriOrRpcConnection) {
	    if (!uriOrRpcConnection) await this._invokeWorker("setDaemonConnection");
	    else {
	      let connection = !uriOrRpcConnection ? undefined : uriOrRpcConnection instanceof MoneroRpcConnection ? uriOrRpcConnection : new MoneroRpcConnection(uriOrRpcConnection);
	      await this._invokeWorker("setDaemonConnection", connection ? connection.getConfig() : undefined);
	    }
	  }
	  
	  async getDaemonConnection() {
	    let rpcConfig = await this._invokeWorker("getDaemonConnection");
	    return rpcConfig ? new MoneroRpcConnection(rpcConfig) : undefined;
	  }
	  
	  async isConnectedToDaemon() {
	    return this._invokeWorker("isConnectedToDaemon");
	  }
	  
	  async getSyncHeight() {
	    return this._invokeWorker("getSyncHeight");
	  }
	  
	  async setSyncHeight(syncHeight) {
	    return this._invokeWorker("setSyncHeight", [syncHeight]);
	  }
	  
	  async getDaemonHeight() {
	    return this._invokeWorker("getDaemonHeight");
	  }
	  
	  async getDaemonMaxPeerHeight() {
	    return this._invokeWorker("getDaemonMaxPeerHeight");
	  }
	  
	  async getHeightByDate(year, month, day) {
	    return this._invokeWorker("getHeightByDate", [year, month, day]);
	  }
	  
	  async isDaemonSynced() {
	    return this._invokeWorker("isDaemonSynced");
	  }
	  
	  async getHeight() {
	    return this._invokeWorker("getHeight");
	  }
	  
	  async addListener(listener) {
	    let wrappedListener = new WalletWorkerListener(listener);
	    let listenerId = wrappedListener.getId();
	    LibraryUtils.WORKER_OBJECTS[this._walletId].callbacks["onSyncProgress_" + listenerId] = [wrappedListener.onSyncProgress, wrappedListener];
	    LibraryUtils.WORKER_OBJECTS[this._walletId].callbacks["onNewBlock_" + listenerId] = [wrappedListener.onNewBlock, wrappedListener];
	    LibraryUtils.WORKER_OBJECTS[this._walletId].callbacks["onBalancesChanged_" + listenerId] = [wrappedListener.onBalancesChanged, wrappedListener];
	    LibraryUtils.WORKER_OBJECTS[this._walletId].callbacks["onOutputReceived_" + listenerId] = [wrappedListener.onOutputReceived, wrappedListener];
	    LibraryUtils.WORKER_OBJECTS[this._walletId].callbacks["onOutputSpent_" + listenerId] = [wrappedListener.onOutputSpent, wrappedListener];
	    this._wrappedListeners.push(wrappedListener);
	    return this._invokeWorker("addListener", [listenerId]);
	  }
	  
	  async removeListener(listener) {
	    for (let i = 0; i < this._wrappedListeners.length; i++) {
	      if (this._wrappedListeners[i].getListener() === listener) {
	        let listenerId = this._wrappedListeners[i].getId();
	        await this._invokeWorker("removeListener", [listenerId]);
	        delete LibraryUtils.WORKER_OBJECTS[this._walletId].callbacks["onSyncProgress_" + listenerId];
	        delete LibraryUtils.WORKER_OBJECTS[this._walletId].callbacks["onNewBlock_" + listenerId];
	        delete LibraryUtils.WORKER_OBJECTS[this._walletId].callbacks["onBalancesChanged_" + listenerId];
	        delete LibraryUtils.WORKER_OBJECTS[this._walletId].callbacks["onOutputReceived_" + listenerId];
	        delete LibraryUtils.WORKER_OBJECTS[this._walletId].callbacks["onOutputSpent_" + listenerId];
	        this._wrappedListeners.splice(i, 1);
	        return;
	      }
	    }
	    throw new MoneroError("Listener is not registered with wallet");
	  }
	  
	  getListeners() {
	    let listeners = [];
	    for (let wrappedListener of this._wrappedListeners) listeners.push(wrappedListener.getListener());
	    return listeners;
	  }
	  
	  async isSynced() {
	    return this._invokeWorker("isSynced");
	  }
	  
	  async sync(listenerOrStartHeight, startHeight, allowConcurrentCalls) {
	    
	    // normalize params
	    startHeight = listenerOrStartHeight instanceof MoneroWalletListener ? startHeight : listenerOrStartHeight;
	    let listener = listenerOrStartHeight instanceof MoneroWalletListener ? listenerOrStartHeight : undefined;
	    if (startHeight === undefined) startHeight = Math.max(await this.getHeight(), await this.getSyncHeight());
	    
	    // register listener if given
	    if (listener) await this.addListener(listener);
	    
	    // sync wallet in worker 
	    let err;
	    let result;
	    try {
	      let resultJson = await this._invokeWorker("sync", [startHeight, allowConcurrentCalls]);
	      result = new MoneroSyncResult(resultJson.numBlocksFetched, resultJson.receivedMoney);
	    } catch (e) {
	      err = e;
	    }
	    
	    // unregister listener
	    if (listener) await this.removeListener(listener);
	    
	    // throw error or return
	    if (err) throw err;
	    return result;
	  }
	  
	  async startSyncing(syncPeriodInMs) {
	    return this._invokeWorker("startSyncing", Array.from(arguments));
	  }
	    
	  async stopSyncing() {
	    return this._invokeWorker("stopSyncing");
	  }
	  
	  async scanTxs(txHashes) {
	    assert(Array.isArray(txHashes), "Must provide an array of txs hashes to scan");
	    return this._invokeWorker("scanTxs", [txHashes]);
	  }
	  
	  async rescanSpent() {
	    return this._invokeWorker("rescanSpent");
	  }
	    
	  async rescanBlockchain() {
	    return this._invokeWorker("rescanBlockchain");
	  }
	  
	  async getBalance(accountIdx, subaddressIdx) {
	    return BigInteger.parse(await this._invokeWorker("getBalance", Array.from(arguments)));
	  }
	  
	  async getUnlockedBalance(accountIdx, subaddressIdx) {
	    let unlockedBalanceStr = await this._invokeWorker("getUnlockedBalance", Array.from(arguments));
	    return BigInteger.parse(unlockedBalanceStr);
	  }
	  
	  async getAccounts(includeSubaddresses, tag) {
	    let accounts = [];
	    for (let accountJson of (await this._invokeWorker("getAccounts", Array.from(arguments)))) {
	      accounts.push(MoneroWalletFull._sanitizeAccount(new MoneroAccount(accountJson)));
	    }
	    return accounts;
	  }
	  
	  async getAccount(accountIdx, includeSubaddresses) {
	    let accountJson = await this._invokeWorker("getAccount", Array.from(arguments));
	    return MoneroWalletFull._sanitizeAccount(new MoneroAccount(accountJson));
	  }
	  
	  async createAccount(label) {
	    let accountJson = await this._invokeWorker("createAccount", Array.from(arguments));
	    return MoneroWalletFull._sanitizeAccount(new MoneroAccount(accountJson));
	  }
	  
	  async getSubaddresses(accountIdx, subaddressIndices) {
	    let subaddresses = [];
	    for (let subaddressJson of (await this._invokeWorker("getSubaddresses", Array.from(arguments)))) {
	      subaddresses.push(MoneroWalletFull._sanitizeSubaddress(new MoneroSubaddress(subaddressJson)));
	    }
	    return subaddresses;
	  }
	  
	  async createSubaddress(accountIdx, label) {
	    let subaddressJson = await this._invokeWorker("createSubaddress", Array.from(arguments));
	    return MoneroWalletFull._sanitizeSubaddress(new MoneroSubaddress(subaddressJson));
	  }
	  
	  async getTxs(query, missingTxHashes) {
	    query = MoneroWallet._normalizeTxQuery(query);
	    let respJson = await this._invokeWorker("getTxs", [query.getBlock().toJson(), missingTxHashes]);
	    return MoneroWalletFull._deserializeTxs(query, JSON.stringify({blocks: respJson.blocks, missingTxHashes: respJson.missingTxHashes}), missingTxHashes); // initialize txs from blocks json string TODO: this stringifies then utility parses, avoid
	  }
	  
	  async getTransfers(query) {
	    query = MoneroWallet._normalizeTransferQuery(query);
	    let blockJsons = await this._invokeWorker("getTransfers", [query.getTxQuery().getBlock().toJson()]);
	    return MoneroWalletFull._deserializeTransfers(query, JSON.stringify({blocks: blockJsons})); // initialize transfers from blocks json string TODO: this stringifies then utility parses, avoid
	  }
	  
	  async getOutputs(query) {
	    query = MoneroWallet._normalizeOutputQuery(query);
	    let blockJsons = await this._invokeWorker("getOutputs", [query.getTxQuery().getBlock().toJson()]);
	    return MoneroWalletFull._deserializeOutputs(query, JSON.stringify({blocks: blockJsons})); // initialize transfers from blocks json string TODO: this stringifies then utility parses, avoid
	  }
	  
	  async exportOutputs(all) {
	    return this._invokeWorker("exportOutputs", [all]);
	  }
	  
	  async importOutputs(outputsHex) {
	    return this._invokeWorker("importOutputs", [outputsHex]);
	  }
	  
	  async exportKeyImages(all) {
	    let keyImages = [];
	    for (let keyImageJson of await this._invokeWorker("getKeyImages", [all])) keyImages.push(new MoneroKeyImage(keyImageJson));
	    return keyImages;
	  }
	  
	  async importKeyImages(keyImages) {
	    let keyImagesJson = [];
	    for (let keyImage of keyImages) keyImagesJson.push(keyImage.toJson());
	    return new MoneroKeyImageImportResult(await this._invokeWorker("importKeyImages", [keyImagesJson]));
	  }
	  
	  async getNewKeyImagesFromLastImport() {
	    throw new MoneroError("MoneroWalletFull.getNewKeyImagesFromLastImport() not implemented");
	  }
	  
	  async freezeOutput(keyImage) {
	    return this._invokeWorker("freezeOutput", [keyImage]);
	  }
	  
	  async thawOutput(keyImage) {
	    return this._invokeWorker("thawOutput", [keyImage]);
	  }
	  
	  async isOutputFrozen(keyImage) {
	    return this._invokeWorker("isOutputFrozen", [keyImage]);
	  }
	  
	  async createTxs(config) {
	    config = MoneroWallet._normalizeCreateTxsConfig(config);
	    let txSetJson = await this._invokeWorker("createTxs", [config.toJson()]);
	    return new MoneroTxSet(txSetJson).getTxs();
	  }
	  
	  async sweepOutput(config) {
	    config = MoneroWallet._normalizeSweepOutputConfig(config);
	    let txSetJson = await this._invokeWorker("sweepOutput", [config.toJson()]);
	    return new MoneroTxSet(txSetJson).getTxs()[0];
	  }

	  async sweepUnlocked(config) {
	    config = MoneroWallet._normalizeSweepUnlockedConfig(config);
	    let txSetsJson = await this._invokeWorker("sweepUnlocked", [config.toJson()]);
	    let txs = [];
	    for (let txSetJson of txSetsJson) for (let tx of new MoneroTxSet(txSetJson).getTxs()) txs.push(tx);
	    return txs;
	  }
	  
	  async sweepDust(relay) {
	    return new MoneroTxSet(await this._invokeWorker("sweepDust", [relay])).getTxs() || [];
	  }
	  
	  async relayTxs(txsOrMetadatas) {
	    assert(Array.isArray(txsOrMetadatas), "Must provide an array of txs or their metadata to relay");
	    let txMetadatas = [];
	    for (let txOrMetadata of txsOrMetadatas) txMetadatas.push(txOrMetadata instanceof MoneroTxWallet ? txOrMetadata.getMetadata() : txOrMetadata);
	    return this._invokeWorker("relayTxs", [txMetadatas]);
	  }
	  
	  async describeTxSet(txSet) {
	    return new MoneroTxSet(await this._invokeWorker("describeTxSet", [txSet.toJson()]));
	  }
	  
	  async signTxs(unsignedTxHex) {
	    return this._invokeWorker("signTxs", Array.from(arguments));
	  }
	  
	  async submitTxs(signedTxHex) {
	    return this._invokeWorker("submitTxs", Array.from(arguments));
	  }
	  
	  async signMessage(message, signatureType, accountIdx, subaddressIdx) {
	    return this._invokeWorker("signMessage", Array.from(arguments));
	  }
	  
	  async verifyMessage(message, address, signature) {
	    return new MoneroMessageSignatureResult(await this._invokeWorker("verifyMessage", Array.from(arguments)));
	  }
	  
	  async getTxKey(txHash) {
	    return this._invokeWorker("getTxKey", Array.from(arguments));
	  }
	  
	  async checkTxKey(txHash, txKey, address) {
	    return new MoneroCheckTx(await this._invokeWorker("checkTxKey", Array.from(arguments)));
	  }
	  
	  async getTxProof(txHash, address, message) {
	    return this._invokeWorker("getTxProof", Array.from(arguments));
	  }
	  
	  async checkTxProof(txHash, address, message, signature) {
	    return new MoneroCheckTx(await this._invokeWorker("checkTxProof", Array.from(arguments)));
	  }
	  
	  async getSpendProof(txHash, message) {
	    return this._invokeWorker("getSpendProof", Array.from(arguments));
	  }
	  
	  async checkSpendProof(txHash, message, signature) {
	    return this._invokeWorker("checkSpendProof", Array.from(arguments));
	  }
	  
	  async getReserveProofWallet(message) {
	    return this._invokeWorker("getReserveProofWallet", Array.from(arguments));
	  }
	  
	  async getReserveProofAccount(accountIdx, amount, message) {
	    try { return await this._invokeWorker("getReserveProofAccount", [accountIdx, amount.toString(), message]); }
	    catch (e) { throw new MoneroError(e.message, -1); }
	  }

	  async checkReserveProof(address, message, signature) {
	    try { return new MoneroCheckReserve(await this._invokeWorker("checkReserveProof", Array.from(arguments))); }
	    catch (e) { throw new MoneroError(e.message, -1); }
	  }
	  
	  async getTxNotes(txHashes) {
	    return this._invokeWorker("getTxNotes", Array.from(arguments));
	  }
	  
	  async setTxNotes(txHashes, notes) {
	    return this._invokeWorker("setTxNotes", Array.from(arguments));
	  }
	  
	  async getAddressBookEntries(entryIndices) {
	    if (!entryIndices) entryIndices = [];
	    let entries = [];
	    for (let entryJson of await this._invokeWorker("getAddressBookEntries", Array.from(arguments))) {
	      entries.push(new MoneroAddressBookEntry(entryJson));
	    }
	    return entries;
	  }
	  
	  async addAddressBookEntry(address, description) {
	    return this._invokeWorker("addAddressBookEntry", Array.from(arguments));
	  }
	  
	  async editAddressBookEntry(index, setAddress, address, setDescription, description) {
	    return this._invokeWorker("editAddressBookEntry", Array.from(arguments));
	  }
	  
	  async deleteAddressBookEntry(entryIdx) {
	    return this._invokeWorker("deleteAddressBookEntry", Array.from(arguments));
	  }
	  
	  async tagAccounts(tag, accountIndices) {
	    return this._invokeWorker("tagAccounts", Array.from(arguments));
	  }

	  async untagAccounts(accountIndices) {
	    return this._invokeWorker("untagAccounts", Array.from(arguments));
	  }
	  
	  async getAccountTags() {
	    return this._invokeWorker("getAccountTags", Array.from(arguments));
	  }

	  async setAccountTagLabel(tag, label) {
	    return this._invokeWorker("setAccountTagLabel", Array.from(arguments));
	  }
	  
	  async getPaymentUri(config) {
	    config = MoneroWallet._normalizeCreateTxsConfig(config);
	    return this._invokeWorker("getPaymentUri", [config.toJson()]);
	  }
	  
	  async parsePaymentUri(uri) {
	    return new MoneroTxConfig(await this._invokeWorker("parsePaymentUri", Array.from(arguments)));
	  }
	  
	  async getAttribute(key) {
	    return this._invokeWorker("getAttribute", Array.from(arguments));
	  }
	  
	  async setAttribute(key, val) {
	    return this._invokeWorker("setAttribute", Array.from(arguments));
	  }
	  
	  async startMining(numThreads, backgroundMining, ignoreBattery) {
	    return this._invokeWorker("startMining", Array.from(arguments));
	  }
	  
	  async stopMining() {
	    return this._invokeWorker("stopMining", Array.from(arguments));
	  }
	  
	  async isMultisigImportNeeded() {
	    return this._invokeWorker("isMultisigImportNeeded");
	  }
	  
	  async isMultisig() {
	    return this._invokeWorker("isMultisig");
	  }
	  
	  async getMultisigInfo() {
	    return new MoneroMultisigInfo(await this._invokeWorker("getMultisigInfo"));
	  }
	  
	  async prepareMultisig() {
	    return this._invokeWorker("prepareMultisig");
	  }
	  
	  async makeMultisig(multisigHexes, threshold, password) {
	    return await this._invokeWorker("makeMultisig", Array.from(arguments));
	  }
	  
	  async exchangeMultisigKeys(multisigHexes, password) {
	    return new MoneroMultisigInitResult(await this._invokeWorker("exchangeMultisigKeys", Array.from(arguments)));
	  }
	  
	  async exportMultisigHex() {
	    return this._invokeWorker("exportMultisigHex");
	  }
	  
	  async importMultisigHex(multisigHexes) {
	    return this._invokeWorker("importMultisigHex", Array.from(arguments));
	  }
	  
	  async signMultisigTxHex(multisigTxHex) {
	    return new MoneroMultisigSignResult(await this._invokeWorker("signMultisigTxHex", Array.from(arguments)));
	  }
	  
	  async submitMultisigTxHex(signedMultisigTxHex) {
	    return this._invokeWorker("submitMultisigTxHex", Array.from(arguments));
	  }
	  
	  async getData() {
	    return this._invokeWorker("getData");
	  }
	  
	  async moveTo(path) {
	    return MoneroWalletFull._moveTo(path, this);
	  }
	  
	  async changePassword(oldPassword, newPassword) {
	    await this._invokeWorker("changePassword", Array.from(arguments));
	    if (this._path) await this.save(); // auto save
	  }
	  
	  async save() {
	    return MoneroWalletFull._save(this);
	  }
	  
	  async close(save) {
	    if (save) await this.save();
	    while (this._wrappedListeners.length) await this.removeListener(this._wrappedListeners[0].getListener());
	    await this._invokeWorker("close");
	    delete LibraryUtils.WORKER_OBJECTS[this._walletId];
	  }
	  
	  async isClosed() {
	    return this._invokeWorker("isClosed");
	  }
	  
	  // --------------------------- PRIVATE HELPERS ------------------------------
	  
	  async _invokeWorker(fnName, args) {
	    return LibraryUtils.invokeWorker(this._walletId, fnName, args);
	  }
	}

	// -------------------------------- LISTENING ---------------------------------

	/**
	 * Receives notifications directly from wasm c++.
	 * 
	 * @private
	 */
	class WalletFullListener {
	  
	  constructor(wallet) {
	    this._wallet = wallet;
	  }
	  
	  async onSyncProgress(height, startHeight, endHeight, percentDone, message) {
	    for (let listener of this._wallet.getListeners()) await listener.onSyncProgress(height, startHeight, endHeight, percentDone, message);
	  }
	  
	  async onNewBlock(height) {
	    for (let listener of this._wallet.getListeners()) await listener.onNewBlock(height);
	  }
	  
	  async onBalancesChanged(newBalanceStr, newUnlockedBalanceStr) {
	    for (let listener of this._wallet.getListeners()) await listener.onBalancesChanged(BigInteger.parse(newBalanceStr), BigInteger.parse(newUnlockedBalanceStr));
	  }
	  
	  async onOutputReceived(height, txHash, amountStr, accountIdx, subaddressIdx, version, unlockHeight, isLocked) {
	    
	    // build received output
	    let output = new MoneroOutputWallet();
	    output.setAmount(BigInteger.parse(amountStr));
	    output.setAccountIndex(accountIdx);
	    output.setSubaddressIndex(subaddressIdx);
	    let tx = new MoneroTxWallet();
	    tx.setHash(txHash);
	    tx.setVersion(version);
	    tx.setUnlockHeight(unlockHeight);
	    output.setTx(tx);
	    tx.setOutputs([output]);
	    tx.setIsIncoming(true);
	    tx.setIsLocked(isLocked);
	    if (height > 0) {
	      let block = new MoneroBlock().setHeight(height);
	      block.setTxs([tx]);
	      tx.setBlock(block);
	      tx.setIsConfirmed(true);
	      tx.setInTxPool(false);
	      tx.setIsFailed(false);
	    } else {
	      tx.setIsConfirmed(false);
	      tx.setInTxPool(true);
	    }
	    
	    // announce output
	    for (let listener of this._wallet.getListeners()) await listener.onOutputReceived(tx.getOutputs()[0]);
	  }
	  
	  async onOutputSpent(height, txHash, amountStr, accountIdxStr, subaddressIdxStr, version, unlockHeight, isLocked) {
	    
	    // build spent output
	    let output = new MoneroOutputWallet();
	    output.setAmount(BigInteger.parse(amountStr));
	    if (accountIdxStr) output.setAccountIndex(parseInt(accountIdxStr));
	    if (subaddressIdxStr) output.setSubaddressIndex(parseInt(subaddressIdxStr));
	    let tx = new MoneroTxWallet();
	    tx.setHash(txHash);
	    tx.setVersion(version);
	    tx.setUnlockHeight(unlockHeight);
	    tx.setIsLocked(isLocked);
	    output.setTx(tx);
	    tx.setInputs([output]);
	    if (height > 0) {
	      let block = new MoneroBlock().setHeight(height);
	      block.setTxs([tx]);
	      tx.setBlock(block);
	      tx.setIsConfirmed(true);
	      tx.setInTxPool(false);
	      tx.setIsFailed(false);
	    } else {
	      tx.setIsConfirmed(false);
	      tx.setInTxPool(true);
	    }
	    
	    // notify wallet listeners
	    for (let listener of this._wallet.getListeners()) await listener.onOutputSpent(tx.getInputs()[0]);
	  }
	}

	/**
	 * Internal listener to bridge notifications to external listeners.
	 * 
	 * @private
	 */
	class WalletWorkerListener {
	  
	  constructor(listener) {
	    this._id = GenUtils.getUUID();
	    this._listener = listener;
	  }
	  
	  getId() {
	    return this._id;
	  }
	  
	  getListener() {
	    return this._listener;
	  }
	  
	  onSyncProgress(height, startHeight, endHeight, percentDone, message) {
	    this._listener.onSyncProgress(height, startHeight, endHeight, percentDone, message);
	  }

	  async onNewBlock(height) {
	    await this._listener.onNewBlock(height);
	  }
	  
	  async onBalancesChanged(newBalanceStr, newUnlockedBalanceStr) {
	    await this._listener.onBalancesChanged(BigInteger.parse(newBalanceStr), BigInteger.parse(newUnlockedBalanceStr));
	  }

	  async onOutputReceived(blockJson) {
	    let block = new MoneroBlock(blockJson, MoneroBlock.DeserializationType.TX_WALLET);
	    await this._listener.onOutputReceived(block.getTxs()[0].getOutputs()[0]);
	  }
	  
	  async onOutputSpent(blockJson) {
	    let block = new MoneroBlock(blockJson, MoneroBlock.DeserializationType.TX_WALLET);
	    await this._listener.onOutputSpent(block.getTxs()[0].getInputs()[0]);
	  }
	}

	MoneroWalletFull.DEFAULT_SYNC_PERIOD_IN_MS = 10000; // 10 second sync period by default

	MoneroWalletFull_1 = MoneroWalletFull;
	return MoneroWalletFull_1;
}

var hasRequiredMoneroJavascript;

function requireMoneroJavascript () {
	if (hasRequiredMoneroJavascript) return moneroJavascript.exports;
	hasRequiredMoneroJavascript = 1;
	(function (module) {

		/**
		 * Export all library models.
		 * 
		 * See the full model specification: http://moneroecosystem.org/monero-java/monero-spec.pdf
		 */
		module.exports = {};

		// export common models
		module.exports.GenUtils = GenUtils_1;
		module.exports.BigInteger = biginteger.BigInteger;
		module.exports.Filter = Filter_1;
		module.exports.MoneroError = MoneroError_1;
		module.exports.HttpClient = requireHttpClient();
		module.exports.LibraryUtils = requireLibraryUtils();
		module.exports.MoneroRpcConnection = requireMoneroRpcConnection();
		module.exports.MoneroRpcError = MoneroRpcError_1;
		module.exports.SslOptions = SslOptions_1;
		module.exports.TaskLooper = TaskLooper_1;

		// export daemon models
		module.exports.ConnectionType = ConnectionType_1;
		module.exports.MoneroAltChain = MoneroAltChain_1;
		module.exports.MoneroBan = MoneroBan_1;
		module.exports.MoneroBlockHeader = MoneroBlockHeader_1;
		module.exports.MoneroBlock = MoneroBlock_1;
		module.exports.MoneroBlockTemplate = MoneroBlockTemplate_1;
		module.exports.MoneroConnectionSpan = MoneroConnectionSpan_1;
		module.exports.MoneroDaemonInfo = MoneroDaemonInfo_1;
		module.exports.MoneroDaemonListener = MoneroDaemonListener_1;
		module.exports.MoneroDaemonSyncInfo = MoneroDaemonSyncInfo_1;
		module.exports.MoneroDaemonUpdateCheckResult = MoneroDaemonUpdateCheckResult_1;
		module.exports.MoneroDaemonUpdateDownloadResult = MoneroDaemonUpdateDownloadResult_1;
		module.exports.MoneroHardForkInfo = MoneroHardForkInfo_1;
		module.exports.MoneroKeyImage = MoneroKeyImage_1;
		module.exports.MoneroKeyImageSpentStatus = MoneroKeyImageSpentStatus_1;
		module.exports.MoneroMinerTxSum = MoneroMinerTxSum_1;
		module.exports.MoneroMiningStatus = MoneroMiningStatus_1;
		module.exports.MoneroNetworkType = MoneroNetworkType_1;
		module.exports.MoneroOutput = MoneroOutput_1;
		module.exports.MoneroOutputHistogramEntry = MoneroOutputHistogramEntry_1;
		module.exports.MoneroSubmitTxResult = MoneroSubmitTxResult_1;
		module.exports.MoneroTx = MoneroTx_1;
		module.exports.MoneroTxPoolStats = MoneroTxPoolStats_1;
		module.exports.MoneroVersion = MoneroVersion_1;
		module.exports.MoneroPeer = MoneroPeer_1;

		// export wallet models
		module.exports.MoneroAccount = MoneroAccount_1;
		module.exports.MoneroAccountTag = MoneroAccountTag_1;
		module.exports.MoneroAddressBookEntry = MoneroAddressBookEntry_1;
		module.exports.MoneroCheck = MoneroCheck_1;
		module.exports.MoneroCheckReserve = MoneroCheckReserve_1;
		module.exports.MoneroCheckTx = MoneroCheckTx_1;
		module.exports.MoneroDestination = MoneroDestination_1;
		module.exports.MoneroIntegratedAddress = MoneroIntegratedAddress_1;
		module.exports.MoneroKeyImageImportResult = MoneroKeyImageImportResult_1;
		module.exports.MoneroMultisigInfo = MoneroMultisigInfo_1;
		module.exports.MoneroMultisigInitResult = MoneroMultisigInitResult_1;
		module.exports.MoneroMultisigSignResult = MoneroMultisigSignResult_1;
		module.exports.MoneroOutputWallet = MoneroOutputWallet_1;
		module.exports.MoneroOutputQuery = requireMoneroOutputQuery();
		module.exports.MoneroTxPriority = MoneroTxPriority_1;
		module.exports.MoneroTxConfig = MoneroTxConfig_1;
		module.exports.MoneroSubaddress = MoneroSubaddress_1;
		module.exports.MoneroSyncResult = MoneroSyncResult_1;
		module.exports.MoneroTransfer = MoneroTransfer_1;
		module.exports.MoneroIncomingTransfer = MoneroIncomingTransfer_1;
		module.exports.MoneroOutgoingTransfer = MoneroOutgoingTransfer_1;
		module.exports.MoneroTransferQuery = requireMoneroTransferQuery();
		module.exports.MoneroTxSet = requireMoneroTxSet();
		module.exports.MoneroTxWallet = requireMoneroTxWallet();
		module.exports.MoneroTxQuery = requireMoneroTxQuery();
		module.exports.MoneroWalletListener = MoneroWalletListener_1;
		module.exports.MoneroWalletConfig = requireMoneroWalletConfig();
		module.exports.MoneroMessageSignatureType = MoneroMessageSignatureType_1;
		module.exports.MoneroMessageSignatureResult = MoneroMessageSignatureResult_1;

		// export connection manager
		module.exports.MoneroConnectionManager = requireMoneroConnectionManager();
		module.exports.MoneroConnectionManagerListener = MoneroConnectionManagerListener_1;

		// export daemon, wallet, and utils classes
		module.exports.MoneroUtils = requireMoneroUtils();
		module.exports.MoneroDaemon = MoneroDaemon_1;
		module.exports.MoneroWallet = MoneroWallet_1;
		module.exports.MoneroDaemonRpc = requireMoneroDaemonRpc();
		module.exports.MoneroWalletRpc = requireMoneroWalletRpc();
		module.exports.MoneroWalletKeys = requireMoneroWalletKeys();
		module.exports.MoneroWalletFull = requireMoneroWalletFull();

		// ---------------------------- GLOBAL FUNCTIONS ------------------------------

		/**
		 * <p>Get the version of the monero-javascript library.<p>
		 * 
		 * @return {string} the version of this monero-javascript library
		 */
		module.exports.getVersion = function() {
		    return module.exports.MoneroUtils.getVersion();
		};

		/**
		 * <p>Create a client connected to monero-daemon-rpc.<p>
		 * 
		 * <p>Examples:<p>
		 * 
		 * <code>
		 * let daemon = await monerojs.connectToDaemonRpc("http://localhost:38081", "superuser", "abctesting123");<br><br>
		 * 
		 * let daemon = await monerojs.connectToDaemonRpc({<br>
		 * &nbsp;&nbsp; uri: "http://localhost:38081",<br>
		 * &nbsp;&nbsp; username: "superuser",<br>
		 * &nbsp;&nbsp; password: "abctesting123"<br>
		 * });
		 * </code>
		 * 
		 * @param {string|object|MoneroRpcConnection} uriOrConfig - uri of monero-daemon-rpc or JS config object or MoneroRpcConnection
		 * @param {string} uriOrConfig.uri - uri of monero-daemon-rpc
		 * @param {string} uriOrConfig.username - username to authenticate with monero-daemon-rpc (optional)
		 * @param {string} uriOrConfig.password - password to authenticate with monero-daemon-rpc (optional)
		 * @param {boolean} uriOrConfig.rejectUnauthorized - rejects self-signed certificates if true (default true)
		 * @param {number} uriOrConfig.pollInterval - poll interval to query for updates in ms (default 5000)
		 * @param {boolean} uriOrConfig.proxyToWorker - run the daemon client in a web worker if true (default true)
		 * @param {string} username - username to authenticate with monero-daemon-rpc (optional)
		 * @param {string} password - password to authenticate with monero-daemon-rpc (optional)
		 * @param {boolean} rejectUnauthorized - rejects self-signed certificates if true (default true)
		 * @param {number} pollInterval - poll interval to query for updates in ms (default 5000)
		 * @param {boolean} proxyToWorker - runs the daemon client in a web worker if true (default true)
		 * @return {MoneroDaemonRpc} the daemon RPC client
		 */
		module.exports.connectToDaemonRpc = function() { return module.exports.MoneroDaemonRpc._connectToDaemonRpc(...arguments); };

		/**
		 * <p>Create a client connected to monero-wallet-rpc.</p>
		 * 
		 * <p>Examples:</p>
		 * 
		 * <code>
		 * let walletRpc = await monerojs.connectToWalletRpc("http://localhost:38081", "superuser", "abctesting123");<br><br>
		 * 
		 * let walletRpc = await monerojs.connectToWalletRpc({<br>
		 * &nbsp;&nbsp; uri: "http://localhost:38081",<br>
		 * &nbsp;&nbsp; username: "superuser",<br>
		 * &nbsp;&nbsp; password: "abctesting123",<br>
		 * &nbsp;&nbsp; rejectUnauthorized: false // e.g. local development<br>
		 * });<br><br>
		 * 
		 * // connect to monero-wallet-rpc running as internal process<br>
		 * let walletRpc = await monerojs.connectToWalletRpc([<br>
		 * &nbsp;&nbsp; "/path/to/monero-wallet-rpc",<br>
		 * &nbsp;&nbsp; "--stagenet",<br>
		 * &nbsp;&nbsp; "--daemon-address", "http://localhost:38081",<br>
		 * &nbsp;&nbsp; "--daemon-login", "superuser:abctesting123",<br>
		 * &nbsp;&nbsp; "--rpc-bind-port", "38085",<br>
		 * &nbsp;&nbsp; "--rpc-login", "rpc_user:abc123",<br>
		 * &nbsp;&nbsp; "--wallet-dir", "/path/to/wallets", // defaults to monero-wallet-rpc directory<br>
		 * &nbsp;&nbsp; "--rpc-access-control-origins", "http://localhost:8080"<br>
		 * &nbsp; ]);
		 * 
		 * </code>
		 * 
		 * @param {string|string[]|object|MoneroRpcConnection} uriOrConfig - uri of monero-wallet-rpc or terminal parameters or JS config object or MoneroRpcConnection
		 * @param {string} uriOrConfig.uri - uri of monero-wallet-rpc
		 * @param {string} uriOrConfig.username - username to authenticate with monero-wallet-rpc (optional)
		 * @param {string} uriOrConfig.password - password to authenticate with monero-wallet-rpc (optional)
		 * @param {boolean} uriOrConfig.rejectUnauthorized - rejects self-signed certificates if true (default true)
		 * @param {string} username - username to authenticate with monero-wallet-rpc (optional)
		 * @param {string} password - password to authenticate with monero-wallet-rpc (optional)
		 * @param {boolean} rejectUnauthorized - rejects self-signed certificates if true (default true)
		 * @return {MoneroWalletRpc} the wallet RPC client
		 */
		module.exports.connectToWalletRpc = function() { return module.exports.MoneroWalletRpc._connectToWalletRpc(...arguments); };

		/**
		 * <p>Create a Monero wallet using fully client-side WebAssembly bindings to monero-project's wallet2 in C++.<p>
		 * 
		 * <p>Example:</p>
		 * 
		 * <code>
		 * let wallet = await monerojs.createWalletFull({<br>
		 * &nbsp;&nbsp; path: "./test_wallets/wallet1", // leave blank for in-memory wallet<br>
		 * &nbsp;&nbsp; password: "supersecretpassword",<br>
		 * &nbsp;&nbsp; networkType: MoneroNetworkType.STAGENET,<br>
		 * &nbsp;&nbsp; mnemonic: "coexist igloo pamphlet lagoon...",<br>
		 * &nbsp;&nbsp; restoreHeight: 1543218,<br>
		 * &nbsp;&nbsp; server: new monerojs.MoneroRpcConnection("http://localhost:38081", "daemon_user", "daemon_password_123"),<br>
		 * });
		 * </code>
		 * 
		 * @param {object|MoneroWalletConfig} config - MoneroWalletConfig or equivalent config object
		 * @param {string} config.path - path of the wallet to create (optional, in-memory wallet if not given)
		 * @param {string} config.password - password of the wallet to create
		 * @param {string|number} config.networkType - network type of the wallet to create (one of "mainnet", "testnet", "stagenet" or MoneroNetworkType.MAINNET|TESTNET|STAGENET)
		 * @param {string} config.mnemonic - mnemonic of the wallet to create (optional, random wallet created if neither mnemonic nor keys given)
		 * @param {string} config.seedOffset - the offset used to derive a new seed from the given mnemonic to recover a secret wallet from the mnemonic phrase
		 * @param {string} config.primaryAddress - primary address of the wallet to create (only provide if restoring from keys)
		 * @param {string} config.privateViewKey - private view key of the wallet to create (optional)
		 * @param {string} config.privateSpendKey - private spend key of the wallet to create (optional)
		 * @param {number} config.restoreHeight - block height to start scanning frsom (defaults to 0 unless generating random wallet)
		 * @param {string} config.language - language of the wallet's mnemonic phrase (defaults to "English" or auto-detected)
		 * @param {number} config.accountLookahead -  number of accounts to scan (optional)
		 * @param {number} config.subaddressLookahead - number of subaddresses to scan per account (optional)
		 * @param {string} config.serverUri - uri of the wallet's daemon (optional)
		 * @param {string} config.serverUsername - username to authenticate with the daemon (optional)
		 * @param {string} config.serverPassword - password to authenticate with the daemon (optional)
		 * @param {boolean} config.rejectUnauthorized - reject self-signed server certificates if true (defaults to true)
		 * @param {MoneroRpcConnection|object} config.server - MoneroRpcConnection or equivalent JS object providing daemon configuration (optional)
		 * @param {boolean} config.proxyToWorker - proxies wallet operations to a web worker in order to not block the main thread (default true)
		 * @param {fs} config.fs - Node.js compatible file system to use (defaults to disk or in-memory FS if browser)
		 * @return {MoneroWalletFull} the created wallet
		 */
		module.exports.createWalletFull = function() { return module.exports.MoneroWalletFull.createWallet(...arguments); };

		/**
		 * <p>Open an existing Monero wallet using fully client-side WebAssembly bindings to monero-project's wallet2 in C++.<p>
		 * 
		 * <p>Examples:<p>
		 * 
		 * <code>
		 * let wallet1 = await monerojs.openWalletFull(<br>
		 * &nbsp;&nbsp; "./wallets/wallet1",<br>
		 * &nbsp;&nbsp; "supersecretpassword",<br>
		 * &nbsp;&nbsp; MoneroNetworkType.STAGENET,<br>
		 * &nbsp;&nbsp; "http://localhost:38081" // daemon uri<br>
		 * );<br><br>
		 * 
		 * let wallet2 = await monerojs.openWalletFull({<br>
		 * &nbsp;&nbsp; path: "./wallets/wallet2",<br>
		 * &nbsp;&nbsp; password: "supersecretpassword",<br>
		 * &nbsp;&nbsp; networkType: MoneroNetworkType.STAGENET,<br>
		 * &nbsp;&nbsp; serverUri: "http://localhost:38081", // daemon configuration<br>
		 * &nbsp;&nbsp; serverUsername: "superuser",<br>
		 * &nbsp;&nbsp; serverPassword: "abctesting123"<br>
		 * });
		 * </code>
		 * 
		 * @param {MoneroWalletConfig|object|string} configOrPath - MoneroWalletConfig or equivalent config object or a path to a wallet to open
		 * @param {string} configOrPath.path - path of the wallet to open (optional if 'keysData' provided)
		 * @param {string} configOrPath.password - password of the wallet to open
		 * @param {string|number} configOrPath.networkType - network type of the wallet to open (one of "mainnet", "testnet", "stagenet" or MoneroNetworkType.MAINNET|TESTNET|STAGENET)
		 * @param {Uint8Array} configOrPath.keysData - wallet keys data to open (optional if path provided)
		 * @param {Uint8Array} configOrPath.cacheData - wallet cache data to open (optional)
		 * @param {string} configOrPath.serverUri - uri of the wallet's daemon (optional)
		 * @param {string} configOrPath.serverUsername - username to authenticate with the daemon (optional)
		 * @param {string} configOrPath.serverPassword - password to authenticate with the daemon (optional)
		 * @param {boolean} configOrPath.rejectUnauthorized - reject self-signed server certificates if true (defaults to true)
		 * @param {MoneroRpcConnection|object} configOrPath.server - MoneroRpcConnection or equivalent JS object configuring the daemon connection (optional)
		 * @param {boolean} configOrPath.proxyToWorker - proxies wallet operations to a web worker in order to not block the main thread (default true)
		 * @param {fs} configOrPath.fs - Node.js compatible file system to use (defaults to disk or in-memory FS if browser)
		 * @param {string} password - password of the wallet to open
		 * @param {string|number} networkType - network type of the wallet to open
		 * @param {string|MoneroRpcConnection} daemonUriOrConnection - daemon URI or MoneroRpcConnection
		 * @param {boolean} proxyToWorker - proxies wallet operations to a web worker in order to not block the main thread (default true)
		 * @param {fs} fs - Node.js compatible file system to use (defaults to disk or in-memory FS if browser)
		 * @return {MoneroWalletFull} the opened wallet
		 */
		module.exports.openWalletFull = function() { return module.exports.MoneroWalletFull.openWallet(...arguments); };

		/**
		 * <p>Create a wallet using WebAssembly bindings to monero-project.</p>
		 * 
		 * <p>Example:</p>
		 * 
		 * <code>
		 * let wallet = await monerojs.createWalletKeys({<br>
		 * &nbsp;&nbsp; password: "abc123",<br>
		 * &nbsp;&nbsp; networkType: MoneroNetworkType.STAGENET,<br>
		 * &nbsp;&nbsp; mnemonic: "coexist igloo pamphlet lagoon..."<br>
		 * });
		 * </code>
		 * 
		 * @param {MoneroWalletConfig|object} config - MoneroWalletConfig or equivalent config object
		 * @param {string|number} config.networkType - network type of the wallet to create (one of "mainnet", "testnet", "stagenet" or MoneroNetworkType.MAINNET|TESTNET|STAGENET)
		 * @param {string} config.mnemonic - mnemonic of the wallet to create (optional, random wallet created if neither mnemonic nor keys given)
		 * @param {string} config.seedOffset - the offset used to derive a new seed from the given mnemonic to recover a secret wallet from the mnemonic phrase
		 * @param {string} config.primaryAddress - primary address of the wallet to create (only provide if restoring from keys)
		 * @param {string} config.privateViewKey - private view key of the wallet to create (optional)
		 * @param {string} config.privateSpendKey - private spend key of the wallet to create (optional)
		 * @param {string} config.language - language of the wallet's mnemonic phrase (defaults to "English" or auto-detected)
		 * @return {MoneroWalletKeys} the created wallet
		 */
		module.exports.createWalletKeys = function() { return module.exports.MoneroWalletKeys.createWallet(...arguments); };
} (moneroJavascript));
	return moneroJavascript.exports;
}

var moneroJavascriptExports = requireMoneroJavascript();

export { moneroJavascriptExports as default };
